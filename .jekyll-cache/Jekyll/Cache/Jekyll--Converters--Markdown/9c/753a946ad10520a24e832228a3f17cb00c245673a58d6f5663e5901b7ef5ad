I"|	<h1 id="graphql과-sql">GraphQL과 SQL</h1>
<h2 id="sql">SQL</h2>
<p><img src="https://user-images.githubusercontent.com/41617388/80458307-8db24d00-896b-11ea-8841-2b82cfe35f37.png" alt="image" /></p>
<ul>
  <li>Structed Query Language</li>
  <li>엔드 포인트가 여러 개
    <ul>
      <li>ex) /content, /api…</li>
    </ul>
  </li>
</ul>

<h2 id="gql">GQL</h2>
<p><img src="https://user-images.githubusercontent.com/41617388/80458317-930f9780-896b-11ea-9e36-757c833d3442.png" alt="image" /></p>

<ul>
  <li>한 개의 엔드포인트</li>
  <li>데이터 스키마에 따라 쿼리 변경</li>
</ul>

<h1 id="graphql의-특징">GraphQL의 특징</h1>
<h3 id="위계적">위계적</h3>
<ul>
  <li>필드가 중첩 가능</li>
  <li>쿼리와 반환 데이터가 같다.</li>
</ul>

<h3 id="제품-중심적">제품 중심적</h3>
<ul>
  <li>client가 요구하는 데이터, 지원하는 언어 및 런타임에 맞춰 동작한다.</li>
</ul>

<h3 id="엄격한-타입-제한">엄격한 타입 제한</h3>
<ul>
  <li>서버에서 타입 유효성을 검사한다. -&gt; 안전성</li>
</ul>

<h3 id="클라이언트-맞춤-쿼리">클라이언트 맞춤 쿼리</h3>
<h3 id="인트로스펙티브-introspective">인트로스펙티브 (Introspective)</h3>

<h1 id="기존-sql의-단점">기존 SQL의 단점</h1>
<h3 id="over-fetching">over-fetching</h3>
<ul>
  <li>요청한 정보보다 많은 정보를 수신하는 경우</li>
  <li>ex) username만 필요한데 DB에서 user의 모든 정보를 수신</li>
</ul>

<h3 id="under-fetching">under-fetching</h3>
<ul>
  <li>REST에서 어떤 기능을 완성하려고 많은 소스를 요청하는 경우</li>
  <li>ex) 메인페이지에서 /feed, /user…등 여러 request 호출</li>
</ul>

<h3 id="url">URL</h3>
<ul>
  <li>여러 엔드포인트 사용</li>
  <li>URL 설계가 복잡해질 수 있음.</li>
</ul>

<h1 id="graphql이-해결">GraphQL이 해결!</h1>
<h3 id="over-fetching-1">over-fetching</h3>
<ul>
  <li>쿼리를 사용 해 필요한 데이터만 가져올 수 있다.</li>
</ul>

<h3 id="under-fetching--url-free">under-fetching &amp; URL-free</h3>
<ul>
  <li>쿼리를 사용 해 필요한 데이터를 모두 가져올 수 있다.</li>
  <li>엔드포인트를 한 개만 사용하므로 한 번의 호출만 필요하다.</li>
</ul>

<hr />

<p>다음 포스팅엔 graphql 서비스 구현에 필요한 개념들을 정리하겠습니다.</p>

:ET