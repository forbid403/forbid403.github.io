I"q<h1 id="프로그래머스-호텔-방-배정">[프로그래머스] 호텔 방 배정</h1>

<p>Algorithm: 유니온파인드
Created: Apr 30, 2020 4:31 PM
DoubleChk: No
link: https://programmers.co.kr/learn/courses/30/lessons/64063</p>

<h3 id="문제-설명"><strong>문제 설명</strong></h3>

<p><strong>[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]</strong></p>

<p>스노우타운에서 호텔을 운영하고 있는 스카피는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 처음에는 모든 방이 비어 있으며 스카피는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다.</p>

<ol>
  <li>한 번에 한 명씩 신청한 순서대로 방을 배정합니다.</li>
  <li>고객은 투숙하기 원하는 방 번호를 제출합니다.</li>
  <li>고객이 원하는 방이 비어 있다면 즉시 배정합니다.</li>
  <li>고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다.</li>
</ol>

<p>예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1, 3, 4, 1, 3, 1] 일 경우 다음과 같이 방을 배정받게 됩니다.</p>

<p>전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.</p>

<h3 id="제한사항"><strong>[제한사항]</strong></h3>

<ul>
  <li>
    <p>k는 1 이상 10 이하인 자연수입니다.</p>

    <p>12</p>
  </li>
  <li>room_number 배열의 크기는 1 이상 200,000 이하입니다.</li>
  <li>room_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다.</li>
  <li>room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다.
    <ul>
      <li>예를 들어, k = 5, room_number = [5, 5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 이런 경우는 입력으로 주어지지 않습니다.</li>
    </ul>
  </li>
</ul>

<hr />

<h3 id="입출력-예"><strong>[입출력 예]</strong></h3>

<p><a href="Untitled/Untitled%20Database.csv">Untitled</a></p>

<h3 id="입출력-예에-대한-설명"><strong>입출력 예에 대한 설명</strong></h3>

<p><strong>입출력 예 #1</strong></p>

<p>문제의 예시와 같습니다.</p>

<p>첫 번째 ~ 세 번째 고객까지는 원하는 방이 비어 있으므로 즉시 배정받을 수 있습니다. 네 번째 고객의 경우 1번 방을 배정받기를 원했는데, 1번 방은 빈 방이 아니므로, 1번 보다 번호가 크고 비어 있는 방 중에서 가장 번호가 작은 방을 배정해야 합니다. 1번 보다 번호가 크면서 비어있는 방은 [2번, 5번, 6번…] 방이며, 이중 가장 번호가 작은 방은 2번 방입니다. 따라서 네 번째 고객은 2번 방을 배정받습니다. 마찬가지로 5, 6번째 고객은 각각 5번, 6번 방을 배정받게 됩니다.</p>

<hr />

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">map</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>

<span class="kt">long</span> <span class="kt">long</span> <span class="nf">find_room</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">room</span><span class="p">){</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">m</span><span class="p">[</span><span class="n">room</span><span class="p">])</span> <span class="k">return</span> <span class="n">room</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">m</span><span class="p">[</span><span class="n">room</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_room</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="n">room</span><span class="p">]);</span>
<span class="p">}</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">solution</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">k</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">room_number</span><span class="p">){</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">long</span> <span class="kt">long</span><span class="o">&gt;</span> <span class="n">answer</span><span class="p">;</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">long</span> <span class="kt">long</span> <span class="n">room</span> <span class="o">:</span> <span class="n">room_number</span><span class="p">){</span>
        <span class="kt">long</span> <span class="kt">long</span> <span class="n">emptyRoom</span> <span class="o">=</span> <span class="n">find_room</span><span class="p">(</span><span class="n">room</span><span class="p">);</span>
        <span class="n">answer</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">emptyRoom</span><span class="p">);</span>
        <span class="n">m</span><span class="p">[</span><span class="n">emptyRoom</span><span class="p">]</span> <span class="o">=</span> <span class="n">emptyRoom</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>union-find로 푸는 문제</li>
  <li>dfs, 이분탐색 모두 시간 초과가 난다.</li>
  <li>find_room으로 빈 방을 찾는다. 요청한 방이 빈 방이면, 바로 return 한다.</li>
  <li>찾은 방의 부모를 +1로 다음 칸으로 업데이트 해 준다.</li>
  <li>빈 방이 아니면, 그 방의 부모를 dfs 돌린다. (m[room])</li>
  <li>빈 방을 찾을 때까지 반복한다.</li>
  <li>빈 방을 찾으면 +1로 업데이트 해 준다.</li>
  <li>즉, m[room]은 다음 빈 방을 의미한다.</li>
</ul>
:ET