I"u<h1 id="chapter-2-system-structure">Chapter 2. System Structure</h1>

<p>Created By: 성희 배
Last Edited: Jan 30, 2020 11:36 PM
Tags: OS</p>

<h2 id="운영체제-서비스">운영체제 서비스</h2>

<ul>
  <li>사용자 인터페이스
    <ul>
      <li>CLI, GUI, batch interface</li>
    </ul>
  </li>
  <li>프로그램 수행</li>
  <li>입출력 연산</li>
  <li>파일 시스템 조작</li>
  <li>통신
    <ul>
      <li>프로세스 간 통신 (공유 메모리, 메시지 전달)</li>
    </ul>
  </li>
  <li>오류 탐지</li>
  <li>자원 할당</li>
  <li>회계</li>
  <li>보호, 보안</li>
</ul>

<h2 id="시스템-호출-system-calls">시스템 호출 (System Calls)</h2>

<ul>
  <li>System Calls
    <ul>
      <li>운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스 제공</li>
      <li>시스템이 수행하는 작업 하나하나가 모두 system call</li>
      <li>그래서 양이 방대하다. → 응용프로그래머에게 API로 제공</li>
      <li>System call 보다 API를 응용 프로그래머가 선호하는 이유?
        <ul>
          <li>프로그램의 호환성</li>
          <li>API보다 복잡하기 때문</li>
        </ul>
      </li>
      <li>운영체제에 매개 변수 전달 방법
        <ol>
          <li>레지스터에 전달</li>
          <li>메모리 내의 블록, 테이블에 저장</li>
          <li>stack에 push, pop</li>
        </ol>

        <p>→ 1, 2번을 선호한다. 개수나 길이의 제한이 없기 때문</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="시스템-호출의-유형">시스템 호출의 유형</h2>

<h3 id="프로세스-제어">프로세스 제어</h3>

<ul>
  <li>OS는 프로세스를 end(정상), abort(비정상) 종료 할 수 있어야 한다.</li>
  <li>
    <p>한 프로그램을 실행하고 있는 Job이나 process가 다른 프로그램을 load, execute를 요청할 수 있어야 한다.</p>

    <p>→ 이후 제어권을 어떻게 할 것인가 ?</p>

    <p>→ 기존 프로그램으로 돌아간다면, 메모리 블록에 기존 프로그램을 저장</p>

    <p>→ 병행 실행이라면, 새로운 job이나 process 실행</p>
  </li>
  <li>
    <p>프로그램들의 집합을 제어할 수 있어야 한다.</p>

    <p>→ 속성 결정, reset, 종료</p>

    <p>→ 종료 대기, 이벤트 대기 등등</p>

    <p>→ lock()</p>
  </li>
  <li>단일 tasking과 다중 tasking
    <ul>
      <li>단일 (MS-DOS)
        <ul>
          <li>1번에 1개의 프로세스</li>
          <li>메모리에 적재, 덮어씀</li>
        </ul>
      </li>
      <li>다중 (Free BSD)
        <ul>
          <li>프로세스 시작 fork()</li>
          <li>실행 exec()</li>
          <li>백그라운드에서 실행</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="통신">통신</h3>

<ul>
  <li>
    <p>메세지 전달 모델</p>

    <p>→ 호스트 이름, 프로세스 이름을 필수로 알아야 함</p>
  </li>
  <li>
    <p>공유 메모리 모델</p>
  </li>
</ul>

<h2 id="운영체제-구조-os-structure">운영체제 구조 (OS Structure)</h2>

<h3 id="간단한-구조">간단한 구조</h3>

<ul>
  <li>MS-DOS
    <ul>
      <li>인터페이스와 기능 계층이 잘 분리되지 X → 보안상의 문제가 있음</li>
    </ul>
  </li>
  <li>UNIX
    <ul>
      <li>계층들로 이루어짐</li>
      <li>커널에서 많은 기능 수행</li>
      <li>모놀리식 (monolithic)
        <ul>
          <li>구현, 유지보수 hard</li>
          <li>시스템 인터페이스, 커널 내부에서의 호출은 오버헤드가 거의 X</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="계층적-접근">계층적 접근</h3>

<ul>
  <li>하드웨어 지원이 있어 구현자들은 내부 동작과 모듈식 운영체제 생성에 변화를 줄 수 있게 됐다.</li>
  <li>운영체제가 여러 층으로 나눠짐
    <ul>
      <li>최하위(0)는 하드웨어, 최상위(N)는 사용자 인터페이스</li>
      <li>구현과 디버깅이 간단하다</li>
      <li>하위 수준의 층에 제공된 연산들만 사용해 구현한다</li>
      <li>다른 유형보다 효율성이 낮다
        <ul>
          <li>연산 수행 시 층별로 호출해야 한다 → 오버헤드 우려</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="마이크로-커널">마이크로 커널</h3>

<ul>
  <li>보다 적은 커널</li>
  <li>중요치 않은 프로그램들은 커널에서 제거, 그것을 시스템 및 사용자 수준 프로그램으로 구현</li>
  <li>클라이언트 프로그램 ↔ 서비스간의 통신을 제공한다.
    <ul>
      <li>메시지 전달로 간접적으로 상호 작용</li>
    </ul>
  </li>
  <li>운영체제의 확장이 용이하다
    <ul>
      <li>새로운 서비스들은 사용자 공간에 추가, 커널은 변경 X</li>
      <li>다른 하드웨어로 이식이 쉽다</li>
    </ul>
  </li>
  <li>높은 보안성과 신뢰성
    <ul>
      <li>대부분이 사용자 프로세스로 수행되기 때문</li>
    </ul>
  </li>
  <li>ex) 매킨토시, QNX</li>
</ul>

<h3 id="모듈">모듈</h3>

<ul>
  <li>적재 가능 커널 모듈 (loadable kernel modules)</li>
  <li>커널 : 핵심 서비스 제공</li>
  <li>
    <p>다른 서비스 : 커널 실행 중 동적으로 구현</p>

    <p>→ 커널에 추가하는 것 보다 바람직하다</p>
  </li>
  <li>커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조와 비슷</li>
  <li>하지만 모듈에서 다른 모듈을 호출 가능하다 → 계층보다 유연함</li>
  <li>중심 모듈은 핵심 기능만을 가지고 다른 모듈의 적재 방법, 모듈간 통신은 마이크로와 비슷</li>
  <li>하지만 메시지 전달을 호출 할 필요가 X → 마이크로보다 효율적</li>
</ul>

<h3 id="혼용-시스템">혼용 시스템</h3>

<ul>
  <li>안드로이드, ios, 맥</li>
</ul>

<h3 id="운영체제-디버깅">운영체제 디버깅</h3>

<ul>
  <li>병목 현상 제거</li>
  <li>성능 조정</li>
</ul>

<h3 id="장애-분석">장애 분석</h3>

<ul>
  <li>로그 파일 기록</li>
  <li>코어 덤프 (프로세스가 사용하던 메모리 캡쳐) 후 파일로 저장</li>
  <li>커널 장애 → 충돌 (crash)</li>
  <li>충돌 덤프 (crash dump)</li>
</ul>

<h2 id="시스템-부트">시스템 부트</h2>

<ul>
  <li>부트스트랩 프로그램 or 부트스트랩 로더가</li>
  <li>커널을 찾고 → 메모리에 적재 후 → 수행</li>
  <li>ROM에 저장된다</li>
  <li>부트 스트랩 코드가 변경 시 ROM을 교체해야 함 → EPROM으로 개선</li>
  <li>ROM == firmware</li>
</ul>
:ET