I"e'<h1 id="징검다리-건너기">징검다리 건너기</h1>

<p>Algorithm: 이분탐색
Created: Apr 27, 2020 7:53 PM
DoubleChk: No
Type: 프로그래머스
level: 3
link: https://programmers.co.kr/learn/courses/30/lessons/64062</p>

<h3 id="문제-설명"><strong>문제 설명</strong></h3>

<p><strong>[본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]</strong></p>

<p>카카오 초등학교의 니니즈 친구들이 라이언 선생님과 함께 가을 소풍을 가는 중에 <strong>징검다리</strong>가 있는 개울을 만나서 건너편으로 건너려고 합니다. 라이언 선생님은 니니즈 친구들이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.</p>

<ul>
  <li>징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.</li>
  <li>디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.</li>
  <li>단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.</li>
</ul>

<p>니니즈 친구들은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.니니즈 친구들은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.</p>

<p>디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.</p>

<h3 id="제한사항"><strong>[제한사항]</strong></h3>

<ul>
  <li>징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.</li>
  <li>stones 배열의 크기는 1 이상 200,000 이하입니다.</li>
  <li>stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.</li>
  <li>k는 1 이상 stones의 길이 이하인 자연수입니다.</li>
</ul>

<hr />

<h3 id="입출력-예"><strong>[입출력 예]</strong></h3>

<p><a href="Untitled/Untitled%20Database.csv">Untitled</a></p>

<h3 id="입출력-예에-대한-설명"><strong>입출력 예에 대한 설명</strong></h3>

<hr />

<p><strong>입출력 예 #1</strong></p>

<p>첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.</p>

<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4560e242-cf83-4e77-a14c-174f3831499d/step_stones_104.png" alt="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/4560e242-cf83-4e77-a14c-174f3831499d/step_stones_104.png" /></p>

<p>첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.</p>

<p>두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.</p>

<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d64f29ac-3e35-4fd3-91fa-4d70e3b6c80a/step_stones_101.png" alt="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d64f29ac-3e35-4fd3-91fa-4d70e3b6c80a/step_stones_101.png" /></p>

<p>두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.</p>

<p>세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.</p>

<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/369bc8a1-7017-4135-a499-505247ab9cfc/step_stones_102.png" alt="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/369bc8a1-7017-4135-a499-505247ab9cfc/step_stones_102.png" /></p>

<p>세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.</p>

<p>네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.</p>

<p><img src="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e44e0a83-e637-48ad-858c-4c135c3b078f/step_stones_103.png" alt="https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/e44e0a83-e637-48ad-858c-4c135c3b078f/step_stones_103.png" /></p>

<p>따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.</p>

<hr />

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="kt">bool</span> <span class="nf">check</span><span class="p">(</span><span class="n">vector</span> <span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">stones</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">){</span>
    <span class="kt">int</span> <span class="n">cntZero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">stones</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="k">if</span><span class="p">(</span><span class="n">stones</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">mid</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">){</span>
            <span class="n">cntZero</span><span class="o">++</span><span class="p">;</span>
            <span class="k">if</span><span class="p">(</span><span class="n">cntZero</span> <span class="o">&gt;=</span> <span class="n">k</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">cntZero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
        
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">stones</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    
    <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">200000001</span><span class="p">;</span>
    
    <span class="k">while</span><span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">){</span>
        
        <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">isCrossed</span> <span class="o">=</span> <span class="n">check</span><span class="p">(</span><span class="n">stones</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
        
        <span class="k">if</span><span class="p">(</span><span class="n">isCrossed</span><span class="p">){</span>
            <span class="c1">//좀더 건널 수 있는지 확인</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
        
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>이분 탐색으로 푸는 문제이다.</li>
  <li>0이 연속해서 K개 이상 나온다면 건널 수 없다는 것까지는 풀었지만, 시간 초과로 인해 틀렸다. 돌의 높이가 2억이 넘으므로 nlogn의 시간 복잡도로 해결 해야 했다.</li>
  <li>mid를 넘을 수 있는 니니즈라고 생각하고 연속된 0이 k개 이상 인지 아닌지를 확인한다.</li>
  <li>건널 수 있다면, left를 더 늘려 좀 더 많은 니니즈도 건널 수 있는지 확인한다.</li>
  <li>건널 수 없다면, right를 줄여 좀 더 적은 니니즈는 건널 수 있는지 확인한다.</li>
  <li>left ≤ right를 충족하면, left를 리턴한다.</li>
</ul>
:ET