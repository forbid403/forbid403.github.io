---
date: 2020-01-30
categories: os
---
# Chapter 2. System Structure

Created By: 성희 배
Last Edited: Jan 30, 2020 11:36 PM
Tags: OS

## 운영체제 서비스

- 사용자 인터페이스
    - CLI, GUI, batch interface
- 프로그램 수행
- 입출력 연산
- 파일 시스템 조작
- 통신
    - 프로세스 간 통신 (공유 메모리, 메시지 전달)
- 오류 탐지
- 자원 할당
- 회계
- 보호, 보안

## 시스템 호출 (System Calls)

- System Calls
    - 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스 제공
    - 시스템이 수행하는 작업 하나하나가 모두 system call
    - 그래서 양이 방대하다. → 응용프로그래머에게 API로 제공
    - System call 보다 API를 응용 프로그래머가 선호하는 이유?
        - 프로그램의 호환성
        - API보다 복잡하기 때문
    - 운영체제에 매개 변수 전달 방법
        1. 레지스터에 전달
        2. 메모리 내의 블록, 테이블에 저장
        3. stack에 push, pop

        → 1, 2번을 선호한다. 개수나 길이의 제한이 없기 때문

## 시스템 호출의 유형

### 프로세스 제어

- OS는 프로세스를 end(정상), abort(비정상) 종료 할 수 있어야 한다.
- 한 프로그램을 실행하고 있는 Job이나 process가 다른 프로그램을 load, execute를 요청할 수 있어야 한다.

    → 이후 제어권을 어떻게 할 것인가 ?

    → 기존 프로그램으로 돌아간다면, 메모리 블록에 기존 프로그램을 저장

    → 병행 실행이라면, 새로운 job이나 process 실행

- 프로그램들의 집합을 제어할 수 있어야 한다.

    → 속성 결정, reset, 종료

    → 종료 대기, 이벤트 대기 등등

    → lock()

- 단일 tasking과 다중 tasking
    - 단일 (MS-DOS)
        - 1번에 1개의 프로세스
        - 메모리에 적재, 덮어씀
    - 다중 (Free BSD)
        - 프로세스 시작 fork()
        - 실행 exec()
        - 백그라운드에서 실행

### 통신

- 메세지 전달 모델

    → 호스트 이름, 프로세스 이름을 필수로 알아야 함

- 공유 메모리 모델

## 운영체제 구조 (OS Structure)

### 간단한 구조

- MS-DOS
    - 인터페이스와 기능 계층이 잘 분리되지 X → 보안상의 문제가 있음
- UNIX
    - 계층들로 이루어짐
    - 커널에서 많은 기능 수행
    - 모놀리식 (monolithic)
        - 구현, 유지보수 hard
        - 시스템 인터페이스, 커널 내부에서의 호출은 오버헤드가 거의 X

### 계층적 접근

- 하드웨어 지원이 있어 구현자들은 내부 동작과 모듈식 운영체제 생성에 변화를 줄 수 있게 됐다.
- 운영체제가 여러 층으로 나눠짐
    - 최하위(0)는 하드웨어, 최상위(N)는 사용자 인터페이스
    - 구현과 디버깅이 간단하다
    - 하위 수준의 층에 제공된 연산들만 사용해 구현한다
    - 다른 유형보다 효율성이 낮다
        - 연산 수행 시 층별로 호출해야 한다 → 오버헤드 우려

### 마이크로 커널

- 보다 적은 커널
- 중요치 않은 프로그램들은 커널에서 제거, 그것을 시스템 및 사용자 수준 프로그램으로 구현
- 클라이언트 프로그램 ↔ 서비스간의 통신을 제공한다.
    - 메시지 전달로 간접적으로 상호 작용
- 운영체제의 확장이 용이하다
    - 새로운 서비스들은 사용자 공간에 추가, 커널은 변경 X
    - 다른 하드웨어로 이식이 쉽다
- 높은 보안성과 신뢰성
    - 대부분이 사용자 프로세스로 수행되기 때문
- ex) 매킨토시, QNX

### 모듈

- 적재 가능 커널 모듈 (loadable kernel modules)
- 커널 : 핵심 서비스 제공
- 다른 서비스 : 커널 실행 중 동적으로 구현

    → 커널에 추가하는 것 보다 바람직하다

- 커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조와 비슷
- 하지만 모듈에서 다른 모듈을 호출 가능하다 → 계층보다 유연함
- 중심 모듈은 핵심 기능만을 가지고 다른 모듈의 적재 방법, 모듈간 통신은 마이크로와 비슷
- 하지만 메시지 전달을 호출 할 필요가 X → 마이크로보다 효율적

### 혼용 시스템

- 안드로이드, ios, 맥

### 운영체제 디버깅

- 병목 현상 제거
- 성능 조정

### 장애 분석

- 로그 파일 기록
- 코어 덤프 (프로세스가 사용하던 메모리 캡쳐) 후 파일로 저장
- 커널 장애 → 충돌 (crash)
- 충돌 덤프 (crash dump)

## 시스템 부트

- 부트스트랩 프로그램 or 부트스트랩 로더가
- 커널을 찾고 → 메모리에 적재 후 → 수행
- ROM에 저장된다
- 부트 스트랩 코드가 변경 시 ROM을 교체해야 함 → EPROM으로 개선
- ROM == firmware