---
date: 2020-01-30
categories: os
---

# 프로세스
## 프로세스
- job이라고도 부른다.
- 실행 중인 프로그램
- 시분할 시스템에서의 작업의 단위


## 프로그램
- 명령어 리스트를 내용으로 가진 수동적인 (passive) 존재
- cf) 프로세스는 다음에 실행할 명령어를 지정하는 Program Counter, 관련 자원의 집합을 가진 능동적인 (active) 존재이다.


## 프로세스는 독립적이다.
- 텍스트 세션은 같을지라도 data, heap, stack은 다를 수 있다.
- ex) chrome 탭은 프로세스인가 스레드인가?
  - 브라우저 프로세스는 chrome이 실행 될 때 한번만 실행이 된다.
  - 하나의 탭이 고장난다고 해서 다른 탭이 고장나지 않으므로 프로세스이다. 각각의 탭은 서로 독립적인 존재이다. 각각의 탭마다 렌더러 프로세스가 생성이 된다.


## 프로세스 상태
![image](https://user-images.githubusercontent.com/41617388/83322393-3e28af00-a292-11ea-84ca-afe923af3645.png)
- 하나의 처리기엔 하나의 프로세스만 실행중이어야 한다.


## PCB (Process Control Block)
![image](https://user-images.githubusercontent.com/41617388/83322414-69ab9980-a292-11ea-9feb-883a88a81876.png)

- 각 프로세스는 PCB에 의해 표현된다.
- 프로세스마다 달라지는 모든 정보를 저장한다.
- `Program Counter` : 다음 실행 할 명령어의 주소

# 

# 프로세스 스케쥴링
- CPU 이용률을 최대화 해야하기 때문에 항상 프로세스가 실행되는 것이 좋다.
- 프로세스 스케쥴러는 process중 하나를 선택한다.


## Scheduling Queue
- 새로운 프로세스 생성 시 Job큐에 넣는다.
- Job 큐는 시스템의 모든 프로세스가 들어있고, 주 메모리에 존재한다.
- 준비 상태가 되면 Ready큐에 저장된다. 이는 연결리스트로 저장된다.
- CPU에서 자원을 할당 해 주면,
  - 입출력 요청 -> 입출력 큐 -> waiting -> ready 큐로 이동
  - 자식 프로세스 생성 후 대기 -> waiting -> ready 큐로 이동
  - 인터럽트로 CPU에서 제거

- 종료되면 큐에서 삭제되고, pcb와 자원 반납


## 스케쥴러
- 장기 스케쥴러
  - 메모리 내부의 프로세스 수 제어
  - new-> ready, running -> terminate
  - 메모리와 디스크 사이의 스케쥴링
- 단기 스케쥴러
  - 실행되는 프로세스들 제어
  - ready -> running -> waiting -> ready
  - 메모리와 cpu 사이의 스케쥴링
- 중기 스케쥴러
  - 다중 프로그래밍의 정도를 완화하기 위해 프로세스를 제거(swap-out)하고 완화된 후 다시 불러옴
  - 이를 swapping이라고 함


## Context Switching
- 인터럽트 이후에 문맥을 복구하는 작업
- 이전의 프로세스 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업 필요. -> 순수한 오버헤드이다.  

#

# 프로세스에 대한 연산
## 프로세스 생성
- 부모, 자실 트리형식으로 프로세스 생성
- pid로 구별
- 프로세스가 자식 프로세스 생성 시
  - 부모, 자식 병행 실행하거나
  - 부모가 자식이 끝날 때까지 대기

- 주소 공간 측면에서는
  - 자식 프로세스는 부모의 복사본이거나
  - 자식 프로세스는 새로운 프로그램을 가진다.

- `fork()` 새로운 프로세스 생성
- `exec()` 실행
- `wait()` 대기

- `pid < 0` 오류
- `pid == 0` 자식
- `pid > 0` 부모


## 프로세스 종료
- 운영체제에 `exit()`호출을 사용해 종료 요청
- 상태값, 자원을 return 한다. -> 이 작업은 waiting 시에 실행 됨
- 부모가 자식을 삭제하는 경우
  - 할당된 자원을 초과 사용
  - Task가 불필요해짐
  - 부모 exit 후 자식 실행을 os에서 허용하지 않을 경우 -> 연쇄식 종료
- wait 호출이 되지 않았는데도 종료된 프로세스를 zombie 프로세스라고 한다.
- 모든 프로세스는 잠깐동안 zombie 프로세스가 된다. (exit->waiting 시의 갭 때문에)
- 그 외의 경우는 Orphan process(고아 프로세스)라고 한다.
- 이 경우 linux, unix에서는 Init 명령어로 프로세스들을 검사하면서 orphan 프로세스들을 제거한다.

#

# 프로세스간 통신 (InterProcess Communication) a.k.a. IPC
- 독립적 or 협력적
- 협력적인 경우
  - 정보 공유가 필요한 경우
  - 계산 가속화가 필요한 경우
  - 모듈성이 필요한 경우
  - 편의성이 필요한 경우 (다중 task 실행)
- 이런 협력적인 프로세스들은 프로세스간 통신이 필요하다.


## 공유 메모리 시스템
- 공유 메모리를 구축하여, 프로세스가 이 영역을 공유한다.
- read, write를 사용하여 통신을 수행한다.
- 메시지 패싱 시스템과 달리 전달이 필요 없기 때문에 성능 측에서 더 낫다.
- OS의 관여 없이 통신 가능하다.
- 구현이 어렵다는 단점이 있다.
- 동기화 문제를 신경 써줘야 한다!
- ex) 데이터베이스

## 메시지 전달 시스템
- 공유되는 메모리 없이 커널을 경유하여 프로세스간 메시지를 전달할 수 있다.
- 동기화가 되어있다.
- 분산 네트워크 환경에서 유용하다.
- send, receive를 사용하여 통신을 수행한다.
- 구현하기 간단하다.
- 커널을 거치므로, 속도가 느리다는 단점이 있다.

- 통신 연결과 통신 구현 종류는 다음과 같다.
# 
## 명명 (Naming)
- 간접통신과 직접 통신으로 나뉜다.

### 간접 통신
-   Mailbox, Port
-   1:N으로 연결 될 수 있다.
-   1. 프로세스가 mailbox를 가지는 경우
    -   어떤 프로세스가 메시지를 받는지 신경 써야 한다.
    -   메일박스를 가지는 프로세스가 종료 될 경우 다른 프로세스가 삭제되었음을 알아야 한다.
-   2. 운영체제가 mailbox를 가지는 경우
    -   독립적으로 운영된다.


### 직접 통신
- 수신, 송신자 이름을 명시하여 연결한다.
- 1:1로 연결된다.


## 동기화
- blocking : 수신, 혹은 송신 완료 때까지 봉쇄
- non-blocking : 수신, 혹은 송신 완료 시 다른 작업 실행

## 버퍼링
- 메시지 큐 구현 방식
- 1. 무용량
  - 용량이 0이므로 봉쇄형이다.
  - 메시지가 들어오면 그 메시지를 pop 할 때까지 다른 메시지가 들어올 수 없음
- 2. 유한 용랑
  - 용량이 n이다.
  - 용량이 꽉 차기 전까지는 비봉쇄, 꽉 차면 봉쇄
- 3. 무한 용량
  - 비봉쇄

#
# 클라이언트 서버 시스템에서의 통신
## 소켓
- 응용 프로그램 2개가 통신 시, 2개의 소켓이 만들어지고 통신 채널 양단에 하나씩 배정 됨

## 원격 프로시저 호출
- 한 프로세스가 원격지의 프로시저를 호출할 때 사용

## 파이프
### 일반 파이프
- 생산자 - 소비자 형태
- 단방향 통신만 지원
- 관련된 프로세스만 공유 가능

### 지명 파이프
- 좀 더 강력한 통신
- 부모 - 자식X
- 양방향
- 반이중
- 모든 프로세스 공유 가능