---
title: "[OS] Ch6. 연습문제"
date: 2020-10-23
categories: os
---

### 4. 동기화 프리미티브가 사용자 수준 프로그램에서 사용되는 경우, 단일 처리기 시스템에서 인터럽트 불능을 이용하여 동기화 프리미티브를 구현하는 것이 왜 부적당한지 설명하시오.
- 만약 사용자 수준에서 인터럽트 불능을 할 수 있다면 문맥 교환을 막거나 타이머 인터럽트를 불능 시킬 수 있기 때문에 다른 프로세스가 실행 되지 않을 수 있다.

### 5. 다중 처리기 시스템을 위한 동기화 프리미티브를 구현할 때 인터럽트를 사용하는 것이 부적합한 이유를 설명하시오.
- 다중 처리기 시스템에서 인터럽트를 사용하는 것은 효율적이지 않다. 인터럽트가 하나의 코어에서만 작동한다면 다른 프로세스들이 공유 자원에 접근하게 되기 때문에 동기화가 되지 않을 것이다. 모든 코어에서 작동하게 된다면 모든 프로세스들에서 I/O 작업, task dispatching 등도 같이 멈추기 때문에 CPU 사용률이 현저히 떨어지게 될 것이다.

### 6. Linux 커널은 정책적으로 세마포를 획득하려고 시도 중인 프로세스는 스핀락을 가질 수 없게끔 제한한다. 이 정책이 사용되는 이유는 무엇인가?
- 스핀락은 다른 프로세스가 짧은 시간 동안 점유 할 경우에 주로 사용된다. 세마포는 문맥 교환을 2번 하는게 더 나은 경우에 쓰이기 때문에, 그만큼 오랜 시간동안 임계 구역을 점거한다는 의미이다. 따라서 세마포를 획득하려고 시도 중이라면, 그만큼 많은 시간을 필요로 하는 프로세스이기 때문에 스핀락은 효율적이지 못한 정책이다.

### 7. 경쟁 조건이 발생할 가능성이 있는 커널 자료구조 2개를 기술하시오. 경쟁 조건이 어떤 경우에 발생할 수 있는지에 대한 설명이 반드시 포함되어야 한다.
- 메모리 할당을 관리하는 자료구조
  - 같은 주소 번지에 할당하려고 할 때 경쟁 조건이 발생할 수 있다.
- 프로세스 리스트를 유지하는 자료구조
  - 프로세스가 동시에 생성되는 경우 pid를 부여 할 때 경쟁 조건이 발생할 수 있다.

### 11. 시스템이 다중 처리 코어를 가지고 있다고 가정하자. 다음 각 시나리오에 대해 스핀락과 mutex락 중 어떤 것이 더 좋은 락킹 기법인지 설명하시오. mutex락은 기다리는 프로세스가 락의 사용이 가능해질 때까지 기다리는 동안 수면상태에 들어가게 된다.
- 락은 짧은 동안만 사용된다.
  - 스핀락
- 락은 긴 시간 동안 사용된다.
  - 뮤텍스
- 스레드가 락을 가진 채로 수면 상태로 들어갈 수 있다.
  - 뮤텍스

### 19. 동일한 유형의 동기화 문제를 푸는 데 사용될 수 있다는 측면에서 모니터와 세마포가 동등함을 보이시오.
- 모니터 내부의 프로세스들 중 하나만이 활성화 되고 나머지는 대기한다는 측면에서 세마포도 signal과 wait을 사용하여 프로세스의 실행 순서를 정할 수 있다. 프로세스간 실행 순서를 정해 두면 하나의 프로세스가 끝나기 전까지는 다른 프로세스가 끝나지 않으므로 동기화 문제를 해결할 수 있다.
- 둘 다 counter와 waiting queue를 사용한다. 모니터는 resource를 캡슐화 할 수 있으므로 좀 더 나은 방안이다.

### 23. 모니터의 signal() 연산과 세마포에서 정의한 signal() 연산이 어떻게 다른지 설명하시오.
- 모니터의 signal()은 하나의 보류된 프로세스를 재개 시킨다. 보류된 프로세스가 없다면 아무런 동작을 하지 않는것과 같다.
- 세마포의 signal()은 락을 방출하는 행위이다. 기다리는 프로세스가 없더라도 semaphore의 값이 하나 올라간다.

### What is the meaning of busy waiting? What are the other kinds of waiting in operating system? Can busy waiting be avoided altogether? Explain.
- 바쁜 대기란 프로세서를 포기하지 않고 계속 루프 문을 돌면서 조건을 만족하기를 기다리는 것이다.
- 프로세서가 해당 프로세스를 포기 하고 적합한 때에 다시 깨우는 대기 방법도 있다.
- 바쁜 대기를 피할 순 있지만, 프로세스를 재우고 깨우는 데에 오버헤드가 발생할 수 있기 때문에 짧은 시간을 가지는 프로세스에서는 바쁜 대기를 사용하는 것이 좋다.

### Explain why spinlocks are not appropriate for single processor systems yet are often used in multiprocessor environments.
- 싱글코어에서는 하나의 프로세스만이 실행 될 수 있다. 따라서 스핀락을 종료하려면 문맥 교환을 통해 다른 프로세스를 실행하는 방법 밖에 없다. 스핀락은 의미 없는 행위이다.

