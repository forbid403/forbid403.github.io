var store = [{
        "title": "1227 TIL",
        "excerpt":"Created By: forbid403 Last Edited: Dec 27, 2019 11:38 PM   MVP 패턴 (Model-View-Presenter)   → View와 Model이 독립적임   Model ← Notify - Presenter ← getter, setter 제공 - View   → View는 일종의 VO   → interaction은 Presenter가 담당.      Model            비즈니스 로직과 어플리케이션 데이터 (인증, 가계 정보)           View            이벤트를 프리젠터에 전달 (로그인 버튼을 클릭하면 프리젠터에 인증 실행 요청)       사용자에게 알맞은 화면 제공 (프리젠터를 통해 전달받은 데이터를 위젯을 통해 표현, 로딩 중, 경고 대화창 등 안내)           Presenter            사용자 요청에 반응 (뷰 - 인증요청, 모델 - 인증 수행, 뷰에 모델에서 수행한 결과를 전달)       뷰의 흐름 제어 (인증 시작 전에 뷰를 통해 진행 중 대화창을 보여주고, 인증에 성공하면 뷰를 통해 메인화면으로 이동)             구현   뷰      인터페이스            사용자에게 보여질 기능을 정의       프리젠터가 호출할 기능       데이터 출력 기능, 진행 중 알림 기능           뷰 구현체            인터페이스에 정의한 기능의 구현 제공       사용자 이벤트를 프리젠터에 전달       데이터를 리스트로 표시, 사용자가 항목을 클릭하면 프리젠터에 선택 요청 전달               public interface StoreListView{     \tvoid showLoadintMessage();     }      public class showLoadingMessage(){     \tprogress = ProgressDialog.show(this, \"\", \"로딩중\");     }   프리젠터      사용자의 UI 행위를 추상화한 메서드로 기능을 정의   뷰 구현에 의존하지 않는다       public class StoreListPresent{   \tprivate StoreListView view;   \tprivate StoreListModel model;   \tpublic void onLocationChange(Coord location){   \t\tviewShowLoadingMessage();   \t\ttry{   \t\t\tList &lt;Store&gt; stores = model.getStoresIn(location, 100);   \t\t\tview.hideLoadingMessage();   \t\t\tview.displayStores(stores);   \t\t}catch(Exeption e){   \t\t\tview.hideLoading();   \t\t\tview.showFailMessage();   \t\t}   \t}   }                프리젠터에 비동기 결과 전달 방법 필요            콜백 (Callback), 옵저버 (Observer) 등           Activity/fragment 라이프사이클에 맞춰 기능을 구현해야 할 경우, 프리젠터에 라이프 사이클 관련 메서드 정의   모델에 다양한 로직이 있다면 unit test 가능한 구조로 만들자   프리젠터 먼저 구현하기  ","categories": ["til"],
        "tags": [],
        "url": "/til/1227-TIL/",
        "teaser": null
      },{
        "title": "1228 TIL",
        "excerpt":"Created By: forbid403 Last Edited: Dec 29, 2019 12:27 AM   try-catch-finally      throw (발생시키다)            예외를 알린다           if (x &lt; 0) { throw new Error('x는 음수가 아니어야 합니다.') }                           catch (잡아내다)            예외를 처리한다           finally            항상 실행이 보장되어야 함       try 블록이 일부라도 실행 되면 finally 블록의 실행은 보장               도커란?      여러 서버를 사용 하면 버젼 관리 등 환경설정을 바꾸거나 해야 한다.        DevOps의 발전으로 개발 주기는 빨라지고 관리는 복잡해진다.       → 그래서 나온게 컨테이너 기반의 오픈소스 가상화 플랫폼인 도커!       컨테이너 : 격리된 공간에서 프로세스가 동작하는 기술   기존의 가상화 방식 : OS를 가상화 (VirtualWare)   layer를 사용해서 유니온 파일 시스템으로 한 개의 파일시스템으로 사용할 수 있음   명령어      –publish : forward traffic incoming on port 8000 to 8080 (호스트의 포트에 맞추어 forward)   –detach : 백그라운드에서 도커 run   –name : 이름 부여   ","categories": ["til"],
        "tags": [],
        "url": "/til/1228-TIL/",
        "teaser": null
      },{
        "title": "1229 TIL",
        "excerpt":"Created By: forbid403 Last Edited: Dec 29, 2019 2:50 PM   Docker + Node.js      이미지 생성            Dockerfile 사용           이미지 빌드            docker build –tag 태그명:버젼명 Dockerfile경로                    ex) docker build –tag node_server:0.0.1 .                       Dockerfile이 같은 디렉토리라면 .       docker images로 이미지들 확인 가능           컨테이너 생성            docker create –name 서버이름 -p 외부포트:내부포트 이미지명:버전명                    ex) docker create –name NDE_SERVER -p 3000:3000 node_server:0.0.1                           컨테이너 생성            docker start 컨테이너명                    ex) docker start NDE_SERVER                              이미지 삭제            docker rmi -f 이미지 해쉬 코드           컨테이너 삭제            docker rm -f 컨테이너명          ","categories": ["til"],
        "tags": [],
        "url": "/til/1229-TIL/",
        "teaser": null
      },{
        "title": "1230 TIL",
        "excerpt":"1230 TIL   Created By: 성희 배 Last Edited: Dec 30, 2019 10:50 PM   ES6 : Arrow Function      function 사용 안함   (인자) ⇒   short-hand syntax   arrow function은 자신의 this, arguments, super, new.target을 바인딩 하지 않는다.       const event = {       name : 'Birthday Party',       guestList :['Andrew', 'Sonia', 'Mike'],       printGuestList(){            console.log('Guest list for ' + this.name)           this.guestList.forEach((guest)=&gt;{               console.log(guest + ' is attending ' + this.name)           })       }   }           메소드 함수가 아닌 곳에 가장 적합   concise 바디는 return 불필요 / block 바디는 return 필요       const square = x =&gt; x*x //concise body           객체 리터럴 반환 : 괄호로 감싸기       const func = ()=&gt; ({foo:1})                Async/Await      JS는 비동기적 언어 → 동기화가 필요 (setTimeout, callback, promise)   setTimeout      특정 시간 동안 delay   setTimeout은 첫 번째 task 내에 별도의 task 생성 후 첫 번째 task가 종료되길 기다림.       let first = 10   let second = 20   let result = 0        function add(x, y) {     return x + y   }   function getResult(callback) {     setTimeout(function() {       result = add(first, second)       console.log(result) // 30       callback()     }, 1000)   }        getResult(function() {     first = 20   })          → 따라서 결과는 30이 아닌 40이 나온다.       callback      callback?            호출하는 함수 (calling function)가 호출되는 함수(called 함수)로 전달하는 함수를 말한다.           callback 함수의 제어권은 호출되는 함수에게 있음   비동기 코드를 동기식으로 처리하기 위해 사용. (네트워크 요청)   남발할 시 코드의 복잡도, 에러 발생 확률 올라감   promise      어떤 작업이 성공 (resolve) 됐을 때, promise 객체의 then() 함수에 넘겨진 파라미터(함수)를 단 한번만 호출하겠다는 약속   파라미터가 단 한 번만 실행되기 때문에 안정성 높음   실패(reject) 했을 경우에도 catch() 함수를 통해 실패 이후의 작업 처리 가능   async &amp; await      function 키워드 앞에 async 부착, 비동기로 처리되는 부분 앞에 await 부착   await 뒷 부분이 반드시 promise 반환   async도 promise 반환   async,await =&gt; 제너레이터,이터레이터 + 프로미스  ","categories": ["til"],
        "tags": [],
        "url": "/til/1230-TIL/",
        "teaser": null
      },{
        "title": "1231 TIL",
        "excerpt":"1231 TIL   Created By: 성희 배 Last Edited: Dec 31, 2019 12:53 PM   Disjoint Set (서로소 집합, 상호 배타 집합)      union(x, y) → x, y 같은 집합 만들기   find(x) → x와 y가 같은 집합에 속하면 같은 값   make_set(x) → 새로운 집합 만들기  ","categories": ["til"],
        "tags": [],
        "url": "/til/1231-TIL/",
        "teaser": null
      },{
        "title": "0102 TIL",
        "excerpt":"0102 TIL   Created By: 성희 배 Last Edited: Jan 03, 2020 1:49 AM Tags: til   Server   → API (interface) : 상호 작용을 하는 프로그램   Protocol   → HTTP   서버/클라이언트간 통신 약속 → 이런 문법대로 써야 알아먹는다.   request/response   client가 얘기하면 서버가 응답 → 서버는 응답밖에 못함   method : get/post   → web socket   실시간 통신용   Server   → program   → package manager (gradle, npm …)   Network   → DNS : ip를 사용해 접속   → TCP/IP   Framework   → 어쨌든 통신 하는 것은 비슷함 : framework 제공   → 서버 개발자는 handling을 하는 부분만 개발   handling : req→res   API Server   → client ↔ server ↔ db server   → Database   RDB : excel → Data들이 어떻게 저장하고 조회하는지 제공 (규약이 있음) : select, insert, delete 등   Scheme을 무조건 적어야 함   NoSQL : column이 계속 바뀜   Scheme가 없음 → create table을 강제하지 않음   Key/Val : column이 없음, Map&lt;key, val&gt; 형식   ex) redis   Search Engine : 검색   ex) elastic search   Auth   → ip로 사용자 구분이 어려움 (매번 바뀜)   → header에 token을 보냄   → Authentication (인증) : 사용자를 구분   → Authorization (허가) : 서버에서 정보를 받아올 수 있는지   암호화   → 통신 단에서 내용을 암호화 하겠다.   → release는 무조건 https   → Information architecture   사용자 입장에서 어떻게 제공 되어야 하는지, 데이터 구조나 데이터 양 등 여러 변수를 고려 해야 함     Prototype      JS에서 객체를 생성 할 때 prototype이 생성된다.   proto (prototype property)는 함수 생성시에만 생성된다.   객체.proto 호출 시 프로토타입 객체 [[prototype]] 를 가리킨다   [[prototype]]은 constructor property를 갖는다.  ","categories": ["til"],
        "tags": [],
        "url": "/til/0102-TIL/",
        "teaser": null
      },{
        "title": "[React] Scrollbar 없애기",
        "excerpt":"React Scrollbar 없애기    RawBlock: { //원하는 class      \t//스크롤바 없애기     '&amp;::-webkit-scrollbar' : { \t\tdisplay : 'none'     }      }  ","categories": ["react"],
        "tags": [],
        "url": "/react/React-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EB%B0%94-%EC%97%86%EC%95%A0%EA%B8%B0/",
        "teaser": null
      },{
        "title": "0103 TIL",
        "excerpt":"0103 TIL   Created By: 성희 배 Last Edited: Jan 04, 2020 2:30 AM Tags: til   Express.js      node.js 상에서 동작하는 웹 프레임 워크   가볍고 유연하게 웹 프레임워크를 구성할 수 있음 → Middleware 구조 때문임   body-parser : POST 요청의 바디 데이터에 접근하기 위함   Socket 통신      TCP/IP를 이용하는 창구 역할   응용 프로그램과 소켓 사이의 interface 역할         socket() 호출으로 소켓 번호와 소켓 주소를 받아온다.   받아온 소켓 번호와 소켓 주소를 bind()한다.            소켓 번호 : 포트       소켓 주소 : 네트워크가 알고있는 주소           listen()으로 대기   클라이언트에서 connect()를 요청 하면, accept()로 연결   send(), recv()로 데이터 송수신     미들웨어      third-party middleware : 다른 사람이 만든 소프트웨어   next()로 middleware 순서 제어  ","categories": ["til"],
        "tags": [],
        "url": "/til/0103-TIL/",
        "teaser": null
      },{
        "title": "[leetcode] Combination Sum",
        "excerpt":"Combination Sum   Algorithm: 재귀 Created: Jan 04, 2020 10:25 AM DoubleChk: No Type: LeetCode level: 2 link: https://leetcode.com/problems/combination-sum/   Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.   The same repeated number may be chosen from candidates unlimited number of times.   Note:      All numbers (including target) will be positive integers.   The solution set must not contain duplicate combinations.   Example 1:   Input: candidates = [2,3,6,7], target = 7, A solution set is: [   [7],   [2,2,3] ]   Example 2:   Input: candidates = [2,3,5], target = 8, A solution set is: [   [2,2,2,2],   [2,3,3],   [3,5] ]        class Solution {     public:                  void recursion(vector &lt;vector&lt;int&gt;&gt; &amp;ans, vector &lt;int&gt; &amp;chosen, vector &lt;int&gt;&amp; candidates, int target, int index){             if(target &lt; 0){                 return;             }                          if(target == 0){                 ans.push_back(chosen);                 return;             }                          for(int i=index; i&lt;candidates.size(); i++){                 chosen.push_back(candidates[i]);                 recursion(ans, chosen, candidates, target - candidates[i], i);                 chosen.pop_back();             }                      }                  vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt;&amp; candidates, int target) {             vector &lt;vector&lt;int&gt;&gt; ans;             vector &lt;int&gt; chosen;                          recursion(ans, chosen, candidates, target, 0);                          return ans;         }     };          문제 풀이       target에서 candidates를 재귀로 계속 빼가면서 0이 되면 ans 벡터에 push를 해준다.       만약 candidates를 뺐는데 음수가 나오면 return 한다. (너무 많이 뺐으므로)       재귀함수를 호출 하면서 index를 부여 해주는데, 중복이 허용 가능 하기 때문에       인자로 i를 보내주어 다시 한 번 자기 자신을 chosen에 넣을 수 있도록 해주었다.            후기       :D      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Combination-Sum/",
        "teaser": null
      },{
        "title": "0104 TIL",
        "excerpt":"0104 TIL   Created By: 성희 배 Last Edited: Jan 04, 2020 2:52 PM   Routing      애플리케이션 엔드 포인트 (URI) 의 정의   URI가 클라이언트 요청에 응답하는 방식의 정의   라우터      HTTP 메소드 중 하나로부터 파생 → get, post, head, delete…   app.route()            라우트 경로에 대하여 체인 가능한 라우트 핸들러 작성 가능           GET vs POST      GET            서버로부터 정보를 조회하기 위해 설계된 메소드       데이터를 Body에 담지 않고 쿼리 스트링을 통해 전송           POST            리소스를 생성/변경하기 위해 설계       Body에 담아서 전송 → 대용량 데이터 전송 가능           GET vs POST?            GET : Idempotent (멱등)       POST : Non-dempotent       GET은 언제나 똑같은 결과를 return (멱등)       POST는 달라질 수 있음          ","categories": ["til"],
        "tags": [],
        "url": "/til/0104-TIL/",
        "teaser": null
      },{
        "title": "0109 TIL",
        "excerpt":"Created By: 성희 배 Last Edited: Jan 09, 2020 4:31 PM Tags: design, til   CTA (CALL TO ACTION)      사용자의 반응을 유도하는 반응 및 행위   Trigger word(수단) → CTA(목적)            액션(Action)=모션(Motion)                 Label이 방향성을 가져야 함       동사 사용                    다음 단계 설명                       버튼의 라벨을 정할 때 다음 화면의 타이틀과 일치                    미스터리를 만들지 말라                       버튼의 라벨을 명확하게                    수월하게 만들어라                       Let’s go!                    짧고 톡톡 튀게 만들어라                       Re-enter your password → Try Again                    이중 부정을 피해라           만약 끝났다면 축하해줘라!                           [누구든지 하는 리액트]   Created By: 성희 배 Last Edited: Jan 09, 2020 4:30 PM Tags: study   리액트      프론트엔드 라이브러리   Web Application   DOM 관리 최소화   Component에 집중   Mutation을 하지 않고 View를 새로 만든다   Virtual DOM      기존 저장된 DOM과 새로운 DOM을 비교해서 달라진 부분만 바꾼다   WebPack      코드들을 의존하는 순서대로 파일을 변환   Babel      자바스크립트 변환 도구   Props      부모 → 자식 값을 전달할 때 사용   함수형 component - 객체형 component보다 미세하게 빠르고, 군더더기 없는 기능만 있기 때문에 단순한 기능일 때에 사용   State      자신이 가지고 있는 정보   setState() : state 값 변경   LifeCycle API   https://react-anyone.vlpt.us/05.html      componentDidMount            이벤트 등록       외부 라이브러리 등록           shouldComponentUpdate   getSnapshotBeforeUpdate            component가 업데이트 되기 직전에 DOM 가져옴           componentWillUnmount            컴포넌트가 지워질 때 호출          ","categories": ["til"],
        "tags": [],
        "url": "/til/0109-TIL/",
        "teaser": null
      },{
        "title": "[leetcode] Populating Next Right Pointers in Each Node II",
        "excerpt":"Populating Next Right Pointers in Each Node II   Algorithm: 트리 level: 2 link: https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/   Given a binary tree   struct Node {   int val;   Node *left;   Node *right;   Node *next; }   Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.   Initially, all next pointers are set to NULL.   Follow up:      You may only use constant extra space.   Recursive approach is fine, you may assume implicit stack space does not count as extra space for this problem.   Example 1:      Input: root = [1,2,3,4,5,null,7] Output: [1,#,2,3,#,4,5,7,#] Explanation: Given the above binary tree (Figure A),  your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with '#' signifying the end of each level.   Constraints:      The number of nodes in the given tree is less than 6000.   -100 &lt;= node.val &lt;= 100   ---      /*     // Definition for a Node.     class Node {     public:         int val;         Node* left;         Node* right;         Node* next;              Node() : val(0), left(NULL), right(NULL), next(NULL) {}              Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}              Node(int _val, Node* _left, Node* _right, Node* _next)             : val(_val), left(_left), right(_right), next(_next) {}     };     */     class Solution {     public:         Node* connect(Node* root) {             Node * prev = NULL;                  if(root == NULL) return root;             queue &lt;Node *&gt; q;             q.push(root);                                              while(!q.empty()){                                  int n = q.size();                 Node * top;                 //자식의 갯수 만큼                 for(int i=0; i&lt;n; i++){                     top = q.front();                     q.pop();                                          if(prev != NULL){                         prev-&gt;next = top;                     }                     prev = top;                                          if(top-&gt;left) q.push(top-&gt;left);                     if(top-&gt;right) q.push(top-&gt;right);                                      }                                  top-&gt;next = NULL;                 prev = NULL;                                                         }                          return root;                      }     };          문제 풀이       BFS로 접근했다       레벨마다 NULL값을 넣어줘야 하기 때문에 자식 PUSH를 모두 한 후에 자식의 갯수만큼 연산을 진행 해 주었다.            후기       오늘 일찍 일어난거 칭찬해 :good:      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Populating-Next-Right-Pointers-in-Each-Node-II/",
        "teaser": null
      },{
        "title": "[os] ch.1",
        "excerpt":"Chapter 1. Introduction   Created By: 성희 배 Last Edited: Jan 26, 2020 12:12 AM Tags: OS   OS      Manages the computer hardware   Provides a basis for application programs   Intermediary between the computer and hardware   What OS do?      hardware, os, application programs, users   Hardware : cpu, memory, i/o device   Application Programs : word processor, spreadsheet, compiler   OS : 컴퓨터 시스템에서 사용 되는 자원들을 효율적으로 사용하기 위한 방법 제공   Definition of OS      운영체제 : 컴퓨터에서 항상 수행되는 프로그램, 커널 이라 불림   Computer-System Organization   Computer System Operation      Bootstrap : 컴퓨터가 시작 할 때 초기화에 필요한 프로그램            Simple 해야 함       EEPROM, ROM(펌웨어) 에 저장 됨       어떻게 os를 로드하고 시작 하는 지를 알아야 함       운영체제의 커널을 찾아 메모리에 적재해야 함           사건이 발생 하면 Interrupt에 의해 신호가 보내짐            하드웨어는 CPU에 system bus를 통해 신호를 보냄       소프트웨어는 system call을 통해 신호를 보냄           Storage Structure      컴퓨터는 대부분의 프로그램을 RAM에서 가져옴   ROM : 변하지 않는 읽기 전용 메모리 (게임 카트리지)   EEPROM : 자주 변할 수 없음, 대부분의 정적 프로그램 저장 (스마트폰)   load, store를 사용 해 메모리 명령 실행   폰 노이만 구조에서 실행되는 전형적인 명령-실행 사이클            메모리로부터 명령어 해독       명령 레지스터에 저장       명령 해독       명령 실행       결과 메모리에 저장           저장 장치 계층            자기테이프 → 광 디스크 → 자기 디스크 → 반도체 디스크 → 주 메모리 → 캐시 → 레지스터           I/O Structure      DMA(직접 메모리 접근)            CPU의 개입 없이 데이터 블록 전체를 전송           Computer System Architecture   Single-Processor System      하나의 주 CPU를 가짐   Multiprocessor System      증가된 처리량 (Increased Throughput)            여러개의 프로세서를 씀으로서 속도가 증가함       하지만 N개의 프로세스를 쓴다고 해서 속도가 N배 증가하지는 않는다. → 오버헤드 때문에           규모의 경제성 (Economy Of Scale)            주변 장치, 저장장치, 전원 공급 장치를 공유하고 있기 때문에 비용을 절약 할 수 있다.           증가된 신뢰성 (Increased Reliability)            한 처리기가 고장나더라도 속도만 느려지지 정지가 되지 않는다.              비대칭적 다중 처리            하나의 주 처리기가 시스템을 제어       처리기끼리 종속 관계           대칭적 다중 처리            각 처리기가 운영체제 내의 모든 작업을 수행       레지스터와 캐시는 로컬, 메모리는 공유           멀티 코어 시스템   Clustered System      높은 가용성을 제공하기 위해 사용   클러스터 내의 컴퓨터가 고장나도 서비스 계속 제공   병렬화 사용   운영체제의 구조      다중 프로그래밍 → CPU 이용률 증가            여러 작업을 메모리에 적재       작업 pool 내에 유지 (메모리 할당 대기)       pool 내의 작업 중 하나를 선택해 실행           시분할 시스템 (멀티태스킹)            대화식 컴퓨터 시스템을 필요로 함       입출력 장치를 사용해 출력장치의 즉각적인 응답을 대기           운영체제 연산   이중 연산 모드      사용자 모드, 커널 모드   모드 비트 사용   모드를 나눔으로서 운영체제 코드와 사용자 코드를 구별   트랩, 인터럽트 발생 → 커널 모드 (모드 비트 0)   사용자 프로그램으로 제어를 넘김 → 사용자 모드 (모드 비트 1)   특권 명령으로 민감한 명령어들을 보호   타이머      무한루프를 방지하기 위해 타이머 사용  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch.1/",
        "teaser": null
      },{
        "title": "[React] React 특정 Table Row highlighting",
        "excerpt":"React 특정 Table Row highlighting   Created By: 성희 배 Last Edited: Jan 27, 2020 6:30 PM Tags: dev   전체 뷰         Youtube 동영상 밑에 있는 Table의 Row를 클릭 시에 Highlighting 하는 기능을 설명한다.   다른 Row 클릭 시 클릭된 Row만 highlighting 된다.     Table 선언   Translate.js      import RawItem from '../components/RawItem'     &lt;Table&gt;     \t&lt;TableBody&gt;     \t\t&lt;TableRow&gt;     \t\t\t&lt;RawItem/&gt;     \t\t&lt;/TableRow&gt;     \t&lt;/TableBody&gt;     &lt;/Table&gt;  TableCell Component 선언   RawItem.js      &lt;TableCell&gt;     \t&lt;div&gt;     \t\t&lt;Typography variant='caption'&gt;&lt;/Typography&gt;     \t\t&lt;Typography variant='h6'&gt;&lt;/Typography&gt;     \t&lt;/div&gt;     &lt;/TableCell&gt;     Row와 Row 안에 들어갈 Cell의 컴포넌트들을 만들어준다.   테이블 데이터 선언   Translate.js      const tableData = [1, 2, 3]     return tableData.map((elem, index) =&gt; {     &lt;Table&gt;     \t&lt;TableBody&gt;     \t\t&lt;TableRow&gt;     \t\t\t&lt;RawItem/&gt;     \t\t&lt;/TableRow&gt;     \t&lt;/TableBody&gt;     &lt;/Table&gt;     )     })     테이블 데이터를 대충 설정 해 주고, .map 반복문으로 Row를 생성해준다.   프로젝트를 실행 해 보면 3개의 cell들이 보일 것이다.   Translate.js      const tableData = [1, 2, 3]     return tableData.map((elem, index) =&gt; {     &lt;Table&gt;     \t&lt;TableBody&gt;     \t\t&lt;TableRow&gt;     \t\t\t&lt;RawItem row={index}/&gt;     \t\t&lt;/TableRow&gt;     \t&lt;/TableBody&gt;     &lt;/Table&gt;     )     })     그리고 map을 돌면서, row = {index}로 각각의 cell들의 index를 자식에게 보내준다.   부모에게 클릭된 cell의 index 보내기   RawItem.js      &lt;TableCell&gt;     \t&lt;div&gt;     \t\t&lt;p&gt;{this.props.row}&lt;/p&gt;     \t\t&lt;Typography variant='caption'&gt;&lt;/Typography&gt;     \t\t&lt;Typography variant='h6'&gt;&lt;/Typography&gt;     \t&lt;/div&gt;     &lt;/TableCell&gt;     이제 부모에게서 받은 값을 props로 접근할 수 있다.        태그로 한 번 찍어보겠다!              인덱스를 잘 받아온 것을 알 수 있다.        이제 이 cell들을 클릭 시, 부모에게 클릭 한 cell의 인덱스를 보내 줄 것이다.       sendSelectedRow = () =&gt; {   \tthis.props.parentCallback(this.props.row)   }       callback 형식으로 부모에게 클릭 한 값을 보내주는 메소드다.   RawItem.js      &lt;TableCell onClick={this.sendSelectedRow}&gt;     \t&lt;div&gt;     \t\t&lt;p&gt;{this.props.row}&lt;/p&gt;     \t\t&lt;Typography variant='caption'&gt;&lt;/Typography&gt;     \t\t&lt;Typography variant='h6'&gt;&lt;/Typography&gt;     \t&lt;/div&gt;     &lt;/TableCell&gt;     TableCell의 onClick에 붙여준다.   Parent에서 값을 받고 변경시키기   Translate.js      state = {     \tselected: null     }     Parent에서 state를 선언해준다   선택된 cell의 인덱스를 저장해주는 state이다       callbackFunc = (childData) =&gt; {   \tthis.setState({    \t\tselected: childData,   \t})           }           callback 함수를 선언 해 준다.   setState로 RawItem.js에서 클릭 시 전달해준 index를 저장한다.       const tableData = [1, 2, 3]   return tableData.map((elem, index) =&gt; {   &lt;Table&gt;   \t&lt;TableBody&gt;   \t\t&lt;TableRow&gt;   \t\t\t&lt;RawItem row={index} parentCallback={this.callbackFunc}/&gt;   \t\t&lt;/TableRow&gt;   \t&lt;/TableBody&gt;   &lt;/Table&gt;   )   })                RawItem에 callback 함수를 붙여준다.       이제 Raw Item을 클릭 → RawItem에서 클릭된 인덱스를 보낸다   클릭된 Cell을 색칠하기   Translate.js      const tableData = [1, 2, 3]     return tableData.map((elem, index) =&gt; {     &lt;Table&gt;     \t&lt;TableBody&gt;     \t\t&lt;TableRow bgcolor={this.state.selected == index ? {color : `rgb(0, 40, 180)`} : null}&gt;     \t\t\t&lt;RawItem row={index} parentCallback={this.callbackFunc}/&gt;     \t\t&lt;/TableRow&gt;     \t&lt;/TableBody&gt;     &lt;/Table&gt;     )     })     이제 클릭 할 때마다, state에 저장된(자식이 준 index)와 cell의 index가 같을 때만 칠해준다.   즉, 클릭 한 cell만 색이 칠해지는 것이다!     전체 소스코드   Translate.js      import React, { Component } from 'react'     import { Paper, Table, TableRow, TableBody, withStyles } from '@material-ui/core'     import RawItem from '../components/RawItem'          class Translate extends Component {             state = {             selected: null         }                  callbackFunc = (childData) =&gt; {             this.setState({                  selected: childData,             })         }              render() {             const {classes} = this.props             const tableData = [1, 2, 3]             return tableData.map((elem, index) =&gt; {                 return (                     &lt;div&gt;                         &lt;Paper&gt;                             &lt;Table&gt;                                 &lt;TableBody&gt;                                     &lt;TableRow bgcolor={this.state.selected == index ? {color : `rgb(0, 40, 180)`} : null}&gt;                                     &lt;RawItem parentCallback={this.callbackFunc} row={index}/&gt;                                     &lt;/TableRow&gt;                                      &lt;/TableBody&gt;                             &lt;/Table&gt;                         &lt;/Paper&gt;                     &lt;/div&gt;                 )             })         }          }          export default withStyles(styles)(RawBlock)  RawItem.js      import React, { Component } from 'react'     import { Typography, TableCell } from '@material-ui/core'     import { withStyles } from '@material-ui/core/styles'          class RawItem extends Component {              sendSelectedRow = () =&gt; {             this.props.parentCallback(this.props.row)         }              render() {             const { classes } = this.props             const sub = this.props.data             return (                 &lt;div&gt;                     &lt;TableCell onClick={this.sendSelectedRow}&gt;                         &lt;div&gt;                             &lt;p&gt;{this.props.row}&lt;/p&gt;                             &lt;Typography variant='caption'&gt;&lt;/Typography&gt;                             &lt;Typography variant='h6'&gt;&lt;/Typography&gt;                         &lt;/div&gt;                     &lt;/TableCell&gt;                      &lt;/div&gt;             )                   }               }          export default withStyles(styles)(RawItem)     리액트 재밌다   더 좋은 방법 있으면 알려주세요 :)  ","categories": ["react"],
        "tags": [],
        "url": "/react/React-React-%ED%8A%B9%EC%A0%95-Table-Row-highlighting/",
        "teaser": null
      },{
        "title": "[백준][1759] 암호 만들기",
        "excerpt":"[1759] 암호 만들기   Algorithm: 문자열, 백트래킹 Created: Jan 28, 2020 5:29 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/1759   문제   바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은, 702호에 새로운 보안 시스템을 설치하기로 하였다. 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다.   암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다. 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다.   새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다. 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오.   입력   첫째 줄에 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15) 다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다. 주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다.   출력   각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력한다.   예제 입력 1   4 6 a t c i s w   예제 출력 1   acis acit aciw acst acsw actw aist aisw aitw astw cist cisw citw istw        #include &lt;string&gt;     #include &lt;vector&gt;     #include &lt;algorithm&gt;     #include &lt;iostream&gt;     using namespace std;     int L, C;     vector &lt;char&gt; v;     vector &lt;string&gt; ans;     int check[16];     char vowel[5] = {'a', 'e', 'i', 'o', 'u'};          bool checkValid(string now){         int vowels = 0;         int constants = 0;         int hasVowel = false;              for(int i=0; i&lt;now.length(); i++){             for(int j=0; j&lt;5; j++){                 if(now[i] == vowel[j]){                     vowels++;                     hasVowel = true;                     break;                 }             }             if(!hasVowel){                 constants++;             }             hasVowel = false;         }              if(vowels &gt;= 1 &amp;&amp; constants &gt;= 2) return true;         return false;     }          //a c i s t w     void recursion(string now, int cur){              if(L == now.length()){             if(checkValid(now)){                 ans.push_back(now);             }             return;         }              for(int i=cur; i&lt;v.size(); i++){             if(!check[i]){                 check[i] = 1;                 recursion(now + v[i], i+1);                 check[i] = 0;             }         }     }          int main(){         cin &gt;&gt; L &gt;&gt; C;              for(int i=0; i&lt;C; i++){             char input;             cin &gt;&gt; input;             v.push_back(input);         }              sort(v.begin(), v.end());         recursion(\"\", 0);              for(int i=0; i&lt;ans.size(); i++){             cout &lt;&lt; ans[i] &lt;&lt; endl;         }         return 0;     }          문제 풀이       알파벳 순서대로 암호가 만들어지기 때문에 sort를 해 주고, 백트래킹 하였다.       사용했는지 안했는지 확인하는 배열이 있는데, 이거 없어도 될 것 같다! (check 배열) 어차피 순서대로 i+1만큼 도니까 중복이 안될 것이라서       그리고 길이가 충족이 되면 자음, 모음을 체크 한다.       체크 한게 충족이 되면 정답에 포함 한다!       이것도 벡터에 따로 안넣고 바로 출력 하면 메모리 아낄 수 있을듯            후기       냠      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1759-%EC%95%94%ED%98%B8-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[백준][2580] 스도쿠",
        "excerpt":"[2580] 스도쿠   Algorithm: 백트래킹 Created: Jan 28, 2020 5:42 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/2580   문제   스도쿠는 18세기 스위스 수학자가 만든 ‘라틴 사각형’이랑 퍼즐에서 유래한 것으로 현재 많은 인기를 누리고 있다. 이 게임은 아래 그림과 같이 가로, 세로 각각 9개씩 총 81개의 작은 칸으로 이루어진 정사각형 판 위에서 이뤄지는데, 게임 시작 전 몇 몇 칸에는 1부터 9까지의 숫자 중 하나가 쓰여 있다.      나머지 빈 칸을 채우는 방식은 다음과 같다.      각각의 가로줄과 세로줄에는 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.   굵은 선으로 구분되어 있는 3x3 정사각형 안에도 1부터 9까지의 숫자가 한 번씩만 나타나야 한다.   위의 예의 경우, 첫째 줄에는 1을 제외한 나머지 2부터 9까지의 숫자들이 이미 나타나 있으므로 첫째 줄 빈칸에는 1이 들어가야 한다.      또한 위쪽 가운데 위치한 3x3 정사각형의 경우에는 3을 제외한 나머지 숫자들이 이미 쓰여있으므로 가운데 빈 칸에는 3이 들어가야 한다.      이와 같이 빈 칸을 차례로 채워 가면 다음과 같은 최종 결과를 얻을 수 있다.      게임 시작 전 스도쿠 판에 쓰여 있는 숫자들의 정보가 주어질 때 모든 빈 칸이 채워진 최종 모습을 출력하는 프로그램을 작성하시오.   입력   아홉 줄에 걸쳐 한 줄에 9개씩 게임 시작 전 스도쿠판 각 줄에 쓰여 있는 숫자가 한 칸씩 띄워서 차례로 주어진다. 스도쿠 판의 빈 칸의 경우에는 0이 주어진다. 스도쿠 판을 규칙대로 채울 수 없는 경우의 입력은 주어지지 않는다.   출력   모든 빈 칸이 채워진 스도쿠 판의 최종 모습을 아홉줄에 걸쳐 한 줄에 9개씩 한 칸씩 띄워서 출력한다.   스도쿠 판을 채우는 방법이 여럿인 경우는 그 중 하나만을 출력한다.   예제 입력 1   0 3 5 4 6 9 2 7 8 7 8 2 1 0 5 6 0 9 0 6 0 2 7 8 1 3 5 3 2 1 0 4 6 8 9 7 8 0 4 9 1 3 5 0 6 5 9 6 8 2 0 4 1 3 9 1 7 6 5 2 0 8 0 6 0 3 7 0 1 9 5 2 2 5 8 3 9 4 7 6 0   예제 출력 1   1 3 5 4 6 9 2 7 8 7 8 2 1 3 5 6 4 9 4 6 9 2 7 8 1 3 5 3 2 1 5 4 6 8 9 7 8 7 4 9 1 3 5 2 6 5 9 6 8 2 7 4 1 3 9 1 7 6 5 2 3 8 4 6 4 3 7 8 1 9 5 2 2 5 8 3 9 4 7 6 1        #include &lt;iostream&gt;     #include &lt;algorithm&gt;     #include &lt;vector&gt;     #include &lt;string.h&gt;     using namespace std;     int sudoku[10][10];     int checkRow[10][10];     int checkCol[10][10];     int checkSquare[10][10];     int cnt;     void print(){              for(int i=0; i&lt;9; i++){             for(int j=0; j&lt;9; j++){                 cout &lt;&lt; sudoku[i][j] &lt;&lt; ' ';             }             cout &lt;&lt; endl;         }          }          bool valid(int row, int col, int num){         if(checkRow[row][num] ||      \t\t\t\tcheckCol[num][col] ||      \t\t\t\tcheckSquare[row/3 * 3 + col/3][num]) return false;         return true;     }     void solve(int cnt){         if(cnt &gt;= 81){             print();             exit(0);         }              for(int i=0; i&lt;9; i++){             for(int j=0; j&lt;9; j++){                 if(sudoku[i][j] == 0){                     for(int k=1; k&lt;10; k++){                         if(valid(i, j, k)){                             sudoku[i][j] = k;                             checkRow[i][k] = 1;                             checkCol[k][j] = 1;                             checkSquare[i/3*3 + j/3][k] = 1;                             solve(cnt + 1);                                  sudoku[i][j] = 0;                             checkRow[i][k] = 0;                             checkCol[k][j] = 0;                             checkSquare[i/3*3 + j/3][k] = 0;                         }                     }                     return;                 }             }         }     }     int main(){              for(int i=0; i&lt;9; i++){             for(int j=0; j&lt;9; j++){                 int num;                 cin &gt;&gt; num;                 sudoku[i][j] = num;                 checkRow[i][num] = 1;                 checkCol[num][j] = 1;                 checkSquare[i/3*3 + j/3][num] = 1;                 if(num != 0) cnt++;             }         }              solve(cnt);         return 0;     }          문제 풀이       스도쿠를 풀려면 3가지 조건이 충족되어야 한다.              가로 줄에 숫자가 중복이 안되어야 함       세로 줄에 숫자가 중복이 안되어야 함       3*3 사각형에 숫자가 중복이 안되어야 함           그래서 배열이 3개 필요하다! → 가로 체크, 세로 체크, 사각형 체크       일단 입력을 받으면서 0이 아닌 입력들을 체크 해 준다.       그리고 재귀 함수에 센 숫자를 인자로 보내준다.       스도쿠 판이 9*9이기 때문에 함수 내에서 기저 조건을 81이랑 cnt랑 같으면 끝내게 해 주었다.       이제 스도쿠 판을 돌면서 0에 1부터 10까지 하나씩 넣어보면서 재귀를 돈다.       숫자를 넣어 볼 때 이미 가로, 세로, 사각형에 들어가 있는 숫자인지 체크 해 준다 (valid 함수)       스도쿠 답은 여러개가 될 수 있지만, 1개만 출력 하라고 했기 때문에 exit(0)으로 탈출한다.             Square 체크 할 때, i/3 *3 + j/3에 대해서 설명을 하겠다. 예시를 들면 더 쉽기 때문에 예시를 보면서 설명하겠다.          i, j가 0일 때에 각각의 값들은 다음과 같다.       checkSquare[0][num] = 1 의 의미는 → 해당 square 칸(0)에 num이 있다고 표시 해 준다.       따라서 i3/3+j3은 해당 square의 가장 왼쪽 위를 가리킨다.       그 값으로 어떤 칸인지 체크 하는 것이다.       다음 예시를 보겠다.          i*3/3+j/3의 값은 3이다.       3은 2번째 칸의 시작 인덱스이다!       4, 1도 똑같이 나온다.       해당 칸 안에 있는 것들은 다 3이 나오게 될 것이다. → 이걸로 square안에 num을 체크 해주는것!            후기       스도쿠 풀어본적도 없는데 알고리즘으로 배웠다 인생 모를..       휴대폰 게임도 스도쿠는 안하고 걸렀는데       수포자 승리하자      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-2580-%EC%8A%A4%EB%8F%84%EC%BF%A0/",
        "teaser": null
      },{
        "title": "[백준][9095] 1, 2, 3 더하기",
        "excerpt":"[9095] 1, 2, 3 더하기   Algorithm: 백트래킹 Created: Jan 27, 2020 6:35 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/9095   문제   정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.      1+1+1+1   1+1+2   1+2+1   2+1+1   2+2   1+3   3+1   정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 테스트 케이스의 개수 T가 주어진다. 각 테스트 케이스는 한 줄로 이루어져 있고, 정수 n이 주어진다. n은 양수이며 11보다 작다.   출력   각 테스트 케이스마다, n을 1, 2, 3의 합으로 나타내는 방법의 수를 출력한다.   예제 입력 1   3 4 7 10   예제 출력 1   7 44 274        #include &lt;string&gt;     #include &lt;vector&gt;     #include &lt;algorithm&gt;     #include &lt;queue&gt;     #include &lt;iostream&gt;     using namespace std;     int n, T, cnt;     int num[3] = {1, 2, 3};     int check[12];     //1, 2, 3의 합으로 나타내기          void recursion(int target, int cur){         if(target &lt; 0) {             return;         }         if(target == 0){             cnt++;             return;         }              for(int i=cur; i&lt;3; i++){             recursion(target - num[i], cur);         }          }          int main(){         cin &gt;&gt; T;         for(int i=0; i&lt;T; i++){             cnt = 0;             cin &gt;&gt; n;                  recursion(n, 0);             cout &lt;&lt; cnt &lt;&lt; endl;         }                        return 0;     }          문제 풀이       재귀를 돌면서 1, 2, 3을 차례로 빼준다.       기저 조건은 현재 값이 0일때 → 답을 하나 추가 해 준다.       만약 0 이하라면, 답이 아니기 때문에 (너무 많이 뺐기 때문에) return을 해 준다.            후기       편두통이 심해졌다..      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-9095-1,2,3-%EB%8D%94%ED%95%98%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[백준][9663] N-Queen",
        "excerpt":"[9663] N-Queen   Algorithm: 백트래킹 Created: Jan 28, 2020 5:29 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/9663   문제   N-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다.   N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15)   출력   첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.   예제 입력 1   8   예제 출력 1   92        #include &lt;iostream&gt;     #include &lt;algorithm&gt;     #include &lt;vector&gt;     #include &lt;string.h&gt;     using namespace std;     int n, ans;     int chess[16][16];     bool check(int row, int col){              //세로         for(int i=0; i&lt;row; i++){             if(chess[i][col] == 1) return false;         }              //대각선              int check_right = col + 1;         int check_left = col - 1;              for (int i = row - 1; i &gt;= 0; --i)         {             //check '/' diag             if (check_right &lt; n &amp;&amp; chess[i][check_right] == 1)                 return false;             else                 check_right++;                  //check '\\' diag             if (check_left &gt; -1 &amp;&amp; chess[i][check_left] == 1)                 return false;             else                 check_left--;         }              return true;     }     void solve(int num){         if(num == n){             ans++;             return;         }              for(int i=0; i&lt;n; i++){             if(check(num, i)){                 chess[num][i] = 1;                 solve(num+1);                 chess[num][i] = 0;             }         }          }     int main(){              cin &gt;&gt; n;         solve(0);         cout &lt;&lt; ans &lt;&lt; endl;     }          문제 풀이       퀸은 가로, 세로, 대각선을 모두 공격할 수 있다.       따라서 한 줄에 퀸을 하나 씩 놓을 때 마다, 그 줄에 놓을 수 있는 퀸을 다 놓은 것이다.       그래서 반복문을 돌면서, 한 줄에 하나씩 퀸을 놓아 본다.       퀸을 놓을 때 마다, 가로, 세로, 대각선에 다른 퀸이 있는지 체크 한다!       이것을 반복하다가 퀸을 다 놓으면 답을 더한다.            후기       처음 이문제 접했을때는 진짜 암것도 모르겠었는데 이제는 아는거 보니 성장했다 눈물난다      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-9663-N-Queen/",
        "teaser": null
      },{
        "title": "[leetcode] Valid Parentheses",
        "excerpt":"Valid Parentheses   문제링크   First Solution      class Solution {     public:         stack &lt;char&gt; st;         bool isValid(string s) {                          for(int i=0; i&lt;s.length(); i++){                 char c = s[i];                                  if(c == ')'){                     if(!st.empty() &amp;&amp;st.top() == '(') {                         st.pop();                         continue;                     }else return false;                 }else if(c == '}'){                     if(!st.empty() &amp;&amp;st.top() == '{'){                         st.pop();                         continue;                     }else return false;                                      }else if(c == ']'){                     if(!st.empty() &amp;&amp; st.top() == '['){                         st.pop();                         continue;                     }else return false;                 }else{                     st.push(c);                 }             }                          if(!st.empty()) return false;             else return true;         }     };  Second Solution   좀더 가시적인 코드      class Solution {     public:         stack &lt;char&gt; st;         bool isValid(string s) {                          for(int i=0; i&lt;s.length(); i++){                 char c = s[i];                 if(c == '(' || c == '[' || c == '{'){                     st.push(c);                 }else{                     if(st.empty()) return false;                     if(c == ']' &amp;&amp; st.top()!= '[') return false;                     if(c == '}' &amp;&amp; st.top()!= '{') return false;                     if(c == ')' &amp;&amp; st.top()!= '(') return false;                     st.pop();                 }                              }                          return st.empty();         }     };   Javascript  var isValid = function(s) {     const stack = [];     const map = {         '(' : ')',         '[' : ']',         '{' : '}'     };          for(let i = 0; i &lt; s.length; i++) {         let c = s[i];                  if(map[c]) stack.push(map[c]); // open bracket         else if (c !== stack.pop()) return false;     }          return !stack.length; };          문제풀이       스택에 하나씩 넣으면서 닫는 괄호 라면 앞에 여는 괄호가 있는지 st.top()으로 확인한다.       여는 괄호가 없거나 스택이 비었다면 return false       여는 괄호가 있으면 pop을 해준다.       다 돈 다음에 스택에 남아있는게 있으면 짝이 없다는 뜻이므로 return false       스택이 비었다면 다 짝을 찾았으므로 return true를 해준다!            후기       비슷한 문제를 자료구조 시간에 풀어서 잘 .. 풀었다 ㅎ 아래 코드가 더 깔끔한데 시간이 더 걸린다 왤까~~      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Valid-Parentheses/",
        "teaser": null
      },{
        "title": "몰입캠프 후기",
        "excerpt":"몰입캠프 회고록   Created By: 성희 배 Last Edited: Jan 30, 2020 3:13 AM   한 달간의 몰입 캠프가 끝났다.   비트 고급반을 할 때는 거의 매일 밤을 샜다. 이른 새벽 4시까지 코딩을 하고, 컴퓨터를 끈 후 강의실에 둔 침낭에 누워 팀원들과 도란도란 얘기를 나누며 잠에 들었다. 아침에 일어나 기숙사에서 씻고만 나와 다시 코딩을 하고, 나가는 시간도 아까워 배달 음식만 시켜먹었다. 그런 나날들이 세 달간 이어 졌는데도 행복했다.   이 때부터 개발자의 꿈을 꾸기 시작했다. 친밀한 팀원들, 프로젝트에 대한 애정, 코딩만을 할 수 있는 환경, 발전 해 나가고 있다는 확신이 그 꿈을 뒷받침 해주었다. 욕심이 생겼다. 비 전공자 수준에 머물러 있고 싶지 않았고 좀 더 깊고 전문적인 기술을 배우고 싶었다.   그토록 원하던 대학교에 들어온 이후 가장 자주 말하던 것은 “대학교 다 똑같아,” 였다. 편입을 하게 되면 모든게 바뀔 줄 알았다. 개발과 연구를 추구하는 학생들, 전공 과목 뿐이 아니라 신 기술까지 섭렵하여 학생들에게 전파하는 교수님, 어디서나 코딩을 할 수 있도록 시설을 제공하는 학교를 기대했다.   지금 생각해보니 오만한 생각이다. 스스로 하기보다는 누군가가 떠 먹여 주길 바랐던 것이다. 익숙하지 않은 것 뿐인데 회피하고 미루고, 변명만 늘어놓았다. 과거에 기준점을 맞춰 비관하고, 이상적인 미래를 생각하며 또 비판했다. 스스로가 선택자가 된 것 마냥 시혜 적인 태도로 현재에 만족하지 못했다. 몰입 캠프에 지원 한 것도 온전히 개발에만 신경쓰는 환경에서 개발만 하고 싶어, 라는 과거의 연장선에서 시작되었다.   비트와 굉장히 비슷한 상황에서 개발을 시작하였지만, 그 때의 느낌과는 전혀 달랐다. 당연한 것이다. 그 때와 지금의 나는 다르다. 환경이 문제가 아니라 내가 문제였던 것이다. 이 사실을 알아챘을 때에는 머리가 띵 했다. 지금까지 불평 불만만 늘어 놓았던 스스로가 부끄러웠다.   4주 동안 전국 내로라 하는 대학생들과 함께 프로젝트를 일주일 단위로 진행 하였다. ‘지능’(Intelligence), ‘창의성’(Creativity), ‘과제집착력’(Task-commitment) 영재성의 3요소이다. 다 똑같은 사람이겠지, 했는데 사고 방식 부터 달랐다. 쉽게 포기하지 않았고, 빠르게 습득하며, 효율적으로 응용한다. 횡설수설한 설명도 요점을 정확히 파악하여 문제를 해결했다.   여러 스타트업 CEO, CTO들을 만날 수 있었던 것도 큰 행운이었다. 본인이 무엇을 원하는 지 정확히 알고, 자신이 좋아하는 일에 열정을 가지고 추진 해 나가며, 자신의 일과 접목 시키려고 하는 점을 본받고 싶었다. 그들처럼 아낌 없이 조언 해 주고 격려 해주는 선배가 되고 싶다.   4주간의 캠프 생활 동안 제일 많이 느낀 것은 아, 난 정말 아무것도 아니구나. 난 정말 범인이구나, 였다. 나의 부족함을 통감하고, 그래서 앞으로 어떤 식으로 발전 해 나가야 하는지 알 수 있었다. 또한 좋은 사람들을 많이 알게 되었다. 명함을 주신 선배님들과, 한 달 동안 동고동락한 분반원들, 알게 된 같은 학교 사람들, 이 사람들에게 영감이 되고 영감을 받고 싶다. 그들의 태도와 삶의 방향성을 엿보게 되어 영광이었다. 조금이나마 성장할 수 있었던 나에게도 고생했다고 말해주고 싶다.   나는 아직 배울 것이 많다. 그래서 더 열심히 할 것이다.   좋은 프로그램을 기획 해 주신 의장님과, 한 달 동안 고생하신 모든 분께 감사의 말씀을 드린다.  ","categories": ["til"],
        "tags": [],
        "url": "/til/%EB%AA%B0%EC%9E%85%EC%BA%A0%ED%94%84-%ED%9B%84%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[os] ch2",
        "excerpt":"Chapter 2. System Structure   Created By: 성희 배 Last Edited: Jan 30, 2020 11:36 PM Tags: OS   운영체제 서비스      사용자 인터페이스            CLI, GUI, batch interface           프로그램 수행   입출력 연산   파일 시스템 조작   통신            프로세스 간 통신 (공유 메모리, 메시지 전달)           오류 탐지   자원 할당   회계   보호, 보안   시스템 호출 (System Calls)      System Calls            운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스 제공       시스템이 수행하는 작업 하나하나가 모두 system call       그래서 양이 방대하다. → 응용프로그래머에게 API로 제공       System call 보다 API를 응용 프로그래머가 선호하는 이유?                    프로그램의 호환성           API보다 복잡하기 때문                       운영체제에 매개 변수 전달 방법                    레지스터에 전달           메모리 내의 블록, 테이블에 저장           stack에 push, pop                   → 1, 2번을 선호한다. 개수나 길이의 제한이 없기 때문                   시스템 호출의 유형   프로세스 제어      OS는 프로세스를 end(정상), abort(비정상) 종료 할 수 있어야 한다.        한 프로그램을 실행하고 있는 Job이나 process가 다른 프로그램을 load, execute를 요청할 수 있어야 한다.       → 이후 제어권을 어떻게 할 것인가 ?       → 기존 프로그램으로 돌아간다면, 메모리 블록에 기존 프로그램을 저장       → 병행 실행이라면, 새로운 job이나 process 실행            프로그램들의 집합을 제어할 수 있어야 한다.       → 속성 결정, reset, 종료       → 종료 대기, 이벤트 대기 등등       → lock()       단일 tasking과 다중 tasking            단일 (MS-DOS)                    1번에 1개의 프로세스           메모리에 적재, 덮어씀                       다중 (Free BSD)                    프로세스 시작 fork()           실행 exec()           백그라운드에서 실행                           통신           메세지 전달 모델       → 호스트 이름, 프로세스 이름을 필수로 알아야 함            공유 메모리 모델       운영체제 구조 (OS Structure)   간단한 구조      MS-DOS            인터페이스와 기능 계층이 잘 분리되지 X → 보안상의 문제가 있음           UNIX            계층들로 이루어짐       커널에서 많은 기능 수행       모놀리식 (monolithic)                    구현, 유지보수 hard           시스템 인터페이스, 커널 내부에서의 호출은 오버헤드가 거의 X                           계층적 접근      하드웨어 지원이 있어 구현자들은 내부 동작과 모듈식 운영체제 생성에 변화를 줄 수 있게 됐다.   운영체제가 여러 층으로 나눠짐            최하위(0)는 하드웨어, 최상위(N)는 사용자 인터페이스       구현과 디버깅이 간단하다       하위 수준의 층에 제공된 연산들만 사용해 구현한다       다른 유형보다 효율성이 낮다                    연산 수행 시 층별로 호출해야 한다 → 오버헤드 우려                           마이크로 커널      보다 적은 커널   중요치 않은 프로그램들은 커널에서 제거, 그것을 시스템 및 사용자 수준 프로그램으로 구현   클라이언트 프로그램 ↔ 서비스간의 통신을 제공한다.            메시지 전달로 간접적으로 상호 작용           운영체제의 확장이 용이하다            새로운 서비스들은 사용자 공간에 추가, 커널은 변경 X       다른 하드웨어로 이식이 쉽다           높은 보안성과 신뢰성            대부분이 사용자 프로세스로 수행되기 때문           ex) 매킨토시, QNX   모듈      적재 가능 커널 모듈 (loadable kernel modules)   커널 : 핵심 서비스 제공        다른 서비스 : 커널 실행 중 동적으로 구현       → 커널에 추가하는 것 보다 바람직하다       커널의 각 부분이 정의되고 보호된 인터페이스를 가진다는 점에서 계층 구조와 비슷   하지만 모듈에서 다른 모듈을 호출 가능하다 → 계층보다 유연함   중심 모듈은 핵심 기능만을 가지고 다른 모듈의 적재 방법, 모듈간 통신은 마이크로와 비슷   하지만 메시지 전달을 호출 할 필요가 X → 마이크로보다 효율적   혼용 시스템      안드로이드, ios, 맥   운영체제 디버깅      병목 현상 제거   성능 조정   장애 분석      로그 파일 기록   코어 덤프 (프로세스가 사용하던 메모리 캡쳐) 후 파일로 저장   커널 장애 → 충돌 (crash)   충돌 덤프 (crash dump)   시스템 부트      부트스트랩 프로그램 or 부트스트랩 로더가   커널을 찾고 → 메모리에 적재 후 → 수행   ROM에 저장된다   부트 스트랩 코드가 변경 시 ROM을 교체해야 함 → EPROM으로 개선   ROM == firmware  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch2/",
        "teaser": null
      },{
        "title": "[os] ch.3 프로세스",
        "excerpt":"프로세스  프로세스     job이라고도 부른다.   실행 중인 프로그램   시분할 시스템에서의 작업의 단위   프로그램     명령어 리스트를 내용으로 가진 수동적인 (passive) 존재   cf) 프로세스는 다음에 실행할 명령어를 지정하는 Program Counter, 관련 자원의 집합을 가진 능동적인 (active) 존재이다.   프로세스는 독립적이다.     텍스트 세션은 같을지라도 data, heap, stack은 다를 수 있다.   ex) chrome 탭은 프로세스인가 스레드인가?            브라우저 프로세스는 chrome이 실행 될 때 한번만 실행이 된다.       하나의 탭이 고장난다고 해서 다른 탭이 고장나지 않으므로 프로세스이다. 각각의 탭은 서로 독립적인 존재이다. 각각의 탭마다 렌더러 프로세스가 생성이 된다.           프로세스 상태       하나의 처리기엔 하나의 프로세스만 실행중이어야 한다.   PCB (Process Control Block)        각 프로세스는 PCB에 의해 표현된다.   프로세스마다 달라지는 모든 정보를 저장한다.   Program Counter : 다음 실행 할 명령어의 주소   #   프로세스 스케쥴링     CPU 이용률을 최대화 해야하기 때문에 항상 프로세스가 실행되는 것이 좋다.   프로세스 스케쥴러는 process중 하나를 선택한다.   Scheduling Queue     새로운 프로세스 생성 시 Job큐에 넣는다.   Job 큐는 시스템의 모든 프로세스가 들어있고, 주 메모리에 존재한다.   준비 상태가 되면 Ready큐에 저장된다. 이는 연결리스트로 저장된다.   CPU에서 자원을 할당 해 주면,            입출력 요청 -&gt; 입출력 큐 -&gt; waiting -&gt; ready 큐로 이동       자식 프로세스 생성 후 대기 -&gt; waiting -&gt; ready 큐로 이동       인터럽트로 CPU에서 제거           종료되면 큐에서 삭제되고, pcb와 자원 반납   스케쥴러     장기 스케쥴러            메모리 내부의 프로세스 수 제어       new-&gt; ready, running -&gt; terminate       메모리와 디스크 사이의 스케쥴링           단기 스케쥴러            실행되는 프로세스들 제어       ready -&gt; running -&gt; waiting -&gt; ready       메모리와 cpu 사이의 스케쥴링           중기 스케쥴러            다중 프로그래밍의 정도를 완화하기 위해 프로세스를 제거(swap-out)하고 완화된 후 다시 불러옴       이를 swapping이라고 함           Context Switching     인터럽트 이후에 문맥을 복구하는 작업   이전의 프로세스 상태를 보관하고 새로운 프로세스의 보관된 상태를 복구하는 작업 필요. -&gt; 순수한 오버헤드이다.   #   프로세스에 대한 연산  프로세스 생성     부모, 자실 트리형식으로 프로세스 생성   pid로 구별   프로세스가 자식 프로세스 생성 시            부모, 자식 병행 실행하거나       부모가 자식이 끝날 때까지 대기           주소 공간 측면에서는            자식 프로세스는 부모의 복사본이거나       자식 프로세스는 새로운 프로그램을 가진다.           fork() 새로운 프로세스 생성   exec() 실행        wait() 대기       pid &lt; 0 오류   pid == 0 자식   pid &gt; 0 부모   프로세스 종료     운영체제에 exit()호출을 사용해 종료 요청   상태값, 자원을 return 한다. -&gt; 이 작업은 waiting 시에 실행 됨   부모가 자식을 삭제하는 경우            할당된 자원을 초과 사용       Task가 불필요해짐       부모 exit 후 자식 실행을 os에서 허용하지 않을 경우 -&gt; 연쇄식 종료           wait 호출이 되지 않았는데도 종료된 프로세스를 zombie 프로세스라고 한다.   모든 프로세스는 잠깐동안 zombie 프로세스가 된다. (exit-&gt;waiting 시의 갭 때문에)   그 외의 경우는 Orphan process(고아 프로세스)라고 한다.   이 경우 linux, unix에서는 Init 명령어로 프로세스들을 검사하면서 orphan 프로세스들을 제거한다.   #   프로세스간 통신 (InterProcess Communication) a.k.a. IPC     독립적 or 협력적   협력적인 경우            정보 공유가 필요한 경우       계산 가속화가 필요한 경우       모듈성이 필요한 경우       편의성이 필요한 경우 (다중 task 실행)           이런 협력적인 프로세스들은 프로세스간 통신이 필요하다.   공유 메모리 시스템     공유 메모리를 구축하여, 프로세스가 이 영역을 공유한다.   read, write를 사용하여 통신을 수행한다.   메시지 패싱 시스템과 달리 전달이 필요 없기 때문에 성능 측에서 더 낫다.   OS의 관여 없이 통신 가능하다.   구현이 어렵다는 단점이 있다.   동기화 문제를 신경 써줘야 한다!   ex) 데이터베이스   메시지 전달 시스템     공유되는 메모리 없이 커널을 경유하여 프로세스간 메시지를 전달할 수 있다.   동기화가 되어있다.   분산 네트워크 환경에서 유용하다.   send, receive를 사용하여 통신을 수행한다.   구현하기 간단하다.        커널을 거치므로, 속도가 느리다는 단점이 있다.       통신 연결과 통신 구현 종류는 다음과 같다. #     명명 (Naming)       간접통신과 직접 통신으로 나뉜다.   간접 통신     Mailbox, Port   1:N으로 연결 될 수 있다.               프로세스가 mailbox를 가지는 경우                    어떤 프로세스가 메시지를 받는지 신경 써야 한다.           메일박스를 가지는 프로세스가 종료 될 경우 다른 프로세스가 삭제되었음을 알아야 한다.                                       운영체제가 mailbox를 가지는 경우                    독립적으로 운영된다.                           직접 통신     수신, 송신자 이름을 명시하여 연결한다.   1:1로 연결된다.   동기화     blocking : 수신, 혹은 송신 완료 때까지 봉쇄   non-blocking : 수신, 혹은 송신 완료 시 다른 작업 실행   버퍼링     메시지 큐 구현 방식               무용량                    용량이 0이므로 봉쇄형이다.           메시지가 들어오면 그 메시지를 pop 할 때까지 다른 메시지가 들어올 수 없음                                       유한 용랑                    용량이 n이다.           용량이 꽉 차기 전까지는 비봉쇄, 꽉 차면 봉쇄                                       무한 용량                    비봉쇄                           #  클라이언트 서버 시스템에서의 통신  소켓     응용 프로그램 2개가 통신 시, 2개의 소켓이 만들어지고 통신 채널 양단에 하나씩 배정 됨   원격 프로시저 호출     한 프로세스가 원격지의 프로시저를 호출할 때 사용   파이프  일반 파이프     생산자 - 소비자 형태   단방향 통신만 지원   관련된 프로세스만 공유 가능   지명 파이프     좀 더 강력한 통신   부모 - 자식X   양방향   반이중   모든 프로세스 공유 가능  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch.3-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[leetcode] 3 Sum",
        "excerpt":"3Sum   Algorithm: 투포인터 Created: Nov 24, 2019 7:53 PM DoubleChk: Yes Type: LeetCode level: 2 link: https://leetcode.com/problems/3sum/   Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.   Note:   The solution set must not contain duplicate triplets.   Example:   Given array nums = [-1, 0, 1, 2, -1, -4],  A solution set is: [   [-1, 0, 1],   [-1, -1, 2] ]        class Solution {     public:        vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) {             vector &lt;vector&lt;int&gt;&gt; ans;             sort(nums.begin(), nums.end());             int numsLen = nums.size() -1;                  for(int i=0; i&lt;numsLen; i++){                 int x = nums[i];                 if(x &gt; 0 || nums[numsLen] &lt; 0) break;                 if(i != 0 &amp;&amp; nums[i] == nums[i-1]) continue;                      int s = i+1;                 int e = numsLen;                 int target = abs(x);                      while(s &lt; e){                                          if(nums[s] + nums[e] &lt; target){                         s++;                     }else if(nums[s] + nums[e] &gt; target){                             e--;                     }else{                         while(s &lt; e &amp;&amp; nums[s] == nums[s+1]) s++;                         while(s &lt; e &amp;&amp; nums[e] == nums[e-1]) e--;                         ans.push_back({x, nums[s], nums[e]});                         s++;                         e--;                     }                      }             }                  return ans;             }     };          문제 풀이       한 개를 x로 잡고, 나머지 두 숫자를 two pointer로 풀었다.       투포인터는 정렬이 되어야 하므로 정렬을 한다.       x가 0이상이라면 아무리 더해도 양수이기 때문에 break를 해준다.       또 배열의 마지막 (제일 큰 값)이 음수여도 아무리 더해도 음수이기 때문에 break를 해준다.       만약 똑같은 숫자가 연속으로 있다면 중복이기 때문에 continue를 해준다.       그리고 투 포인터로 target 숫자를 찾아간다.       하나의 조합을 찾았을 때, 같은 숫자가 연속으로 있는 경우라면 중복이기 때문에 똑같은 숫자가 아닐 때까지 index를 update 시켜준다.            후기       세상엔 참 천재들이 많다 ! 😲      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-3-Sum/",
        "teaser": null
      },{
        "title": "[leetcode] Remove Nth Node From End of List",
        "excerpt":"Remove Nth Node From End of List   Algorithm: 리스트 Created: Nov 25, 2019 3:23 PM DoubleChk: No Type: LeetCode level: 2 link: https://leetcode.com/problems/remove-nth-node-from-end-of-list/   Given a linked list, remove the n-th node from the end of list and return its head.   Example:   Given linked list: 1-&gt;2-&gt;3-&gt;4-&gt;5, and n = 2.  After removing the second node from the end, the linked list becomes 1-&gt;2-&gt;3-&gt;5.   Note:   Given n will always be valid.   Follow up:   Could you do this in one pass?        /**      * Definition for singly-linked list.      * struct ListNode {      *     int val;      *     ListNode *next;      *     ListNode(int x) : val(x), next(NULL) {}      * };      */     class Solution {     public:         ListNode* removeNthFromEnd(ListNode* head, int n) {             ListNode *tail = head;             ListNode *cur = head;             ListNode *del = head;                          int cnt = 0;             while(tail != NULL){                 tail = tail-&gt;next;                 cnt++;             }                          if(cnt &lt;= n){                 head = head-&gt;next;                 return head;             }                          for(int i=1; i&lt; (cnt - n); i++){                 cur = cur-&gt;next;             }             del = cur-&gt;next;             cur-&gt;next = del-&gt;next;             del-&gt;next = NULL;                                       return head;         }     };      /**      * Definition for singly-linked list.      * struct ListNode {      *     int val;      *     ListNode *next;      *     ListNode(int x) : val(x), next(NULL) {}      * };      */     class Solution {     public:         ListNode* removeNthFromEnd(ListNode* head, int n) {             ListNode *dummyHead = new ListNode(0);             dummyHead -&gt; next = head;             ListNode *first = dummyHead;             ListNode *second = dummyHead;                                  for(int i=1; i&lt;=n+1; i++){                 first = first-&gt;next;             }                          while(first!= NULL){                 first = first-&gt;next;                 second = second-&gt;next;             }                          second-&gt;next = second-&gt;next-&gt;next;                          return dummyHead-&gt;next;                      }     };     문제풀이            맨 끝으로 보내면서 갯수를 센다       (갯수 - target)만큼 새로운 커서를 보낸다 → 지우려는 노드 바로 뒤       새로운 커서의 다음에 커서를 보낸다       삭제 연산           head가 삭제 될때도 예외처리 해 주었다.       아래는 one-pass algorithm, 근데 two-pass랑 별로 차이 없네?              first, second를 head에 위치한다.       first를 n+1만큼 이동시킨다. (dummy때문에)       second와 first의 gap을 유지시키면서 first가 NULL이 될때까지 이동시킨다.       second→next를 second→next→next 한다.                후기       two-pass algorithm이랑 비슷하게 풀었다. one-path알고리즘도 한 번 봐야겠당       one-path 알고리즘 구현한 사람 나와.. 천재 아냐?      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Remove-Nth-Node-From-End-of-List/",
        "teaser": null
      },{
        "title": "[1697] 숨바꼭질",
        "excerpt":"[1697] 숨바꼭질   Algorithm: bfs Created: Feb 02, 2020 11:04 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/1697   문제   수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.   수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.   입력   첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.   출력   수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.   예제 입력 1   5 17   예제 출력 1   4   힌트   수빈이가 5-10-9-18-17 순으로 가면 4초만에 동생을 찾을 수 있다.        #include &lt;iostream&gt;     #include &lt;algorithm&gt;     #include &lt;queue&gt;     #define MAX 100001     using namespace std;     int n, k;     int visit[MAX];     queue &lt;int&gt; q;     void solve(){              while(!q.empty()){             int top = q.front();             if(top == k) break;             q.pop();                  int next_x = top - 1;             if(next_x &gt;= 0 &amp;&amp; !visit[next_x])      \t{q.push(next_x); visit[next_x] = visit[top] + 1;}                  next_x = top + 1;             if(next_x &lt; MAX &amp;&amp; !visit[next_x])     \t{q.push(next_x); visit[next_x] = visit[top] + 1;}                  next_x = top * 2;             if(next_x &lt; MAX &amp;&amp; !visit[next_x])     \t{q.push(next_x); visit[next_x] = visit[top] + 1;}              }     }     int main() {              cin &gt;&gt; n &gt;&gt; k;         q.push(n);         visit[n] = 1;              solve();              cout &lt;&lt; visit[k]-1 &lt;&lt; endl;              return 0;     }          문제 풀이       queue에 방문할 인덱스를 넣고, +1, -1, *2를 해준다.       이미 방문 했거나, 범위를 넘었을 때를 제외 하고       queue에 push를 한 뒤, 방문 처리를 해준다.       queue가 빌 때 까지 반복한다            후기       -      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1697-%EC%88%A8%EB%B0%94%EA%BC%AD%EC%A7%88/",
        "teaser": null
      },{
        "title": "[2178] 미로 탐색",
        "excerpt":"[2178] 미로 탐색   Algorithm: bfs Created: Feb 02, 2020 11:08 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/submit/2178/17257041   문제   N×M크기의 배열로 표현되는 미로가 있다.   Untitled   미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.   위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.   입력   첫째 줄에 두 정수 N, M(2 ≤ N, M ≤ 100)이 주어진다. 다음 N개의 줄에는 M개의 정수로 미로가 주어진다. 각각의 수들은 붙어서 입력으로 주어진다.   출력   첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.   예제 입력 1   4 6 101111 101010 101011 111011   예제 출력 1   15   예제 입력 2   4 6 110110 110110 111111 111101   예제 출력 2   9   예제 입력 3   2 25 1011101110111011101110111 1110111011101110111011101   예제 출력 3   38   예제 입력 4   7 7 1011111 1110001 1000001 1000001 1000001 1000001 1111111   예제 출력 4   13        #include &lt;iostream&gt;     #include &lt;algorithm&gt;     #include &lt;vector&gt;     #include &lt;queue&gt;     using namespace std;     int n, m, ans;     int map_[101][101];     queue &lt;pair&lt;int, int&gt;&gt; q;     int dx[4] = {0, 0, -1, 1};     int dy[4] = {-1, 1, 0, 0};     int check[101][101];     void bfs(){              while(!q.empty()){                  int top_x = q.front().first;             int top_y = q.front().second;             check[top_x][top_y] = 1;             q.pop();                          for(int i=0; i&lt;4; i++){                      int next_x = dx[i] + top_x;                 int next_y = dy[i] + top_y;                      if(next_x &lt; 0 || next_y &lt; 0 || next_x &gt;= n || next_y &gt;= m                     || map_[next_x][next_y] == 0 || check[next_x][next_y] == 1)     \tcontinue;                      check[next_x][next_y] = 1;                 map_[next_x][next_y] = map_[top_x][top_y] + 1;                 q.push(make_pair(next_x, next_y));                  }              }     }     int main(){              cin &gt;&gt; n &gt;&gt; m;              for(int i=0; i&lt;n; i++){             for(int j=0; j&lt;m; j++){                 scanf(\"%1d\", &amp;map_[i][j]);             }         }              q.push(make_pair(0, 0));         check[0][0] = 1;         bfs();              cout &lt;&lt; map_[n-1][m-1] &lt;&lt; endl;         return 0;     }          후기       전형적인 bfs      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-2178-%EB%AF%B8%EB%A1%9C-%ED%83%90%EC%83%89/",
        "teaser": null
      },{
        "title": "[2573] 빙산",
        "excerpt":"[2573] 빙산   Algorithm: bfs Created: Feb 02, 2020 11:10 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/2573   문제   지구 온난화로 인하여 북극의 빙산이 녹고 있다. 빙산을 그림 1과 같이 2차원 배열에 표시한다고 하자. 빙산의 각 부분별 높이 정보는 배열의 각 칸에 양의 정수로 저장된다. 빙산 이외의 바다에 해당되는 칸에는 0이 저장된다. 그림 1에서 빈칸은 모두 0으로 채워져 있다고 생각한다.      그림 1. 행의 개수가 5이고 열의 개수가 7인 2차원 배열에 저장된 빙산의 높이 정보   빙산의 높이는 바닷물에 많이 접해있는 부분에서 더 빨리 줄어들기 때문에, 배열에서 빙산의 각 부분에 해당되는 칸에 있는 높이는 일년마다 그 칸에 동서남북 네 방향으로 붙어있는 0이 저장된 칸의 개수만큼 줄어든다. 단, 각 칸에 저장된 높이는 0보다 더 줄어들지 않는다. 바닷물은 호수처럼 빙산에 둘러싸여 있을 수도 있다. 따라서 그림 1의 빙산은 일년후에 그림 2와 같이 변형된다.   그림 3은 그림 1의 빙산이 2년 후에 변한 모습을 보여준다. 2차원 배열에서 동서남북 방향으로 붙어있는 칸들은 서로 연결되어 있다고 말한다. 따라서 그림 2의 빙산은 한 덩어리이지만, 그림 3의 빙산은 세 덩어리로 분리되어 있다.      한 덩어리의 빙산이 주어질 때, 이 빙산이 두 덩어리 이상으로 분리되는 최초의 시간(년)을 구하는 프로그램을 작성하시오. 그림 1의 빙산에 대해서는 2가 답이다. 만일 전부 다 녹을 때까지 두 덩어리 이상으로 분리되지 않으면 프로그램은 0을 출력한다.   입력   첫 줄에는 이차원 배열의 행의 개수와 열의 개수를 나타내는 두 정수 N과 M이 한 개의 빈칸을 사이에 두고 주어진다. N과 M은 3 이상 300 이하이다. 그 다음 N개의 줄에는 각 줄마다 배열의 각 행을 나타내는 M개의 정수가 한 개의 빈 칸을 사이에 두고 주어진다. 각 칸에 들어가는 값은 0 이상 10 이하이다. 배열에서 빙산이 차지하는 칸의 개수, 즉, 1 이상의 정수가 들어가는 칸의 개수는 10,000 개 이하이다. 배열의 첫 번째 행과 열, 마지막 행과 열에는 항상 0으로 채워진다.   출력   첫 줄에 빙산이 분리되는 최초의 시간(년)을 출력한다. 만일 빙산이 다 녹을 때까지 분리되지 않으면 0을 출력한다.   예제 입력 1   5 7 0 0 0 0 0 0 0 0 2 4 5 3 0 0 0 3 0 2 5 2 0 0 7 6 2 4 0 0 0 0 0 0 0 0 0   예제 출력 1   2        #include &lt;iostream&gt;     #include &lt;algorithm&gt;     #include &lt;queue&gt;     #include &lt;cstring&gt;     #include &lt;string.h&gt;     #define MAX 303     using namespace std;     int n, m, year;     int map_[MAX][MAX];     int map_copy[MAX][MAX];     int visited[MAX][MAX];     int dx[4] = {0, 0, -1, 1};     int dy[4] = {-1, 1, 0, 0};     void input(){         for(int i=0; i&lt;n; i++){             for(int j=0; j&lt;m; j++){                 cin &gt;&gt; map_[i][j];             }         }     }          void bfs(int x, int y){         queue &lt;pair&lt;int, int&gt;&gt; q;         q.push(make_pair(x, y));         visited[x][y] = 1;              while(!q.empty()){             int top_x = q.front().first;             int top_y = q.front().second;             q.pop();                  for(int i=0; i&lt;4; i++){                 int next_x = top_x + dx[i];                 int next_y = top_y + dy[i];                      if(map_[next_x][next_y] == 0 || visited[next_x][next_y] ||                 next_x &gt;= n|| next_y &gt;=m || next_x &lt; 0 || next_y &lt; 0) continue;                      visited[next_x][next_y] = 1;                 q.push(make_pair(next_x, next_y));                  }         }     }          int melt(int x, int y){              int cnt = 0;         for(int i=0; i&lt;4; i++){             int next_x = x + dx[i];             int next_y = y + dy[i];                  if(map_[next_x][next_y] == 0) cnt++;         }              return cnt;          }     int main() {              cin &gt;&gt; n &gt;&gt; m;         input();              while(true) {                  int landCnt = 0;             for (int i = 0; i &lt; n; i++) {                 for (int j = 0; j &lt; m; j++) {                     if (map_[i][j] != 0 &amp;&amp; !visited[i][j]) {                         landCnt++;                         bfs(i, j);                     }                 }             }                          if (landCnt &gt;= 2) {cout &lt;&lt; year &lt;&lt; endl; return 0;}             if (landCnt == 0) {cout &lt;&lt; 0 &lt;&lt; endl; return 0;}                  //melt             for (int i = 0; i &lt; n; i++) {                 for (int j = 0; j &lt; m; j++) {                     if (map_[i][j] != 0) {                         map_copy[i][j] = map_[i][j] - melt(i, j);                         if (map_copy[i][j] &lt; 0) map_copy[i][j] = 0;                     }                 }             }                  year++;                  memcpy(map_, map_copy, sizeof(map_));             memset(visited, 0, sizeof(visited));             memset(map_copy, 0, sizeof(map_copy));         }     }          문제 풀이       입력 → bfs로 나뉜 섬 탐색 → 녹이기 → 변수 초기화       이 순서대로 진행 한다.       녹일 경우 똑같은 배열에 녹여버리면 이미 녹여버린 빙하로 탐색할 수 있기 때문에 배열을 따로 선언 해 주어야 한다.            후기       같이 녹여버려서 8번이나 틀림 💖      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-2573-%EB%B9%99%EC%82%B0/",
        "teaser": null
      },{
        "title": "[3187] 양치기 꿍",
        "excerpt":"[3187] 양치기 꿍   Algorithm: bfs Created: Feb 02, 2020 11:13 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/3187   문제   양치기 꿍은 맨날 늑대가 나타났다고 마을 사람들을 속였지만 이젠 더이상 마을 사람들이 속지 않는다. 화가 난 꿍은 복수심에 불타 아예 늑대들을 양들이 있는 울타리안에 마구 집어넣어 양들을 잡아먹게 했다.   하지만 양들은 보통 양들이 아니다. 같은 울타리 영역 안의 양들의 숫자가 늑대의 숫자보다 더 많을 경우 늑대가 전부 잡아먹힌다. 물론 그 외의 경우는 양이 전부 잡아먹히겠지만 말이다.   꿍은 워낙 똑똑했기 때문에 이들의 결과는 이미 알고있다. 만약 빈 공간을 ‘.’(점)으로 나타내고 울타리를 ‘#’, 늑대를 ‘v’, 양을 ‘k’라고 나타낸다면 여러분은 몇 마리의 양과 늑대가 살아남을지 계산할 수 있겠는가?   단, 울타리로 막히지 않은 영역에는 양과 늑대가 없으며 양과 늑대는 대각선으로 이동할 수 없다.   입력   입력의 첫 번째 줄에는 각각 영역의 세로와 가로의 길이를 나타내는 두 개의 정수 R, C (3 ≤ R, C ≤ 250)가 주어진다.   다음 각 R줄에는 C개의 문자가 주어지며 이들은 위에서 설명한 기호들이다.   출력   살아남게 되는 양과 늑대의 수를 각각 순서대로 출력한다.   예제 입력 1   6 6 ...#.. .##v#. #v.#.# #.k#.# .###.# ...###   예제 출력 1   0 2   예제 입력 2   8 8 .######. #..k...# #.####.# #.#v.#.# #.#.k#k# #k.##..# #.v..v.# .######.   예제 출력 2   3 1   예제 입력 3   9 12 .###.#####.. #.kk#...#v#. #..k#.#.#.#. #..##k#...#. #.#v#k###.#. #..#v#....#. #...v#v####. .####.#vv.k# .......####.   예제 출력 3   3 5    ```c++     #include      #include      #include      #include      #include      #define MAX 303     using namespace std;     int r, c, sheep, wolf;     int ansSheep, ansWolf;     char fence[MAX][MAX];     int visit[MAX][MAX];     queue &lt;pair&lt;int, int&gt;&gt; q;     int dx[4] = {0, 0, -1, 1};     int dy[4] = {-1, 1, 0, 0};     void bfs(int x, int y){       q.push(make_pair(x, y));     visit[x][y] = 1;     if(fence[x][y] == 'k') sheep++;     if(fence[x][y] == 'v') wolf++;      while(!q.empty()){         int top_x = q.front().first;         int top_y = q.front().second;         q.pop();          for(int i=0; i&lt;4; i++){             int next_x = top_x + dx[i];             int next_y = top_y + dy[i];              if(visit[next_x][next_y] || next_x &lt; 0 || next_y &lt; 0 || next_x &gt;= r || next_y &gt;= c || fence[next_x][next_y] == '#')                 continue;              if(fence[next_x][next_y] == 'k') sheep++;             if(fence[next_x][next_y] == 'v') wolf++;              visit[next_x][next_y] = 1;             q.push(make_pair(next_x, next_y));         }     } } void input(){      for(int i=0; i&lt;r; i++){         for(int j=0; j&lt;c; j++){             cin &gt;&gt; fence[i][j];         }     } } void solve(){     for(int i=0; i&lt;r; i++){         for(int j=0; j&lt;c; j++){             if(fence[i][j] != '#' &amp;&amp; !visit[i][j]){                 wolf = 0; sheep = 0;                 bfs(i, j);                  if (wolf &lt; sheep)                     ansSheep += sheep;                 else                     ansWolf += wolf;             }         }     } } int main() {      cin &gt;&gt; r &gt;&gt; c;      input();      solve();      cout &lt;&lt; ansSheep &lt;&lt; ' ' &lt;&lt; ansWolf &lt;&lt; endl;      return 0;  } ```  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-3187-%EC%96%91%EC%B9%98%EA%B8%B0-%EA%BF%8D/",
        "teaser": null
      },{
        "title": "[leetcode] Unique Paths",
        "excerpt":"Unique Paths   Algorithm: DP Created: Jan 28, 2020 6:16 PM DoubleChk: No Type: LeetCode level: 2 link: https://leetcode.com/problems/unique-paths/   A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).   The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).   How many possible unique paths are there?      Above is a 7 x 3 grid. How many possible unique paths are there?   Note: m and n will be at most 100.   Example 1:   Input: m = 3, n = 2 Output: 3 Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner: 1. Right -&gt; Right -&gt; Down 2. Right -&gt; Down -&gt; Right 3. Down -&gt; Right -&gt; Right   Example 2:   Input: m = 7, n = 3 Output: 28        class Solution {     public:         int dp[101][101];         int uniquePaths(int m, int n) {                  for(int i=0; i&lt;m; i++){                 dp[i][0] = 1;             }                          for(int j=0; j&lt;n; j++){                 dp[0][j] = 1;             }                          for(int i=1; i&lt;m; i++){                 for(int j=1; j&lt;n; j++){                     dp[i][j] = dp[i][j-1] + dp[i-1][j];                 }             }                          return dp[m-1][n-1];         }     };          문제풀이       매우 간단한 dp 문제       한 칸에서 갈 수 있는 칸이 오른쪽, 아래 밖에 없기 때문에,       1, 1 부터 돌면서 왼쪽에서 오는 길의 수 + 위쪽에서 오는 길의 수를 하면 된다.       오른쪽으로만 가는 길, 아래로만 가는 길은 1로 미리 초기화 해 놓았다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Unique-Paths/",
        "teaser": null
      },{
        "title": "[leetcode] Sort Characters By Frequency",
        "excerpt":"Sort Characters By Frequency   Algorithm: 해쉬 DoubleChk: No Type: LeetCode level: 2 link: https://leetcode.com/problems/sort-characters-by-frequency/   Given a string, sort it in decreasing order based on the frequency of characters.   Example 1:   Input: \"tree\"  Output: \"eert\"  Explanation: 'e' appears twice while 'r' and 't' both appear once. So 'e' must appear before both 'r' and 't'. Therefore \"eetr\" is also a valid answer.   Example 2:   Input: \"cccaaa\"  Output: \"cccaaa\"  Explanation: Both 'c' and 'a' appear three times, so \"aaaccc\" is also a valid answer. Note that \"cacaca\" is incorrect, as the same characters must be together.   Example 3:   Input:Output:Explanation:        class Solution {     public:         static bool myCompare(pair &lt;char, int&gt; a, pair &lt;char, int&gt; b){             return a.second &gt; b.second;         }         string frequencySort(string s) {             map &lt;char, int&gt; mp;             int n = s.length();                          //update frequency             for(char c : s){                 mp[c]++;             }                          vector &lt; pair&lt;char, int&gt;&gt; v(mp.begin(), mp.end());                          //sort by frequency             sort(v.begin(), v.end(), myCompare);                          //add to answer string by frequency             string ans = \"\";             for(auto &amp;i : v){                 //vector.second 만큼의 빈도로 있기 때문에                 for(int j=0; j&lt;i.second; j++){                     ans += i.first;                 }             }             return ans;                      }     };  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Sort-Characters-By-Frequency/",
        "teaser": null
      },{
        "title": "[leetcode] Top K Frequent Words",
        "excerpt":"Top K Frequent Words   Algorithm: 정렬, 해쉬 Created: Feb 08, 2020 11:25 PM DoubleChk: No Type: LeetCode level: 2 link: https://leetcode.com/problems/top-k-frequent-words/   Given a non-empty list of words, return the k most frequent elements.   Your answer should be sorted by frequency from highest to lowest. If two words have the same frequency, then the word with the lower alphabetical order comes first.   Example 1:   Input: [\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"], k = 2 Output: [\"i\", \"love\"] Explanation: \"i\" and \"love\" are the two most frequent words.     Note that \"i\" comes before \"love\" due to a lower alphabetical order.   Example 2:   Input: [\"the\", \"day\", \"is\", \"sunny\", \"the\", \"the\", \"the\", \"sunny\", \"is\", \"is\"], k = 4 Output: [\"the\", \"is\", \"sunny\", \"day\"] Explanation: \"the\", \"is\", \"sunny\" and \"day\" are the four most frequent words,     with the number of occurrence being 4, 3, 2 and 1 respectively.   Note:      You may assume k is always valid, 1 ≤ k ≤ number of unique elements.   Input words contain only lowercase letters.   Follow up:      Try to solve it in O(n log k) time and O(n) extra space.        class Solution {     public:         static bool myCompare(const pair&lt;string, int&gt;&amp; a, const pair&lt;string, int&gt;&amp;b){             if(a.second==b.second)                return a.first&lt;b.first;             return a.second&gt;b.second;         }         vector&lt;string&gt; topKFrequent(vector&lt;string&gt;&amp; words, int k) {             unordered_map &lt;string, int&gt; m;             for(auto str : words){                 m[str]++;             }                          vector &lt;pair&lt;string, int&gt;&gt; temp;                          for(auto i : m){                 temp.push_back(make_pair(i.first, i.second));             }                          sort(temp.begin(), temp.end(), myCompare);                          vector &lt;string&gt; ans;             for(int i=0; i&lt;k; i++){                 ans.push_back(temp[i].first);                  }                          return ans;         }              };          문제 풀이       맵으로 string의 갯수를 세어준다.       value 값으로 정렬을 해야 하기 때문에, vector를 하나 생성 해 복사 해 준다.       sort에서 compare 함수를 통해 value값을 비교한다.       만약 갯수가 같다면, string을 비교 해 알파벳 순서가 더 빠른 애로 정렬한다.       정렬이 끝난 후 정답 벡터에 k만큼 push 한다.            후기       50퍼정도의 속도가 나왔다 더 빨리 푸는 방법이 있으려나      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Top-K-Frequent-Words/",
        "teaser": null
      },{
        "title": "[leetcode] Longest Palindrome",
        "excerpt":"409. Longest Palindrome   Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.   This is case sensitive, for example “Aa” is not considered a palindrome here.   Note: Assume the length of given string will not exceed 1,010.   Example:   Input:     “abccccdd”   Output:     7   Explanation: One longest palindrome that can be built is “dccaccd”, whose length is 7.    class Solution { public:     int longestPalindrome(string s) {         unordered_map &lt;char, int&gt; m;                  for(auto c : s){             m[c]++;         }                  int ans = 0;         int flag = false;                  for (unordered_map&lt;char, int&gt;::              const_iterator it = m.begin(); it != m.end(); ++it){             if(it-&gt;second == 1){                 if(flag) continue;                 ans += 1;                 flag = true;             }else if(it-&gt;second % 2 == 1){                 if(flag){                     ans += (it-&gt;second - 1);                 }                 else {                     ans += it-&gt;second;                     flag = true;                 }             }else if(it-&gt;second % 2 == 0){                 ans += (it-&gt;second);             }         }         return ans;     } };          문제풀이   해쉬 맵에 글자들의 갯수를 저장한다.       palindrome이 되는 조건은 가운데 기준으로 대칭을 이루면 된다.  1개인 경우는 대칭의 기준이 되는 애 1개면 충분 하기 때문에 flag로 구분 해 준다.  홀수인 경우는 n-1개로 짝수로 만들어서 대칭을 만든다.  이 때에, 기준이 되는 1개가 없을 경우 ex) “ccc” 를 예외처리 해준다.  짝수인 경우는 그냥 대칭을 만든다.       ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Longest-Palindrome/",
        "teaser": null
      },{
        "title": "[leetcode] Map Sum Pairs",
        "excerpt":"Implement a MapSum class with insert, and sum methods.   For the method insert, you’ll be given a pair of (string, integer). The string represents the key and the integer represents the value. If the key already existed, then the original key-value pair will be overridden to the new one.   For the method sum, you’ll be given a string representing the prefix, and you need to return the sum of all the pairs’ value whose key starts with the prefix.   Example 1:   Input: insert(“apple”, 3), Output: Null Input: sum(“ap”), Output: 3 Input: insert(“app”, 2), Output: Null Input: sum(“ap”), Output: 5   –   class MapSum { public:          unordered_map&lt;string, int&gt; m;          void insert(string key, int val) {         m[key] = val;     }          int sum(string prefix) {         int ret = 0;         for(auto cur : m){             int flag = 1;             for(int j=0; j&lt;prefix.length(); j++){                 string compare = cur.first;                 if(prefix[j] != compare[j]){                     flag = 0;                     break;                 }             }             if(flag) ret += cur.second;         }                  return ret;     } };       문제 풀이   맵으로 insert를 해준 다음,   Prefix의 길이만큼 돌면서 flag로 맞는지 아닌지 체크 해 준다.   후기   여행중 코딩 ㅎㅅㅎ ..  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Map-Sum-Pairs/",
        "teaser": null
      },{
        "title": "[leetcode] Validate Binary Tree Nodes",
        "excerpt":"Validate Binary Tree Nodes   Algorithm: bfs Created: Feb 23, 2020 1:59 PM DoubleChk: No Type: LeetCode level: 2 link: https://leetcode.com/problems/validate-binary-tree-nodes/   You have n binary tree nodes numbered from 0 to n - 1 where node i has two children leftChild[i] and rightChild[i], return true if and only if all the given nodes form exactly one valid binary tree.   If node i has no left child then leftChild[i] will equal -1, similarly for the right child.   Note that the nodes have no values and that we only use the node numbers in this problem.   Example 1:      Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,-1,-1,-1] Output: true   Example 2:      Input: n = 4, leftChild = [1,-1,3,-1], rightChild = [2,3,-1,-1] Output: false   Example 3:      Input: n = 2, leftChild = [1,0], rightChild = [-1,-1] Output: false   Example 4:      Input: n = 6, leftChild = [1,-1,-1,4,-1,-1], rightChild = [2,-1,-1,5,-1,-1] Output: false   Constraints:      1 &lt;= n &lt;= 10^4   leftChild.length == rightChild.length == n   -1 &lt;= leftChild[i], rightChild[i] &lt;= n - 1     class Solution { public:     int check[10001];     queue &lt;int&gt; q;     bool validateBinaryTreeNodes(int n, vector&lt;int&gt;&amp; leftChild, vector&lt;int&gt;&amp; rightChild) {         q.push(0);         int cnt = 0;         while(!q.empty()){             int top = q.front();             if(check[top]) return false;             check[top] = 1;             q.pop();             cnt++;                          if(leftChild[top] != -1) q.push(leftChild[top]);             if(rightChild[top] != -1) q.push(rightChild[top]);                      }                  if(cnt != n) return false;                  return true;     } };           문제 풀이       bfs로 풀었다.       올바르지 않은 트리일 경우가              사이클이 생기는 경우       두 개로 나눠진 경우           이렇게 생각 했다. (예시에 나온 경우들)       풀이 방법은              check 배열로 방문 처리를 해 준다 → 이미 방문 했다면 cycle       cnt 변수로 노드 갯수를 세준다. queue가 비었을 때, cnt와 n이 같지 않다면 트리가 1개 이상인 것       위 두 경우에 걸리지 않았다면 true                후기       첫번째 콘테스트였다.       이게 될까? 했는데 1트에 됨.. ?       30개밖에 테스트케이스가 없어서 예외가 더 있을 것 같은데 그래도 풀었으 ㅎㅅㅎ      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Validate-Binary-Tree-Nodes/",
        "teaser": null
      },{
        "title": "[백준 1890] 점프",
        "excerpt":"점프   Algorithm: DP Created: Feb 24, 2020 11:43 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/1890   문제   N×N 게임판에 수가 적혀져 있다. 이 게임의 목표는 가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 점프를 해서 가는 것이다.   각 칸에 적혀있는 수는 현재 칸에서 갈 수 있는 거리를 의미한다. 반드시 오른쪽이나 아래쪽으로만 이동해야 한다. 0은 더 이상 진행을 막는 종착점이며, 항상 현재 칸에 적혀있는 수만큼 오른쪽이나 아래로 가야 한다. 한 번 점프를 할 때, 방향을 바꾸면 안 된다. 즉, 한 칸에서 오른쪽으로 점프를 하거나, 아래로 점프를 하는 두 경우만 존재한다.   가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 규칙에 맞게 이동할 수 있는 경로의 개수를 구하는 프로그램을 작성하시오.   입력   첫째 줄에 게임 판의 크기 N (4 ≤ N ≤ 100)이 주어진다. 그 다음 N개 줄에는 각 칸에 적혀져 있는 수가 N개씩 주어진다. 칸에 적혀있는 수는 0보다 크거나 같고, 9보다 작거나 같은 정수이며, 가장 오른쪽 아래 칸에는 항상 0이 주어진다.   출력   가장 왼쪽 위 칸에서 가장 오른쪽 아래 칸으로 문제의 규칙에 맞게 갈 수 있는 경로의 개수를 출력한다. 경로의 개수는 263-1보다 작거나 같다.   예제 입력 1   4 2 3 3 1 1 2 1 3 1 2 3 1 3 1 1 0   예제 출력 1   3   힌트           #include &lt;iostream&gt;     #include &lt;algorithm&gt;     #define MAX 1001     using namespace std;     int n, m;     long long int dp[MAX][MAX];     long long int board[MAX][MAX];     void input(){         cin &gt;&gt; n;         for(int i=0; i&lt;n; i++){             for(int j=0; j&lt;n; j++){                 cin &gt;&gt; board[i][j];             }         }     }          int main(){              input();              dp[0][0] = 1;              for(int i=0; i&lt;n; i++){             for(int j=0; j&lt;n; j++){                 long long int next_x = i + board[i][j];                 long long int next_y = j + board[i][j];                 if(n-1 == i &amp;&amp; n-1 == j) break;                      if(next_y &lt; n) {                     dp[i][next_y] = dp[i][j] + dp[i][next_y];                 }                 if(next_x &lt; n){                     dp[next_x][j] = dp[i][j] + dp[next_x][j];                 }                  }         }              cout &lt;&lt; dp[n-1][n-1] &lt;&lt; endl;              return 0;     }          문제 풀이       반복문을 돌면서 다음 점프할 칸을 더해준다. (next_x,  next_y)       범위가 넘지 않으면 오른쪽 점프와 아래쪽 점프를 업데이트 해 준다.       만약 끝에 도달하면 break 한다.            후기       계란물 묻힌 식빵과 설탕은 존맛      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1890-%EC%A0%90%ED%94%84/",
        "teaser": null
      },{
        "title": "[leetcode] Closest Divisors",
        "excerpt":"Closest Divisors   Algorithm: 수학 Created: Feb 27, 2020 11:35 PM DoubleChk: No Type: LeetCode level: 2 link: https://leetcode.com/problems/closest-divisors/   Given an integer num, find the closest two integers in absolute difference whose product equals num + 1 or num + 2.   Return the two integers in any order.   Example 1:   Input: num = 8 Output: [3,3] Explanation: For num + 1 = 9, the closest divisors are 3 &amp; 3, for num + 2 = 10, the closest divisors are 2 &amp; 5, hence 3 &amp; 3 is chosen.   Example 2:   Input: num = 123 Output: [5,25]   Example 3:   Input: num = 999 Output: [40,25]   Constraints:      1 &lt;= num &lt;= 10^9        class Solution {     public:         vector&lt;int&gt; closestDivisors(int num) {             vector &lt;int&gt; ans;                          int num1 = num+1, num2 = num+2, dist = INT_MAX;                          for(int i=sqrt(num1); i&gt;=1; i--){                 if(num1 % i == 0){                     ans = {i, num1/i};                     dist = num1 / i - i;                     break;                      }             }                          for(int i=sqrt(num2); i&gt;=1; i--){                 if(num2 % i == 0){                     if(dist &gt; (num2 / i - i)){                         ans = {i, num2/i};                     }                     break;                 }                              }                          return ans;         }     };          문제 풀이       숫자의 약수의 쌍들 중, 두 수의 숫자의 차가 제일 적은 쌍을 찾으면 된다.       예를 들어, 100일 때는 → 10*10으로 둘의 차이가 0으로 제일 작다.       100의 약수는 다음과 같다         1*100    ^   2*50     |   4*25     |   5*20     |  (Increasing distance as we go up)   10*10 &lt;- sqrt, we see repetitions after this point (Also notice this is the closest)   20*5    25*4    2*50    100*1           제곱근을 기준으로 두 번 반복 되므로, sqrt(num)을 해준다면 한 번만 반복문을 돌아도 된다는 것이다.       그리고 하나의 수가 작아질 수록 차이가 커진다는 것을 볼 수 있다.       따라서, num1, num2를 제곱근 한 곳부터 ~ 1이 될 때까지 반복하며,       만약 나누어 떨어진다면, 두 수의 차이를 저장하고 반복문을 멈춘다.       왜냐하면 반복문을 진행할 수록 두 수의 차이가 벌어지기 때문이다.       num1을 한 후 num2에서도 동일한 과정을 반복하고,       차이 (dist)가 제일 적은 것을 저장해주면 된다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Closest-Divisors/",
        "teaser": null
      },{
        "title": "[leetcode] Minimum Cost to Make at Least One Valid Path in a Grid",
        "excerpt":"Minimum Cost to Make at Least One Valid Path in a Grid   Algorithm: bfs Created: Mar 04, 2020 4:35 PM DoubleChk: No Type: LeetCode level: 3 link: https://leetcode.com/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/   Given a mxn grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell.   The sign of grid[i][j] can be:      1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])   2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])   3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])   4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])   Notice that there could be some invalid signs on the cells of the grid which points outside the grid.   You will initially start at the upper left cell (0,0). A valid path in the grid is a path which starts from the upper left cell (0,0) and ends at the bottom-right cell (m - 1, n - 1) following the signs on the grid. The valid path doesn’t have to be the shortest.   You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.   Return the minimum cost to make the grid have at least one valid path.   Example 1:      Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]] Output: 3 Explanation: You will start at point (0, 0). The path to (3, 3) is as follows. (0, 0) --&gt; (0, 1) --&gt; (0, 2) --&gt; (0, 3) change the arrow to down with cost = 1 --&gt; (1, 3) --&gt; (1, 2) --&gt; (1, 1) --&gt; (1, 0) change the arrow to down with cost = 1 --&gt; (2, 0) --&gt; (2, 1) --&gt; (2, 2) --&gt; (2, 3) change the arrow to down with cost = 1 --&gt; (3, 3) The total cost = 3.   Example 2:      Input: grid = [[1,1,3],[3,2,2],[1,1,4]] Output: 0 Explanation: You can follow the path from (0, 0) to (2, 2).   Example 3:      Input: grid = [[1,2],[4,3]] Output: 1   Example 4:   Input: grid = [[2,2,2],[2,2,2]] Output: 3   Example 5:   Input: grid = [[4]] Output: 0   Constraints:      m == grid.length   n == grid[i].length   1 &lt;= m, n &lt;= 100         class Solution {     public:         int dir[4][2] = {{0, 1}, {0, -1}, {1, 0}, { -1, 0}};         queue &lt;pair&lt;int, int&gt;&gt; q;              int minCost(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {                          int cost = 0;             int m = grid.size();             int n = grid[0].size();             vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, INT_MAX));                          dfs(grid, 0, 0, cost, m, n, dp);                          while(!q.empty()){                 cost++;                 int sz = q.size();                                  for(int i=0; i&lt;sz; i++){                     pair&lt;int, int&gt; p = q.front();                     int px = p.first;                     int py = p.second;                     q.pop();                                          for(int j=0; j&lt;4; j++){                                         dfs(grid, px + dir[j][0], py + dir[j][1], cost, m, n, dp);                     }                 }                              }                          return dp[m-1][n-1];         }                  void dfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, int x, int y, int cost, int m, int n, vector&lt;vector&lt;int&gt;&gt;&amp; dp){             if(x &gt;= m || y &gt;= n || x &lt; 0 || y &lt; 0 ||dp[x][y] != INT_MAX) return;             dp[x][y] = cost;             q.push(make_pair(x, y));                          int next_dir = grid[x][y] - 1;             dfs(grid, x + dir[next_dir][0], y + dir[next_dir][1], cost, m, n, dp);         }     };                문제풀이                       dfs로 방문 가능 한 모든 곳 탐색                        방문한 노드들을 queue에 삽입, visit 체크                        큐를 돌면서 상하좌우 탐색                        후기       3레벨 첨풀어봐 ㅎㅅㅎ      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Minimum-Cost-to-Make-at-Least-One-Valid-Path-in-a-Grid/",
        "teaser": null
      },{
        "title": "[leetcode] Rank Teams by Votes",
        "excerpt":"Rank Teams by Votes   Algorithm: 배열, 정렬 Created: Mar 04, 2020 3:09 PM DoubleChk: No Type: LeetCode level: 2 link: https://leetcode.com/problems/rank-teams-by-votes/   In a special ranking system, each voter gives a rank from highest to lowest to all teams participated in the competition.   The ordering of teams is decided by who received the most position-one votes. If two or more teams tie in the first position, we consider the second position to resolve the conflict, if they tie again, we continue this process until the ties are resolved. If two or more teams are still tied after considering all positions, we rank them alphabetically based on their team letter.   Given an array of strings votes which is the votes of all voters in the ranking systems. Sort all teams according to the ranking system described above.   Return a string of all teams sorted by the ranking system.   Example 1:   Input: votes = [\"ABC\",\"ACB\",\"ABC\",\"ACB\",\"ACB\"] Output: \"ACB\" Explanation: Team A was ranked first place by 5 voters. No other team was voted as first place so team A is the first team. Team B was ranked second by 2 voters and was ranked third by 3 voters. Team C was ranked second by 3 voters and was ranked third by 2 voters. As most of the voters ranked C second, team C is the second team and team B is the third.   Example 2:   Input: votes = [\"WXYZ\",\"XYZW\"] Output: \"XWYZ\" Explanation: X is the winner due to tie-breaking rule. X has same votes as W for the first position but X has one vote as second position while W doesn't have any votes as second position.   Example 3:   Input: votes = [\"ZMNAGUEDSJYLBOPHRQICWFXTVK\"] Output: \"ZMNAGUEDSJYLBOPHRQICWFXTVK\" Explanation: Only one voter so his votes are used for the ranking.   Example 4:   Input: votes = [\"BCA\",\"CAB\",\"CBA\",\"ABC\",\"ACB\",\"BAC\"] Output: \"ABC\" Explanation:  Team A was ranked first by 2 voters, second by 2 voters and third by 2 voters. Team B was ranked first by 2 voters, second by 2 voters and third by 2 voters. Team C was ranked first by 2 voters, second by 2 voters and third by 2 voters. There is a tie and we rank teams ascending by their IDs.   Example 5:   Input: votes = [\"M\",\"M\",\"M\",\"M\"] Output: \"M\" Explanation: Only team M in the competition so it has the first rank.   Constraints:      1 &lt;= votes.length &lt;= 1000   1 &lt;= votes[i].length &lt;= 26   votes[i].length == votes[j].length for 0 &lt;= i, j &lt; votes.length.   votes[i][j] is an English upper-case letter.   All characters of votes[i] are unique.   All the characters that occur in votes[0] also occur in votes[j] where 1 &lt;= j &lt; votes.length.        class Solution {     public:         string rankTeams(vector&lt;string&gt;&amp; votes) {             vector&lt;vector&lt;int&gt;&gt; rank(26, vector&lt;int&gt;(26, 0));             for(auto v : votes){                 for(int i=0; i&lt;v.length(); i++){                     rank[v[i] - 'A'][i]++;                 }             }                          auto cmp = [&amp;](char a, char b){                 return rank[a - 'A'] &gt; rank[b - 'A'] ||                     rank[a - 'A'] == rank[b - 'A'] &amp;&amp; a &lt; b;             };                          string x = votes[0];             sort(begin(x), end(x), cmp);             return x;         }     };          문제 풀이       람다식을 이용해서 sorting 하여 푸는 문제.       일단 각 글자들이 얼마나 나오는지 체크 해 준다.       그리고 sorting을 해주는데, cmp라는 람다 함수를 비교함수로 사용한다.       랭킹이 큰 것, 만약 같다면 알파벳 순서가 빠른 순서로 정렬한다.            후기       contest 2회차       한문제밖에 못풀었는데 랭킹이 올랐다       랭작 꿀잼      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Rank-Teams-by-Votes/",
        "teaser": null
      },{
        "title": "[TIL] Promise, Async/await",
        "excerpt":"0312 TIL   Created By: 성희 배 Last Edited: Mar 12, 2020 11:29 PM         데이터를 받아올 때, 두 개를 한번에 받아오다 보니 동기화가 안돼서 한개만 받아와지는 경우가 있었다.      기존 코드        Restriction.countDocuments({state : 0}, (err, cnt)=&gt;{         ret.prohibitions = cnt      }).then(Restriction.countDocuments({state : 1}, (err, cnt)=&gt;{         ret.restrictions = cnt      })).then(()=&gt; res.send(ret))           .then()으로 감싸다 보니 한 개만 보내지고.. 난리         변경 코드 ```javascript     async function fetch(){         const prohibitions = await Restriction.countDocuments({state : 0})         const restrictions = await Restriction.countDocuments({state : 1})        res.send({       restrictions : restrictions,       prohibitions : prohibitions     })  } ``` - 해결 방법이 없을까 검색을 해보니 async/await이 있어 사용해 봤다! - 코드도 훨씬 가시적이고, 데이터도 너무 잘 보내짐 👍   Async/await 과 Promise   Promise?      .then().then()…   함수 호출 (resolve라고 하나봄) 이후 then()에 걸린 함수 실행   Async/await      async 함수(), await 함수()   await은 async가 resolve 된 이후 실행   그래서 Promise보다 Async가 나은 이유?      동기적 코드 흐름으로 개발이 가능   코드가 간결해지고, 가독성이 높아진다   응답데이터 (err, data, res 등)를 없앨 수 있음   Promise 사용 시 콜백 내는 동기화 가능하지만, 밖의 함수는 동기화 불가        검색 해보니 Promise.all을 사용하면 여러개를 기다릴 수 있었다..ㅎㅎㅎ! 검색 부족이었던걸로..  ","categories": ["til"],
        "tags": [],
        "url": "/til/til-0312TIL/",
        "teaser": null
      },{
        "title": "[TIL] window.location, document.location 차이점, 유동 포워딩, 고정 포워딩",
        "excerpt":"Created By: 성희 배 Last Edited: Mar 23, 2020 1:00 AM   window.location과 document.location의 차이   window.location      현재 위치를 object 값으로 가져옴   document.location      현재 URL 값을 string으로 변환해서 가져옴   ⇒ 웹사이트 호환성 때문에 document.location보다는 window.location을 추천한다.   ⇒ document.location은 document.URL로 직관적이게 바뀌었다.     유동 포워딩, 고정 포워딩   유동 포워딩      접속 하는 URL로 주소창에 표기   meta 방식으로 포워딩 설정   고정 포워딩      접속 시 도메인 그대로 주소창에 표기   frame 방식으로 포워딩 설정   ex ) 페이지를 이동 해도 www.example.co.kr이 그대로 유지  ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-window.location,-document.location-%EC%B0%A8%EC%9D%B4%EC%A0%90,-%EC%9C%A0%EB%8F%99-%ED%8F%AC%EC%9B%8C%EB%94%A9,-%EA%B3%A0%EC%A0%95-%ED%8F%AC%EC%9B%8C%EB%94%A9/",
        "teaser": null
      },{
        "title": "[백준 13460] 구슬 탈출 2",
        "excerpt":"Algorithm: bfs Created: Mar 23, 2020 4:39 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/13460   문제   스타트링크에서 판매하는 어린이용 장난감 중에서 가장 인기가 많은 제품은 구슬 탈출이다. 구슬 탈출은 직사각형 보드에 빨간 구슬과 파란 구슬을 하나씩 넣은 다음, 빨간 구슬을 구멍을 통해 빼내는 게임이다.   보드의 세로 크기는 N, 가로 크기는 M이고, 편의상 1×1크기의 칸으로 나누어져 있다. 가장 바깥 행과 열은 모두 막혀져 있고, 보드에는 구멍이 하나 있다. 빨간 구슬과 파란 구슬의 크기는 보드에서 1×1크기의 칸을 가득 채우는 사이즈이고, 각각 하나씩 들어가 있다. 게임의 목표는 빨간 구슬을 구멍을 통해서 빼내는 것이다. 이때, 파란 구슬이 구멍에 들어가면 안 된다.   이때, 구슬을 손으로 건드릴 수는 없고, 중력을 이용해서 이리 저리 굴려야 한다. 왼쪽으로 기울이기, 오른쪽으로 기울이기, 위쪽으로 기울이기, 아래쪽으로 기울이기와 같은 네 가지 동작이 가능하다.   각각의 동작에서 공은 동시에 움직인다. 빨간 구슬이 구멍에 빠지면 성공이지만, 파란 구슬이 구멍에 빠지면 실패이다. 빨간 구슬과 파란 구슬이 동시에 구멍에 빠져도 실패이다. 빨간 구슬과 파란 구슬은 동시에 같은 칸에 있을 수 없다. 또, 빨간 구슬과 파란 구슬의 크기는 한 칸을 모두 차지한다. 기울이는 동작을 그만하는 것은 더 이상 구슬이 움직이지 않을 때 까지이다.   보드의 상태가 주어졌을 때, 최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 구하는 프로그램을 작성하시오.   입력   첫 번째 줄에는 보드의 세로, 가로 크기를 의미하는 두 정수 N, M (3 ≤ N, M ≤ 10)이 주어진다. 다음 N개의 줄에 보드의 모양을 나타내는 길이 M의 문자열이 주어진다. 이 문자열은 ‘.’, ‘#’, ‘O’, ‘R’, ‘B’ 로 이루어져 있다. ‘.‘은 빈 칸을 의미하고, ‘#‘은 공이 이동할 수 없는 장애물 또는 벽을 의미하며, ‘O‘는 구멍의 위치를 의미한다. ‘R‘은 빨간 구슬의 위치, ‘B‘는 파란 구슬의 위치이다.   입력되는 모든 보드의 가장자리에는 모두 ‘#‘이 있다. 구멍의 개수는 한 개 이며, 빨간 구슬과 파란 구슬은 항상 1개가 주어진다.   출력   최소 몇 번 만에 빨간 구슬을 구멍을 통해 빼낼 수 있는지 출력한다. 만약, 10번 이하로 움직여서 빨간 구슬을 구멍을 통해 빼낼 수 없으면 -1을 출력한다.   예제 입력 1   5 5 ##### #..B# #.#.# #RO.# #####   예제 출력 1   1   예제 입력 2   7 7 ####### #...RB# #.##### #.....# #####.# #O....# #######   예제 출력 2   5   예제 입력 3   7 7 ####### #..R#B# #.##### #.....# #####.# #O....# #######   예제 출력 3   5   예제 입력 4   10 10 ########## #R#...##B# #...#.##.# #####.##.# #......#.# #.######.# #.#....#.# #.#.#.#..# #...#.O#.# ##########   예제 출력 4   -1   예제 입력 5   3 7 ####### #R.O.B# #######   예제 출력 5   1   예제 입력 6   10 10 ########## #R#...##B# #...#.##.# #####.##.# #......#.# #.######.# #.#....#.# #.#.##...# #O..#....# ##########   예제 출력 6   7   예제 입력 7   3 10 ########## #.O....RB# ##########   예제 출력 7   -1        #include &lt;iostream&gt;     #include &lt;queue&gt;     #include &lt;algorithm&gt;     using namespace std;     struct bead {         int rx, ry, bx, by, d;     };          int n, m;     char box[10][10];     bool check[10][10][10][10];     queue&lt;bead&gt; q;     const int dx[] = {-1, 0, 1, 0}, dy[] = {0, 1, 0, -1};          void move(int &amp;x, int &amp;y, int &amp;c, int dx, int dy) {         while (box[x+dx][y+dy] != '#' &amp;&amp; box[x][y] != 'O') {             x += dx;             y += dy;             c += 1;         }     }          void bfs() {         while(!q.empty()){                  int rx = q.front().rx; int ry = q.front().ry;             int bx = q.front().bx; int by = q.front().by;             int d = q.front().d;                  if(d &gt;= 10){                 cout &lt;&lt; -1 &lt;&lt; endl;                 return;             }             q.pop();                  for(int i=0; i&lt;4; i++){                 int nrx = rx, nry = ry, nbx = bx, nby = by;                 int count_red = 0, count_blue = 0, nd = d+1;                      //움직이기                 move(nbx, nby, count_blue, dx[i], dy[i]);                 move(nrx, nry, count_red, dx[i], dy[i]);                      if(box[nbx][nby] == 'O') continue;                      if(box[nrx][nry] == 'O'){                     cout &lt;&lt; nd &lt;&lt; endl;                     return;                 }                      if(nbx == nrx &amp;&amp; nby == nry){                     if(count_blue &gt; count_red)                         nbx -= dx[i], nby -= dy[i];                     else nrx -= dx[i], nry -= dy[i];                 }                      if(check[nrx][nry][nbx][nby]) continue;                 check[nrx][nry][nbx][nby] = true;                 q.push({nrx, nry, nbx, nby, nd});                  }         }         cout &lt;&lt; -1 &lt;&lt; endl;     }          int main() {         cin &gt;&gt; n &gt;&gt; m;         int rx = 0, ry = 0, bx = 0, by = 0;         for (int i=0; i&lt;n; i++) {             for (int j=0; j&lt;m; j++) {                 cin &gt;&gt; box[i][j];                 if (box[i][j] == 'R') rx = i, ry = j;                 else if (box[i][j] == 'B') bx = i, by = j;             }         }         q.push({rx, ry, bx, by, 0});         check[rx][ry][bx][by] = true;         bfs();         return 0;     }          문제 풀이       BFS를 사용해서 푸는 문제이다.       상자를 상, 하, 좌, 우로 기울이면서 빨간 구슬을 구멍에 넣는 것이다. 이 때, 구슬은 기울인 위치의 끝까지 이동한다.       beads라는 구조체를 만들어 빨간구슬 위치, 파란구슬 위치, 그리고 박스를 기울인 횟수를 저장한다.       beads를 넣는 큐를 만들고, 방문 처리를 해주는 배열을 만든다.       한 번 기울였으면 다시 돌려놓을 필요가 없다. (원위치로 가기 때문에)       큐를 돌면서, 10번 넘게 기울였다면 -1을 출력한다.       상, 하, 좌, 우를 돌면서 구슬을 움직인다.       파랑 구슬이 빠져나왔다면, continue로 넘어간다.       빨강 구슬이 빠져나왔다면, 답을 출력 해 준다.       만약 파랑구슬과 빨강구슬의 좌표(nbx, nby / nrx, nry)가 겹친다면, 움직일 때 세 주었던 count를 이용해 더 많이 움직인 구슬을 한 칸 뒤로 빼준다.       방문 처리를 해주고, 큐에 넣어준다.            후기       구슬이 한 칸씩만 움직이는 줄 알아서 삽질 좀 했다..      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-13460-%EA%B5%AC%EC%8A%AC-%ED%83%88%EC%B6%9C-2/",
        "teaser": null
      },{
        "title": "[백준 16234] 인구 이동",
        "excerpt":"[16234] 인구 이동   Algorithm: bfs Created: Mar 28, 2020 9:12 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/16234   문제   N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다. 각각의 땅에는 나라가 하나씩 존재하며, r행 c열에 있는 나라에는 A[r][c]명이 살고 있다. 인접한 나라 사이에는 국경선이 존재한다. 모든 나라는 1×1 크기이기 때문에, 모든 국경선은 정사각형 형태이다.   오늘부터 인구 이동이 시작되는 날이다.   인구 이동은 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다.      국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루동안 연다.   위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.   국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다.   연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다.   연합을 해체하고, 모든 국경선을 닫는다.   각 나라의 인구수가 주어졌을 때, 인구 이동이 몇 번 발생하는지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 N, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100)   둘째 줄부터 N개의 줄에 각 나라의 인구수가 주어진다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100)   인구 이동이 발생하는 횟수가 2,000번 보다 작거나 같은 입력만 주어진다.   출력   인구 이동이 몇 번 발생하는지 첫째 줄에 출력한다.   예제 입력 1   2 20 50 50 30 20 40   예제 출력 1   1   초기 상태는 아래와 같다.   https://upload.acmicpc.net/2993ef69-f57e-4d46-a9b3-eb3a05612dc7/-/preview/   L = 20, R = 50 이기 때문에, 모든 나라 사이의 국경선이 열린다. (열린 국경선은 점선으로 표시)   https://upload.acmicpc.net/3e73073e-b68e-478b-90fd-f158f44863b7/-/preview/   연합은 하나 존재하고, 연합의 인구는 (50 + 30 + 20 + 40) 이다. 연합의 크기가 4이기 때문에, 각 칸의 인구수는 140/4 = 35명이 되어야 한다.   https://upload.acmicpc.net/78951cb1-213d-416b-a64d-fb80697af36a/-/preview/   예제 입력 2   2 40 50 50 30 20 40   예제 출력 2   0   경계를 공유하는 나라의 인구 차이가 모두 L보다 작아서 인구 이동이 발생하지 않는다.   예제 입력 3   2 20 50 50 30 30 40   예제 출력 3   1   초기 상태는 아래와 같다.   https://upload.acmicpc.net/c70d5726-35d0-4af8-96f7-f01371db935f/-/preview/   L = 20, R = 50이기 때문에, 아래와 같이 국경선이 열린다.   https://upload.acmicpc.net/eff2e0d7-3b05-4b4d-88d6-4fc56fd946c6/-/preview/   인구 수는 합쳐져있는 연합의 인구수는 (50+30+30) / 3 = 36 (소수점 버림)이 되어야 한다.   https://upload.acmicpc.net/c54b09bd-7b13-4f41-9c80-271497c3239e/-/preview/   예제 입력 4   3 5 10 10 15 20 20 30 25 40 22 10   예제 출력 4   2   예제 입력 5   4 10 50 10 100 20 90 80 100 60 70 70 20 30 40 50 20 100 10        #include &lt;iostream&gt;     #include &lt;queue&gt;     #include &lt;algorithm&gt;     #include &lt;string.h&gt;     using namespace std;     int visit[101][101];     int dx[4] = {0, 0, -1, 1};     int dy[4] = {1, -1, 0, 0};     int N, L, R;     int land[101][101];     int sum, cnt, ans;     bool flag;     vector &lt;pair&lt;int, int&gt;&gt; unites;     void input(){         cin &gt;&gt; N &gt;&gt; L &gt;&gt; R;              for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;N; j++){                 cin &gt;&gt; land[i][j];             }         }     }          void bfs(int i,int j){         queue&lt;pair&lt;int, int&gt;&gt; q;         q.push({i,j});         unites.push_back({i,j});         visit[i][j] = true;         sum += land[i][j];         cnt++;              while(!q.empty()){             int x = q.front().first;             int y = q.front().second;             q.pop();                  for(int k=0; k&lt;4; k++){                 int nx = x + dx[k];                 int ny = y + dy[k];                      if(nx&lt;0 || nx&gt;=N || ny&lt;0 || ny&gt;=N) continue;                 if(visit[nx][ny]) continue;                      int sub = abs(land[x][y] - land[nx][ny]);                 if(sub&gt;=L &amp;&amp; sub&lt;=R){                     visit[nx][ny] = true;                     sum += land[nx][ny];                     cnt++;                     q.push({nx,ny});                     unites.push_back({nx,ny});                 }             }         }                   if(unites.size() &gt; 1) {             for(auto country : unites){                 land[country.first][country.second] = sum / cnt;             }             flag = true;         }              unites.clear();         sum = 0;         cnt = 0;     }     int main(){              ios_base::sync_with_stdio(false);         cin.tie(NULL); cout.tie(NULL);              input();              while(1){             memset(visit, 0, sizeof(visit));             flag = false;             for(int i=0; i&lt;N; i++){                 for(int j=0; j&lt;N; j++){                     if(visit[i][j]) continue;                     bfs(i, j);                 }             }                  if(flag) ans++;             else break;              }              cout &lt;&lt; ans &lt;&lt; endl;     }          문제 풀이       bfs로 푸는 문제이다.       주의 해야 할 점이,       인구 이동을 하고, 업데이트 한 값으로 다시 인구 이동을 해주어야 한다.       한 번 방문 한 나라는 다시 처리를 해 줄 필요가 없으므로 visit 배열을 생성한다.       새로운 인구 이동을 시작 할 때마다 초기화 해주면 된다. (memset)       bfs를 돌면서, 인접 나라를 탐색하며, 범위를 초과하거나 방문 했을 시에 continue로 넘어간다.       또, 인구를 계산하여 L과 R 사이의 값인지 확인하고, 사이의 값이라면 q와 unites 벡터에 넣어준다.       방문 처리를 하고, unites의 갯수를 더해준다.       bfs가 끝난 후에, 연합의 갯수가 2 이상이라면, land를 업데이트 해 주고, flag를 true로 바꿔준다. (연합이 있다는 뜻)       flag가 true라면 답을 더해주고, 아니라면 종료한다. (연합이 없으므로)            후기       오타때문에 2시간 날렸다      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-16234-%EC%9D%B8%EA%B5%AC-%EC%9D%B4%EB%8F%99/",
        "teaser": null
      },{
        "title": "[백준 3190] 뱀",
        "excerpt":"[3190] 뱀   Algorithm: 시뮬레이션 Created: Mar 29, 2020 8:19 PM DoubleChk: Yes Type: 백준 link: https://www.acmicpc.net/problem/3190   문제   ‘Dummy’ 라는 도스게임이 있다. 이 게임에는 뱀이 나와서 기어다니는데, 사과를 먹으면 뱀 길이가 늘어난다. 뱀이 이리저리 기어다니다가 벽 또는 자기자신의 몸과 부딪히면 게임이 끝난다.   게임은 NxN 정사각 보드위에서 진행되고, 몇몇 칸에는 사과가 놓여져 있다. 보드의 상하좌우 끝에 벽이 있다. 게임이 시작할때 뱀은 맨위 맨좌측에 위치하고 뱀의 길이는 1 이다. 뱀은 처음에 오른쪽을 향한다.   뱀은 매 초마다 이동을 하는데 다음과 같은 규칙을 따른다.      먼저 뱀은 몸길이를 늘려 머리를 다음칸에 위치시킨다.   만약 이동한 칸에 사과가 있다면, 그 칸에 있던 사과가 없어지고 꼬리는 움직이지 않는다.   만약 이동한 칸에 사과가 없다면, 몸길이를 줄여서 꼬리가 위치한 칸을 비워준다. 즉, 몸길이는 변하지 않는다.   사과의 위치와 뱀의 이동경로가 주어질 때 이 게임이 몇 초에 끝나는지 계산하라.   입력   첫째 줄에 보드의 크기 N이 주어진다. (2 ≤ N ≤ 100) 다음 줄에 사과의 개수 K가 주어진다. (0 ≤ K ≤ 100)   다음 K개의 줄에는 사과의 위치가 주어지는데, 첫 번째 정수는 행, 두 번째 정수는 열 위치를 의미한다. 사과의 위치는 모두 다르며, 맨 위 맨 좌측 (1행 1열) 에는 사과가 없다.   다음 줄에는 뱀의 방향 변환 횟수 L 이 주어진다. (1 ≤ L ≤ 100)   다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지는데, 정수 X와 문자 C로 이루어져 있으며. 게임 시작 시간으로부터 X초가 끝난 뒤에 왼쪽(C가 ‘L’) 또는 오른쪽(C가 ‘D’)로 90도 방향을 회전시킨다는 뜻이다. X는 10,000 이하의 양의 정수이며, 방향 전환 정보는 X가 증가하는 순으로 주어진다.   출력   첫째 줄에 게임이 몇 초에 끝나는지 출력한다.   예제 입력 1   6 3 3 4 2 5 5 3 3 3 D 15 L 17 D   예제 출력 1   9   예제 입력 2   10 4 1 2 1 3 1 4 1 5 4 8 D 10 D 11 D 13 L   예제 출력 2   21   예제 입력 3   10 5 1 5 1 3 1 2 1 6 1 7 4 8 D 10 D 11 D 13 L   예제 출력 3   13        #include &lt;iostream&gt;     #include &lt;queue&gt;     #include &lt;algorithm&gt;     using namespace std;     int N, K, L;     int board[101][101];     const int dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};     const int L_dir[] = {3, 2, 0, 1}, R_dir[] = {2, 3, 1, 0};     int t[101]; char c[101];     queue&lt;pair&lt;int, int&gt;&gt; q;          void input(){              cin &gt;&gt; N &gt;&gt; K;         for (int i=0; i&lt;K; i++) {             int u, v;             cin &gt;&gt; u &gt;&gt; v;             board[u-1][v-1] = 1;         }         cin &gt;&gt; L;         for (int i=0; i&lt;L; i++) {             cin &gt;&gt; t[i] &gt;&gt; c[i];         }     }               int main(){              ios_base::sync_with_stdio(false);         cin.tie(NULL); cout.tie(NULL);         input();              //0 빈칸 1 사과 2 뱀         board[0][0] = 2;         q.push({0, 0});         int x = 0, y = 0, z = 0;         int d = 0;         int cnt = 0;         while(1){             x += dx[d], y += dy[d];             cnt++;             if (x &lt; 0 || x &gt;= N || y &lt; 0 || y &gt;= N || board[x][y] == 2) {                 break;             }             if (board[x][y] == 0) {                 int nx = q.front().first, ny = q.front().second; q.pop();                 board[nx][ny] = 0;             }             board[x][y] = 2;             q.push({x, y});             if (cnt == t[z]) {                 if (c[z] == 'L') d = L_dir[d];                 else d = R_dir[d];                 z++;             }         }                   cout &lt;&lt; cnt &lt;&lt; endl;              return 0;               }          문제 풀이       q로 푸는 문제이다.       1초씩 update를 하며 검사를 해준다.              범위 초과 했는지 검사한다.       뱀인지 검사한다. (board[x][y] == 2)       빈 칸이라면 → 꼬리를 줄이고, 머리를 더한다.       사과라면 → 머리를 더한다.       방향이 전환되어야 하면 (cnt == t[z]) 방향을 전환 해 준다.                문제 후기       지금 발견했는데 사과 다 먹어도 끝나지 않는다.. 띠용      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-3190-%EB%B1%80/",
        "teaser": null
      },{
        "title": "[백준 12100] 2048 (Easy)",
        "excerpt":"[12100] 2048 (Easy)   Algorithm: dfs Type: 백준 link: https://www.acmicpc.net/problem/12100   문제   2048 게임은 4×4 크기의 보드에서 혼자 즐기는 재미있는 게임이다. 이 링크를 누르면 게임을 해볼 수 있다.   이 게임에서 한 번의 이동은 보드 위에 있는 전체 블록을 상하좌우 네 방향 중 하나로 이동시키는 것이다. 이때, 같은 값을 갖는 두 블록이 충돌하면 두 블록은 하나로 합쳐지게 된다. 한 번의 이동에서 이미 합쳐진 블록은 또 다른 블록과 다시 합쳐질 수 없다. (실제 게임에서는 이동을 한 번 할 때마다 블록이 추가되지만, 이 문제에서 블록이 추가되는 경우는 없다) … 생략      #include &lt;iostream&gt;     #include &lt;queue&gt;     #include &lt;algorithm&gt;     using namespace std;     int N;     int board[21][21];     int ans;     void input(){              cin &gt;&gt; N;         for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;N; j++){                 cin &gt;&gt; board[i][j];                 ans = max(ans, board[i][j]);             }         }          }     int findMax(){         int ret = 0;         for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;N; j++){                 ret = max(ret, board[i][j]);             }         }        return ret;     }     void solve(int dir){              queue &lt;int&gt; q;         if(dir == 0){ //상                  for(int i=0; i&lt;N; i++){                 for(int j=0; j&lt;N; j++){                     if(board[j][i]) {                         q.push(board[j][i]);                     }                     board[j][i] = 0;                      }                 int idx = 0;                 while(!q.empty()){                     int top = q.front(); q.pop();                     if(board[idx][i] == 0){                         board[idx][i] = top;                     }else if(board[idx][i] == top){                         board[idx++][i] = top*2;                     }else{                         board[++idx][i] = top;                     }                 }             }         }else if(dir == 1){ //하             for(int i = N-1; i &gt;= 0; i--) {                 for (int j = N-1; j &gt;= 0; j--) {                     if (board[j][i]) {                         q.push(board[j][i]);                         board[j][i] = 0;                     }                 }                      int idx = N-1;                 while(!q.empty()){                     int top = q.front(); q.pop();                          if(board[idx][i] == 0){                         board[idx][i] = top;                     }else if(board[idx][i] == top){                         board[idx--][i] = top*2;                     }else{                         board[--idx][i] = top;                     }                 }             }         }else if(dir == 2){ //좌             for(int i = 0; i &lt; N; i++) {                 for (int j = 0; j &lt; N; j++) {                     if (board[i][j]) {                         q.push(board[i][j]);                         board[i][j] = 0;                     }                 }                      int idx = 0;                 while(!q.empty()){                     int top = q.front(); q.pop();                          if(board[i][idx] == 0){                         board[i][idx] = top;                     }else if(board[i][idx] == top){                         board[i][idx++] = top*2;                     }else{                         board[i][++idx] = top;                     }                 }             }         }else{ //우             for(int i = 0; i &lt; N; i++) {                 for (int j = N-1; j &gt;= 0; j--) {                     if (board[i][j]) {                         q.push(board[i][j]);                         board[i][j] = 0;                     }                 }                      int idx = N-1;                 while(!q.empty()){                     int top = q.front(); q.pop();                     if(board[i][idx] == 0){                         board[i][idx] = top;                     }else if(board[i][idx] == top){                         board[i][idx--] = top*2;                     }else{                         board[i][--idx] = top;                     }                 }             }         }     //    print();          }          void dfs(int depth){              //기저 조건         if(depth == 5){             ans = max(ans, findMax());             return;         }              //board 저장         int temp_board[21][21];         for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;N; j++){                 temp_board[i][j] = board[i][j];             }         }              //모든 방향으로 탐색         for(int k=0; k&lt;4; k++){             solve(k);             dfs(depth+1);             //원래 상태로 돌려놓기                  for(int i=0; i&lt;N; i++){                 for(int j=0; j&lt;N; j++){                     board[i][j] = temp_board[i][j];                 }             }         }          }     int main(){              ios_base::sync_with_stdio(false);         cin.tie(NULL); cout.tie(NULL);              input();         dfs(0);         cout &lt;&lt; ans &lt;&lt; endl;              return 0;     }          문제 풀이       dfs로 풀었다.       깊이를 하나씩 더해 줘가면서 board를 업데이트 시켜준다.       depth가 5가 되면, 최대 값을 찾는다.       상하좌우를 모두 탐색하며 dfs를 도는데,       상의 예시를 들겠다.       한 줄씩 돌면서 큐에 넣어주고,       다 넣어준 다음 다시 그 줄에 뿌려주면 된다.       뿌려줄 때에는 0인 경우, 같은 경우, 다른 경우로 나누어서 뿌려준다.             ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-12100-2048-(Easy)/",
        "teaser": null
      },{
        "title": "[백준 14499] 주사위 굴리기",
        "excerpt":"[14499] 주사위 굴리기   Algorithm: 시뮬레이션 Created: Apr 03, 2020 3:41 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/14499   문제   크기가 N×M인 지도가 존재한다. 지도의 오른쪽은 동쪽, 위쪽은 북쪽이다. 이 지도의 위에 주사위가 하나 놓여져 있으며, 주사위의 전개도는 아래와 같다. 지도의 좌표는 (r, c)로 나타내며, r는 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로부터 떨어진 칸의 개수이다.     2 4 1 3   5   6   주사위는 지도 위에 윗 면이 1이고, 동쪽을 바라보는 방향이 3인 상태로 놓여져 있으며, 놓여져 있는 곳의 좌표는 (x, y) 이다. 가장 처음에 주사위에는 모든 면에 0이 적혀져 있다.   지도의 각 칸에는 정수가 하나씩 쓰여져 있다. 주사위를 굴렸을 때, 이동한 칸에 쓰여 있는 수가 0이면, 주사위의 바닥면에 쓰여 있는 수가 칸에 복사된다. 0이 아닌 경우에는 칸에 쓰여 있는 수가 주사위의 바닥면으로 복사되며, 칸에 쓰여 있는 수는 0이 된다.   주사위를 놓은 곳의 좌표와 이동시키는 명령이 주어졌을 때, 주사위가 이동했을 때 마다 상단에 쓰여 있는 값을 구하는 프로그램을 작성하시오.   주사위는 지도의 바깥으로 이동시킬 수 없다. 만약 바깥으로 이동시키려고 하는 경우에는 해당 명령을 무시해야 하며, 출력도 하면 안 된다.   입력   첫째 줄에 지도의 세로 크기 N, 가로 크기 M (1 ≤ N, M ≤ 20), 주사위를 놓은 곳의 좌표 x y(0 ≤ x ≤ N-1, 0 ≤ y ≤ M-1), 그리고 명령의 개수 K (1 ≤ K ≤ 1,000)가 주어진다.   둘째 줄부터 N개의 줄에 지도에 쓰여 있는 수가 북쪽부터 남쪽으로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 주사위를 놓은 칸에 쓰여 있는 수는 항상 0이다. 지도의 각 칸에 쓰여 있는 수는 10을 넘지 않는 자연수 또는 0이다.   마지막 줄에는 이동하는 명령이 순서대로 주어진다. 동쪽은 1, 서쪽은 2, 북쪽은 3, 남쪽은 4로 주어진다.        #include &lt;iostream&gt;     #include &lt;queue&gt;     #include &lt;algorithm&gt;     using namespace std;     int N, M, x, y, K;     int map_[21][21];     int order[1001];          //1동 2서 3북 4남     int dx[5] = {0, 0, 0, -1, 1};     int dy[5] = {0, 1, -1, 0, 0};          void input(){         cin &gt;&gt; N &gt;&gt; M &gt;&gt; x &gt;&gt; y &gt;&gt; K;         for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;M; j++){                 cin &gt;&gt; map_[i][j];             }         }              for(int i=0; i&lt;K; i++){             cin &gt;&gt; order[i];         }     }     void changeDice(int *dice, int dir){         int temp_dice[7];         copy(dice, dice+7, temp_dice);              if(dir == 1){ //동             dice[1] = temp_dice[4];             dice[3] = temp_dice[1];             dice[4] = temp_dice[6];             dice[6] = temp_dice[3];         }else if(dir == 2){ //서             dice[1] = temp_dice[3];             dice[3] = temp_dice[6];             dice[4] = temp_dice[1];             dice[6] = temp_dice[4];         }else if(dir == 3){ //북             dice[1] = temp_dice[5];             dice[2] = temp_dice[1];             dice[5] = temp_dice[6];             dice[6] = temp_dice[2];         }else{ //남             dice[1] = temp_dice[2];             dice[2] = temp_dice[6];             dice[5] = temp_dice[1];             dice[6] = temp_dice[5];         }     }     void solve(){         //1동 2서 3북 4남         //4 4 4 1 3 3 3 2         int dice[7] = {0, };              for(int i=0; i&lt;K; i++){             int dir = order[i];                  int nx = x + dx[dir];             int ny = y + dy[dir];                  //범위 초과             if(nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= M) continue;                  changeDice(dice, dir);                  //0이면 -&gt; 주사위 바닥을 칸으로             if(map_[nx][ny] == 0){                 map_[nx][ny] = dice[6];             }else{             //0이 아니면 -&gt; 칸을 주사위 바닥으로, 칸은 0                 dice[6] = map_[nx][ny];                 map_[nx][ny] = 0;             }                  x = nx; y = ny;             cout &lt;&lt; dice[1] &lt;&lt; endl;              }          }     int main(){              ios_base::sync_with_stdio(false);         cin.tie(NULL); cout.tie(NULL);              input();              solve();              return 0;     }          문제풀이       주사위를 굴려 가면서 조건에 맞게 주사위와 지도를 변경 해 주면 된다.                                 후기       와 한방에 맞췄다 진심 눈물난다 ㅜ..최초야..      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-14499-%EC%A3%BC%EC%82%AC%EC%9C%84-%EA%B5%B4%EB%A6%AC%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[TIL] 네이버 D2 PWA 세미나 요약",
        "excerpt":"네이버 D2 PWA 세미나 요약   PWA      Progressive Web App   Reliable            빠른 로딩       오프라인 작동       불안정한 네트워크에서도 작동           Fast            빠른 반응       어떤 input, Event에도 반응       재방문시에도 빠른 반응           Engaging            홈 화면에 추가 가능       full screen       ui 유지       push 알림           OFFLINE      서비스워커 사용         PWA의 기본적인 조건은?            https상에서 작동       태블릿, 모바일 상에서 반응형으로 작동       최소 시작 URL은 offline으로 작동       홈 화면에 추가 시 metadata 제공       3G상에서도 빠르게 작동       cross-browser       페이지 변환에 네트워크가 영향을 끼치지 않는듯이 작용       각각의 페이지가 URL을 가지고 있음           ⇒ LightHouse로 PWA인지 확인하고, 관리할 수 있음      그래서 어떻게 시작해?            처음부터 PWA시작 or 조금씩 변경 or single feature(오프라인)       App-shell (프론트)           서비스워커 life cycle            App-like 라이프사이클       System Events에만 받음                OS가 명령할 때만 작동                  Simple Example                       self.addEventListener('fetch', e=&gt;{ event.respondWith(fetch(e.request)); }                       self.addEventListener(‘fetch’,        \tevent =&gt;{ event.respondWith( caches.open(‘my-cache’).then(cache =&gt; {       \t\treturn cache.match(event.request).then(cacheResponse =&gt; {       \t\t\tconst fetchPromise = fetch(event.request).then(networkResponse =&gt;{       \t\t\t\tcache.put(event.request, networkResponse.clone());       \t\t\t\treturn networkResponse;       \t\treturn cacheResponse || fetchPromise;} })}          ### WorkBox              사용하면 좀 더 편리하다       version 관리       pre-caching                               cache-first                    설치할 때 캐시를 모두 저장                                Fast-Navigation                                 자주 변경되는 건 network와 직접 통신 (blacklist)           아닌건 cache에 저장해서 빠른 접근           로직을 서비스워커가 담당한다           flexible integration                                 ## 실사용 서비스들   ### Wired                     cache size는 설계를 잘 해야됨       offline article listing                         기타 우버, 에어비앤비, 틴더 등등                 PWA in Production   퍼포먼스 조건 설정      최초 뷰를 우선적으로 처리해야 함            3초 이내 로딩           Simple      이미지, css, 폰트, lazy loading   Not Simple      3rd 파티 라이브러리, JS 최적화   More Not Simple      퍼포먼스 유지   PWA Indexability      polyfills, metadata, ssr, be progressive   서비스워커 kill switch      typlically ‘kill header’ 사용   언제 서비스워커를 설치 하는지 고려   Offline Analytics      workbox 사용   Service Worker Scope      sub-directory까지   캐시 관리는 설계자가   CORS Caching &amp; Opaque Response      workbox는 기본적으로 캐싱 X   PWA를 기존의 웹사이트에 적용할때 리팩토링 VS NEW      New is the best   Simple site 이상은 완전한 PWA가 힘들다   ~~프레임워크에서 PWA 어떻게 사용?      hnpwa.com 참고   CDN, Broswer, 서비스 워커 내의 캐시 상호작용 고려   buile process가 복잡하지만, worth it.   Offline UX      사용자 입장에서 어떤 것이 좋은지 고려하기   Desktop PWA도 신경쓰기   웹 뷰 안에 PWA?      Yes, 캐시 부분만  ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-%EB%84%A4%EC%9D%B4%EB%B2%84-D2-PWA-%EC%84%B8%EB%AF%B8%EB%82%98-%EC%9A%94%EC%95%BD/",
        "teaser": null
      },{
        "title": "[백준 14503] 로봇 청소기",
        "excerpt":"[14503] 로봇 청소기   Algorithm: 시뮬레이션 Created: Apr 04, 2020 4:52 AM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/14503   문제   로봇 청소기가 주어졌을 때, 청소하는 영역의 개수를 구하는 프로그램을 작성하시오.   로봇 청소기가 있는 장소는 N×M 크기의 직사각형으로 나타낼 수 있으며, 1×1크기의 정사각형 칸으로 나누어져 있다. 각각의 칸은 벽 또는 빈 칸이다. 청소기는 바라보는 방향이 있으며, 이 방향은 동, 서, 남, 북중 하나이다. 지도의 각 칸은 (r, c)로 나타낼 수 있고, r은 북쪽으로부터 떨어진 칸의 개수, c는 서쪽으로 부터 떨어진 칸의 개수이다.   로봇 청소기는 다음과 같이 작동한다.      현재 위치를 청소한다.   현재 위치에서 현재 방향을 기준으로 왼쪽방향부터 차례대로 탐색을 진행한다.            왼쪽 방향에 아직 청소하지 않은 공간이 존재한다면, 그 방향으로 회전한 다음 한 칸을 전진하고 1번부터 진행한다.       왼쪽 방향에 청소할 공간이 없다면, 그 방향으로 회전하고 2번으로 돌아간다.       네 방향 모두 청소가 이미 되어있거나 벽인 경우에는, 바라보는 방향을 유지한 채로 한 칸 후진을 하고 2번으로 돌아간다.       네 방향 모두 청소가 이미 되어있거나 벽이면서, 뒤쪽 방향이 벽이라 후진도 할 수 없는 경우에는 작동을 멈춘다.           로봇 청소기는 이미 청소되어있는 칸을 또 청소하지 않으며, 벽을 통과할 수 없다.   입력   첫째 줄에 세로 크기 N과 가로 크기 M이 주어진다. (3 ≤ N, M ≤ 50)   둘째 줄에 로봇 청소기가 있는 칸의 좌표 (r, c)와 바라보는 방향 d가 주어진다. d가 0인 경우에는 북쪽을, 1인 경우에는 동쪽을, 2인 경우에는 남쪽을, 3인 경우에는 서쪽을 바라보고 있는 것이다.   셋째 줄부터 N개의 줄에 장소의 상태가 북쪽부터 남쪽 순서대로, 각 줄은 서쪽부터 동쪽 순서대로 주어진다. 빈 칸은 0, 벽은 1로 주어진다. 지도의 첫 행, 마지막 행, 첫 열, 마지막 열에 있는 모든 칸은 벽이다.   로봇 청소기가 있는 칸의 상태는 항상 빈 칸이다.   출력   로봇 청소기가 청소하는 칸의 개수를 출력한다.        #include &lt;iostream&gt;     #include &lt;queue&gt;     #include &lt;algorithm&gt;     using namespace std;     int N, M;     int r, c, d, ans;     int room[51][51];     //0북 1동 2남 3서     int dx[] = {-1, 0, 1, 0};     int dy[] = {0, 1, 0, -1};          void input(){         cin &gt;&gt; N &gt;&gt; M;         cin &gt;&gt; r &gt;&gt; c &gt;&gt; d;         for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;M; j++){                 cin &gt;&gt; room[i][j];             }         }     }     int changeDir(int d){         if(d == 0) return 3;         else if(d == 1) return 0;         else if(d == 2) return 1;         else return 2;     }     void solve(){             while(1){                 bool cleaned = false;                 for(int i=0; i&lt;4; i++){                int nd = changeDir(d);                int nx = r + dx[nd];                int ny = c + dy[nd];                d = nd;                     if(room[nx][ny] == 0){                    room[nx][ny] = 2;                    ans+=1;                    r = nx; c = ny;                    cleaned = true;                    break;                }            }                 if(!cleaned){                int back_r = r - dx[d];                int back_c = c - dy[d];                if(room[back_r][back_c] == 1){                    return;                }                else {                    r = back_r; c = back_c;                }            }        }          }     int main(){              ios_base::sync_with_stdio(false);         cin.tie(NULL); cout.tie(NULL);              input();         room[r][c] = 2;              solve();              cout &lt;&lt; ans+1 &lt;&lt; endl;              return 0;     }          문제 풀이       간단한 시뮬레이션 문제.       동서남북 처리하기가 머리아팠다.              계속해서 왼쪽으로 돌기 때문에 북→서→남→동→북.. 이 순서대로 배열을 만들어주면 된다.       flag를 두어 동, 서, 남, 북 모두를 탐색 해도 길이 없을 경우를 표현해준다.       후진을 해도 길이 없으면 함수를 끝내준다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-14503-%EB%A1%9C%EB%B4%87-%EC%B2%AD%EC%86%8C%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[백준 14889] 스타트와 링크",
        "excerpt":"[14889] 스타트와 링크   Algorithm: 백트래킹 Created: Apr 04, 2020 8:45 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/14889   문제   오늘은 스타트링크에 다니는 사람들이 모여서 축구를 해보려고 한다. 축구는 평일 오후에 하고 의무 참석도 아니다. 축구를 하기 위해 모인 사람은 총 N명이고 신기하게도 N은 짝수이다. 이제 N/2명으로 이루어진 스타트 팀과 링크 팀으로 사람들을 나눠야 한다.   BOJ를 운영하는 회사 답게 사람에게 번호를 1부터 N까지로 배정했고, 아래와 같은 능력치를 조사했다. 능력치 Sij는 i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치이다. 팀의 능력치는 팀에 속한 모든 쌍의 능력치 Sij의 합이다. Sij는 Sji와 다를 수도 있으며, i번 사람과 j번 사람이 같은 팀에 속했을 때, 팀에 더해지는 능력치는 Sij와 Sji이다.   N=4이고, S가 아래와 같은 경우를 살펴보자.   Untitled   예를 들어, 1, 2번이 스타트 팀, 3, 4번이 링크 팀에 속한 경우에 두 팀의 능력치는 아래와 같다.           스타트 팀: S + S = 1 + 4 = 5       12       21            링크 팀: S + S = 2 + 5 = 7       34       43       1, 3번이 스타트 팀, 2, 4번이 링크 팀에 속하면, 두 팀의 능력치는 아래와 같다.           스타트 팀: S + S = 2 + 7 = 9       13       31            링크 팀: S + S = 6 + 4 = 10       24       42       축구를 재미있게 하기 위해서 스타트 팀의 능력치와 링크 팀의 능력치의 차이를 최소로 하려고 한다. 위의 예제와 같은 경우에는 1, 4번이 스타트 팀, 2, 3번 팀이 링크 팀에 속하면 스타트 팀의 능력치는 6, 링크 팀의 능력치는 6이 되어서 차이가 0이 되고 이 값이 최소이다.   입력   첫째 줄에 N(4 ≤ N ≤ 20, N은 짝수)이 주어진다. 둘째 줄부터 N개의 줄에 S가 주어진다. 각 줄은 N개의 수로 이루어져 있고, i번 줄의 j번째 수는 Sij 이다. Sii는 항상 0이고, 나머지 Sij는 1보다 크거나 같고, 100보다 작거나 같은 정수이다.   출력   첫째 줄에 스타트 팀과 링크 팀의 능력치의 차이의 최솟값을 출력한다.        #include &lt;iostream&gt;     #include &lt;queue&gt;     #include &lt;algorithm&gt;     using namespace std;     int N;     int board[21][21];     int visited[21];     int ans = 987654321;     void input(){         cin &gt;&gt; N;         for(int i=1; i&lt;=N; i++){             for(int j=1; j&lt;=N; j++){                 cin &gt;&gt; board[i][j];             }         }     }          void solve(vector &lt;int&gt; &amp;candidates, int idx){              if(candidates.size() == N/2){             int start = 0;             int link = 0;                  for(int i=1; i&lt;=N; i++){                 for(int j=1; j&lt;=N; j++){                     if(visited[i] &amp;&amp; visited[j]){                         start += board[i][j];                     }else if(!visited[i] &amp;&amp; !visited[j]){                         link += board[i][j];                     }                 }             }                  int differnce = abs(link - start);             ans = min(ans, differnce);                  return;         }              for(int i=idx; i&lt;= N; i++){             visited[i] = 1;             candidates.push_back(i);             solve(candidates, i+1);             candidates.pop_back();             visited[i] = 0;         }          }     int main(){              ios_base::sync_with_stdio(false);         cin.tie(NULL); cout.tie(NULL);         input();         vector &lt;int&gt; start;              solve(start, 1);              cout &lt;&lt; ans &lt;&lt; endl;              return 0;     }          문제 풀이       결국 n/2개의 조합을 만드는 것이기 때문에 dfs로 풀었다.       벡터에 팀들의 조합을 넣어가면서, 사이즈가 2면 능력치를 계산해주었다.       가장 적은 차이의 능력치를 업데이트 해 준다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-14889-%EC%8A%A4%ED%83%80%ED%8A%B8%EC%99%80-%EB%A7%81%ED%81%AC/",
        "teaser": null
      },{
        "title": "[프로그래머스] 도둑질",
        "excerpt":"도둑질   Algorithm: DP Created: Apr 06, 2020 7:47 PM DoubleChk: No Type: 프로그래머스 level: 4 link: https://programmers.co.kr/learn/courses/30/lessons/42897   문제 설명   도둑이 어느 마을을 털 계획을 하고 있습니다. 이 마을의 모든 집들은 아래 그림과 같이 동그랗게 배치되어 있습니다.      각 집들은 서로 인접한 집들과 방범장치가 연결되어 있기 때문에 인접한 두 집을 털면 경보가 울립니다.   각 집에 있는 돈이 담긴 배열 money가 주어질 때, 도둑이 훔칠 수 있는 돈의 최댓값을 return 하도록 solution 함수를 작성하세요.   제한사항      이 마을에 있는 집은 3개 이상 1,000,000개 이하입니다.   money 배열의 각 원소는 0 이상 1,000 이하인 정수입니다.        #include &lt;string&gt;     #include &lt;vector&gt;          using namespace std;     int dp[1000001];     int dp2[1000001];     int solution(vector&lt;int&gt; money) {         int answer = 0;         int ret1 = 0;         int ret2 = 0;         int n = money.size();              //첫 번째 집 털었을 때         dp[0] = money[0];         dp[1] = dp[0];                  //첫 번째 집 안 털었을 때         dp2[0] = 0;         dp2[1] = money[1];              for(int i=2; i&lt;n-1; i++){             dp[i] = max(dp[i-1], dp[i-2] + money[i]);             ret1 = max(ret1, dp[i]);         }                  for(int i=2; i&lt;n; i++){             dp2[i] = max(dp2[i-1], dp2[i-2] + money[i]);             ret2 = max(ret2, dp2[i]);         }              return max(ret1, ret2);     }          문제 풀이       집이 동그랗게 되어 있기 때문에 마지막 집을 털게 되면 첫 번째 집을 털면 안된다.       따라서 첫 번째 집을 털 경우랑 첫 번째 집을 털지 않을 경우를 구분 해 주어야 한다.       반복문으로 현재 집을 털 경우, 안 털 경우를 계산해서 업데이트 해 준다.       반복문이 끝나면 두 경우 중 큰 값을 return 한다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8F%84%EB%91%91%EC%A7%88/",
        "teaser": null
      },{
        "title": "[프로그래머스] 기능개발",
        "excerpt":"기능개발   Created: Apr 07, 2020 10:49 PM DoubleChk: No Type: 프로그래머스 link: https://programmers.co.kr/learn/courses/30/lessons/42586   문제 설명   프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다.   또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다.   먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요.   제한 사항      작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다.   작업 진도는 100 미만의 자연수입니다.   작업 속도는 100 이하의 자연수입니다.   배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.        #include &lt;string&gt;     #include &lt;vector&gt;          using namespace std;          vector&lt;int&gt; solution(vector&lt;int&gt; progresses, vector&lt;int&gt; speeds) {         vector&lt;int&gt; answer;         int left = 0;         int n = progresses.size();              while(1){             if(left &gt;= n) break;                  for(int i=left; i&lt;n; i++){                 progresses[i] += speeds[i];             }                  int cnt = 0;             while(left &lt; n &amp;&amp; progresses[left] &gt;= 100){                 cnt++;                 left++;             }                  if(cnt &gt; 0) answer.push_back(cnt);              }              return answer;     }          문제 풀이       예전에 풀었던 건데, 스킬 체크로 다시 풀었다.       left라는 인덱스를 하나 두어서, 반복문을 진행한다.       만약 left가 n보다 크면, 함수를 종료 해 준다.       left부터 n까지 돌면서 진행 상황을 업데이트 해 준다.       만약 progress[left]가 100이 됐다면, 답을 세어 주고, left를 옮겨 준다.       답을 벡터에 넣어 준다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B8%B0%EB%8A%A5%EA%B0%9C%EB%B0%9C/",
        "teaser": null
      },{
        "title": "[백준 16236] 아기 상어",
        "excerpt":"[ 백준 16236 ] 아기 상어   Algorithm: bfs Created: Apr 08, 2020 8:41 PM DoubleChk: Yes Type: 백준 link: https://www.acmicpc.net/problem/16236   문제   N×N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 물고기가 최대 1마리 존재한다.   아기 상어와 물고기는 모두 크기를 가지고 있고, 이 크기는 자연수이다. 가장 처음에 아기 상어의 크기는 2이고, 아기 상어는 1초에 상하좌우로 인접한 한 칸씩 이동한다.   아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없고, 나머지 칸은 모두 지나갈 수 있다. 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 따라서, 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다.   아기 상어가 어디로 이동할지 결정하는 방법은 아래와 같다.      더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다.   먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다.   먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.            거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다.       거리가 가까운 물고기가 많다면, 가장 위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.           아기 상어의 이동은 1초 걸리고, 물고기를 먹는데 걸리는 시간은 없다고 가정한다. 즉, 아기 상어가 먹을 수 있는 물고기가 있는 칸으로 이동했다면, 이동과 동시에 물고기를 먹는다. 물고기를 먹으면, 그 칸은 빈 칸이 된다.   아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다. 예를 들어, 크기가 2인 아기 상어는 물고기를 2마리 먹으면 크기가 3이 된다.   공간의 상태가 주어졌을 때, 아기 상어가 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는지 구하는 프로그램을 작성하시오.   입력   첫째 줄에 공간의 크기 N(2 ≤ N ≤ 20)이 주어진다.   둘째 줄부터 N개의 줄에 공간의 상태가 주어진다. 공간의 상태는 0, 1, 2, 3, 4, 5, 6, 9로 이루어져 있고, 아래와 같은 의미를 가진다.      0: 빈 칸   1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기   9: 아기 상어의 위치   아기 상어는 공간에 한 마리 있다.   출력   첫째 줄에 아기 상어가 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수 있는 시간을 출력한다.        #include &lt;iostream&gt;     #include &lt;queue&gt;     #include &lt;stack&gt;     #include &lt;algorithm&gt;     #include &lt;string.h&gt;     #include &lt;math.h&gt;     using namespace std;     int N;     int ans;     int water[21][21];     int visit[21][21];     int dx[4] = {0, 0, -1, 1};     int dy[4] = {-1, 1, 0, 0};     typedef struct fish{         int x;         int y;         int size; //크기         int move; //움직인 횟수 (거리)         int eat; // 먹은 갯수     }fish;     bool cmp (fish &amp;n1, fish &amp;n2){         if(n1.move == n2.move){ //거리가 같다면             if(n1.x == n2.x){                 return n1.y &lt; n2.y;             }else{                 return n1.x &lt; n2.x;             }         }else{             return n1.move &lt; n2.move; //거리 작은 순대로         }     }     fish shark;     vector &lt;fish&gt; eatable;     void input(){         cin &gt;&gt; N;         for(int i=0; i&lt;N; i++){             for(int j=0; j&lt;N; j++){                 cin &gt;&gt; water[i][j];                 if(water[i][j] == 9){                     shark.x = i;                     shark.y = j;                     shark.size = 2;                     water[i][j] = 0;                 }             }         }     }     void solve(){              while(1){             memset(visit, 0, sizeof(visit));             eatable.clear();             shark.move = 0;                  queue &lt;fish&gt; q;             q.push(shark);             visit[shark.x][shark.y] = 1;                  //bfs -&gt; 먹을 수 있는 물고기들을 찾는다.             while(!q.empty()){                      fish top = q.front();                 q.pop();                      for(int i=0; i&lt;4; i++){                     int nx = top.x + dx[i];                     int ny = top.y + dy[i];                          if(nx &lt; 0|| ny &lt; 0 || nx &gt;= N || ny &gt;= N || visit[nx][ny] || water[nx][ny] &gt; shark.size) continue;                     q.push({nx, ny, top.size, top.move + 1});                     visit[nx][ny] = 1;                          if(shark.size &gt; water[nx][ny] &amp;&amp; water[nx][ny] != 0){                         eatable.push_back(fish{nx,ny,water[nx][ny],top.move+1});                     }                 }                  }                  if(eatable.empty()){                 cout &lt;&lt; ans &lt;&lt; endl;                 break;             }else{                 sort(eatable.begin(), eatable.end(), cmp);                      shark.x = eatable[0].x;                 shark.y = eatable[0].y;                      water[eatable[0].x][eatable[0].y] = 0;                 shark.eat++;                      if(shark.eat == shark.size){                     shark.eat = 0;                     shark.size++;                 }                      ans += eatable[0].move;                  }         }          }     int main() {              ios_base::sync_with_stdio(false);         cin.tie(NULL);         cout.tie(NULL);              input();              solve();                   return 0;     }   ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-16236-%EC%95%84%EA%B8%B0-%EC%83%81%EC%96%B4/",
        "teaser": null
      },{
        "title": "[프로그래머스] 단어 변환",
        "excerpt":"단어 변환   Algorithm: dfs Created: Apr 08, 2020 1:21 AM DoubleChk: No Type: 프로그래머스 link: https://programmers.co.kr/learn/courses/30/lessons/43163   문제 설명   두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.   `1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.     words에 있는 단어로만 변환할 수 있습니다.`   예를 들어 begin이 hit, target가 cog, words가 [hot,dot,dog,lot,log,cog]라면 hit -&gt; hot -&gt; dot -&gt; dog -&gt; cog와 같이 4단계를 거쳐 변환할 수 있습니다.   두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.   제한사항      각 단어는 알파벳 소문자로만 이루어져 있습니다.   각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다.   words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다.   begin과 target은 같지 않습니다.   변환할 수 없는 경우에는 0를 return 합니다.   입출력 예   Untitled   입출력 예 설명   예제 #1문제에 나온 예와 같습니다.   예제 #2target인 cog는 words 안에 없기 때문에 변환할 수 없습니다.        #include &lt;string&gt;     #include &lt;vector&gt;     #include &lt;algorithm&gt;          using namespace std;     int answer = 0;     int visit[51];          void dfs(string now, string target, vector&lt;string&gt;&amp; words, int cur){         if(now == target){             answer = cur;             return;         }                  for(int i=0; i&lt;words.size(); i++){                          if(visit[i]) continue;                          //1개 차이만             int diff = 0;             for(int j=0; j&lt;now.length(); j++){                 if(words[i][j] != now[j]){                     diff++;                 }             }             if(diff == 1){                 visit[i] = 1;                 dfs(words[i], target, words, cur+1);                 visit[i] = 0;             }         }              }          int solution(string begin, string target, vector&lt;string&gt; words) {         if(find(words.begin(), words.end(), target) == words.end()) return 0;              dfs(begin, target, words, 0);                  return answer;     }          문제 풀이       dfs 문제이다.       기저 조건은 target과 현재(now)가 같을 때이다.       차이가 1개인 단어들만 탐색 하면 되기 때문에, words 벡터를 돌면서 차이를 세 준다.       1개만 다르다면 dfs를 그 단어로 돌면 된다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8B%A8%EC%96%B4-%EB%B3%80%ED%99%98/",
        "teaser": null
      },{
        "title": "[프로그래머스] 큰 수 만들기",
        "excerpt":"큰 수 만들기   Algorithm: 그리디 Created: Apr 10, 2020 7:04 PM DoubleChk: No Type: 프로그래머스 link: https://programmers.co.kr/learn/courses/30/lessons/42883   문제 설명   어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.   예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.   문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.   제한 조건      number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.   k는 1 이상 number의 자릿수 미만인 자연수입니다.        #include &lt;string&gt;     #include &lt;vector&gt;          using namespace std;          string solution(string number, int k) {         string answer = \"\";         int n = number.size() - k;                  int cur = 0;         for(int i=0; i&lt;n; i++){             char max_num = number[cur];             int max_idx = cur;                          for(int j = cur ; j&lt;= k+i; j++){                 if(max_num &lt; number[j]){                     max_num = number[j];                     max_idx = j;                 }             }                          cur = max_idx + 1;             answer += max_num;                      }         return answer;     }          문제 풀이       dfs로 풀면 시간 초과가 난다.       반복문을 n-k번만 돌리면 된다는 것은 다들 알 것이다.       총 (n-k)개의 숫자 길이가 나와야 하므로       각각의 자릿값들은 이전 인덱스 ~ (전체길이 - 나머지 남은 자릿수 길이)에서 찾으면 된다.       예를들어,       number = “1231234”       k = “3”       일때,       number.length() - k개가 숫자의 길이다. 즉 7-3으로 4개의 숫자를 더해야 한다.       그래서 outer loop가 0~n-k번 돌게 된다. i는 자릿수를 의미한다.       첫 번째 큰 값은, 0부터 number.length() - 3에서 찾아야 한다.       왜냐하면!!       나머지 자릿수들을 찾아야 하기 때문이다. 남은 자릿수가 3개니까 최소한 3개는 남겨 놔야한다.       inner loop는 이 작업을 한다.       가장 큰 값과 가장 큰 값의 인덱스를 저장하고,       innerloop가 끝나면 update를 한다.       가장 큰 값의 다음 인덱스부터 탐색을 진행하면 된다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%81%B0-%EC%88%98-%EB%A7%8C%EB%93%A4%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스] 구명보트",
        "excerpt":"구명보트   Algorithm: 그리디 Created: Apr 12, 2020 6:59 PM DoubleChk: No Type: 프로그래머스 level: 2 link: https://programmers.co.kr/learn/courses/30/lessons/42885#   문제 설명   무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.   예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.   구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.   사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.   제한사항      무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.   각 사람의 몸무게는 40kg 이상 240kg 이하입니다.   구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.   구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.     #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std;   int solution(vector&lt;int&gt; people, int limit) {     int answer = 0;     sort(people.begin(), people.end());     int left = 0;     int right = people.size() - 1;      while(left &lt;= right){          int remain = limit - people[right];          if(remain &lt; people[left]){             //태울 수 없음             right--;             answer++;         }else{             //태울 수 있음             left++;             right--;             answer++;         }     }      return answer; }           문제 풀이       투 포인터로 풀었다.       작은 순서부터 큰 순서까지 sorting 해준다.       left, right 인덱스 해주고,       limit에서 제일 큰 값을 빼준다.       left를 태울 수 있으면 태운 뒤에, left를 한칸, right를 한칸 옮겨주고, 답+1       left를 태울 수 없으면 right만 태우면 되므로 right 한 칸 옮겨주고 답+1       주의할 점은 최대 2명만 탈 수 있다!!!      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B5%AC%EB%AA%85%EB%B3%B4%ED%8A%B8/",
        "teaser": null
      },{
        "title": "[프로그래머스] 저울",
        "excerpt":"저울   Algorithm: 그리디 Created: Apr 13, 2020 5:18 PM DoubleChk: No Type: 프로그래머스 level: 3 link: https://programmers.co.kr/learn/courses/30/lessons/42886   문제 설명   하나의 양팔 저울을 이용하여 물건의 무게를 측정하려고 합니다. 이 저울의 양팔의 끝에는 물건이나 추를 올려놓는 접시가 달려 있고, 양팔의 길이는 같습니다. 또한, 저울의 한쪽에는 저울추들만 놓을 수 있고, 다른 쪽에는 무게를 측정하려는 물건만 올려놓을 수 있습니다.      저울추가 담긴 배열 weight가 매개변수로 주어질 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값을 return 하도록 solution 함수를 작성해주세요.   예를 들어, 무게가 각각 [3, 1, 6, 2, 7, 30, 1]인 7개의 저울추를 주어졌을 때, 이 추들로 측정할 수 없는 양의 정수 무게 중 최솟값은 21입니다.   제한 사항      저울추의 개수는 1개 이상 10,000개 이하입니다.   각 추의 무게는 1 이상 1,000,000 이하입니다.   입출력 예   Untitled   입출력 예 설명   문제에 나온 예와 같습니다.        #include &lt;string&gt;     #include &lt;algorithm&gt;     #include &lt;vector&gt;          using namespace std;          int solution(vector&lt;int&gt; weight) {         int answer = 0;         sort(weight.begin(), weight.end());         answer = weight[0];                  for(int i=1; i&lt;weight.size(); i++){             if(answer+1 &lt; weight[i]){                 return answer+1;             }else{                 answer += weight[i];             }         }                  return answer+1;     }          문제 풀이       오름차순으로 정렬을 한다.       answer를 제일 작은 추로 update 해 준다.       만약, 현재의 무게 + 1 보다 다음 크기의 추가 작으면!! ⇒ 불가능, return       아니라면, answer에 추를 더해준다.       answer의 의미는 지금까지의 추로 만들 수 있는 무게이다.       dfs나 조합으로 풀면 시간 초과가 난다..            문제 후기       비슷한 문제가 나왔을 때 잊어버리지 않도록 하자!!!!!      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A0%80%EC%9A%B8/",
        "teaser": null
      },{
        "title": "[프로그래머스] 더 맵게",
        "excerpt":"더 맵게   Algorithm: 힙 Created: Apr 15, 2020 1:10 AM DoubleChk: No Type: 프로그래머스 level: 2 link: https://programmers.co.kr/learn/courses/30/lessons/42626   문제 설명   매운 것을 좋아하는 Leo는 모든 음식의 스코빌 지수를 K 이상으로 만들고 싶습니다. 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 Leo는 스코빌 지수가 가장 낮은 두 개의 음식을 아래와 같이 특별한 방법으로 섞어 새로운 음식을 만듭니다.   섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)   Leo는 모든 음식의 스코빌 지수가 K 이상이 될 때까지 반복하여 섞습니다.Leo가 가진 음식의 스코빌 지수를 담은 배열 scoville과 원하는 스코빌 지수 K가 주어질 때, 모든 음식의 스코빌 지수를 K 이상으로 만들기 위해 섞어야 하는 최소 횟수를 return 하도록 solution 함수를 작성해주세요.   제한 사항      scoville의 길이는 2 이상 1,000,000 이하입니다.   K는 0 이상 1,000,000,000 이하입니다.   scoville의 원소는 각각 0 이상 1,000,000 이하입니다.   모든 음식의 스코빌 지수를 K 이상으로 만들 수 없는 경우에는 -1을 return 합니다.   입출력 예   Untitled   입출력 예 설명      스코빌 지수가 1인 음식과 2인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.새로운 음식의 스코빌 지수 = 1 + (2 * 2) = 5가진 음식의 스코빌 지수 = [5, 3, 9, 10, 12]   스코빌 지수가 3인 음식과 5인 음식을 섞으면 음식의 스코빌 지수가 아래와 같이 됩니다.새로운 음식의 스코빌 지수 = 3 + (5 * 2) = 13가진 음식의 스코빌 지수 = [13, 9, 10, 12]   모든 음식의 스코빌 지수가 7 이상이 되었고 이때 섞은 횟수는 2회입니다.        #include &lt;string&gt;     #include &lt;vector&gt;     #include &lt;queue&gt;     using namespace std;     priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; pq;     int solution(vector&lt;int&gt; scoville, int K) {         int answer = 0;                  for(auto plate : scoville){             pq.push(plate);         }                  bool flag = false;         while(1){             if(pq.top() &gt;= K){                 flag = true;                 break;             }             if(pq.size() &lt; 2){                 break;             }             int first = pq.top();             pq.pop();                          int second = pq.top();             pq.pop();                          int new_scoville = first + (second * 2);                          pq.push(new_scoville);             answer++;         }                  if(!flag) return -1;                  return answer;     }          문제 풀이       우선순위 큐 라이브러리를 사용해서 풀었다.       min heap으로 선언을 해주고, 모든 음식을 넣어준다.       정상 종료 됐는지 확인하기 위해 flag를 선언 해 준다.       while문을 돌면서 두 개의 음식을 꺼내고 섞은 후 다시 넣는다.       섞을 때 마다 answer를 하나씩 올려준다.       만약, 가장 작은 값(min heap의 top)이 K이상이라면, 모든 음식이 K 이상이기 때문에 flag를 true(정상종료)로 바꿔주고 종료 해준다.       만약, 우선순위 큐의 크기가 2 이하라면, 더이상 섞을 수 없으므로 false인 채로 종료한다 (비정상 종료)       종료 후 비정상이면 -1, 정상이면 answer를 출력해준다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8D%94-%EB%A7%B5%EA%B2%8C/",
        "teaser": null
      },{
        "title": "[프로그래머스] 라면공장",
        "excerpt":"라면공장   Created: Apr 16, 2020 1:12 AM DoubleChk: No   문제 설명   라면 공장에서는 하루에 밀가루를 1톤씩 사용합니다. 원래 밀가루를 공급받던 공장의 고장으로 앞으로 k일 이후에야 밀가루를 공급받을 수 있기 때문에 해외 공장에서 밀가루를 수입해야 합니다.   해외 공장에서는 향후 밀가루를 공급할 수 있는 날짜와 수량을 알려주었고, 라면 공장에서는 운송비를 줄이기 위해 최소한의 횟수로 밀가루를 공급받고 싶습니다.   현재 공장에 남아있는 밀가루 수량 stock, 밀가루 공급 일정(dates)과 해당 시점에 공급 가능한 밀가루 수량(supplies), 원래 공장으로부터 공급받을 수 있는 시점 k가 주어질 때, 밀가루가 떨어지지 않고 공장을 운영하기 위해서 최소한 몇 번 해외 공장으로부터 밀가루를 공급받아야 하는지를 return 하도록 solution 함수를 완성하세요.   dates[i]에는 i번째 공급 가능일이 들어있으며, supplies[i]에는 dates[i] 날짜에 공급 가능한 밀가루 수량이 들어 있습니다.   제한사항      stock에 있는 밀가루는 오늘(0일 이후)부터 사용됩니다.   stock과 k는 2 이상 100,000 이하입니다.   dates의 각 원소는 1 이상 k 이하입니다.   supplies의 각 원소는 1 이상 1,000 이하입니다.   dates와 supplies의 길이는 1 이상 20,000 이하입니다.   k일 째에는 밀가루가 충분히 공급되기 때문에 k-1일에 사용할 수량까지만 확보하면 됩니다.   dates에 들어있는 날짜는 오름차순 정렬되어 있습니다.   dates에 들어있는 날짜에 공급되는 밀가루는 작업 시작 전 새벽에 공급되는 것을 기준으로 합니다. 예를 들어 9일째에 밀가루가 바닥나더라도, 10일째에 공급받으면 10일째에는 공장을 운영할 수 있습니다.   밀가루가 바닥나는 경우는 주어지지 않습니다.   입출력 예   Untitled   입출력 예 설명      현재 밀가루가 4톤 남아 있기 때문에 오늘과 1일 후~3일 후까지 사용하고 나면 모든 밀가루를 다 사용합니다. 따라서 4일 후에는 반드시 밀가루를 공급받아야 합니다.   4일째 공급받고 나면 15일 이후 아침에는 9톤의 밀가루가 남아있게 되고, 이때 10톤을 더 공급받으면 19톤이 남아있게 됩니다. 15일 이후부터 29일 이후까지 필요한 밀가루는 15톤이므로 더 이상의 공급은 필요 없습니다.   따라서 총 2회의 밀가루를 공급받으면 됩니다.        #include &lt;string&gt;     #include &lt;vector&gt;     #include &lt;queue&gt;     using namespace std;          priority_queue &lt;int&gt; pq;     int solution(int stock, vector&lt;int&gt; dates, vector&lt;int&gt; supplies, int k) {         int answer = 0;                  int idx = 0;         int day = 0;         while(1){                          stock--;             day++;                          if(day &gt;= k){                 break;             }                          //stock 추가             if(dates[idx] == day){                 pq.push(supplies[idx++]);             }                          if(stock == 0){                 stock += pq.top();                 pq.pop();                 answer++;             }                      }                  return answer;     }          문제 풀이       while문을 돌리고, 루프 마다 stock을 하나씩 빼 주고, day를 하나씩 올려준다.       한번의 루프 마다 하루가 가는 것이다.       날짜가 k가 넘게 되면 종료 해 준다.       만약, dates[idx]가 현재 날짜와 같다면, 즉 공급받을 수 있는 날짜가 되면,       공급량을 우선순위 큐에 넣어준다.       우선순위 큐는 max heap이다. 공급량이 제일 많을 때 추가해야 하기 때문이다.       stock이 떨어질 때마다 우선순위 큐의 top을 더해 주고, 답을 +1 한다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%9D%BC%EB%A9%B4%EA%B3%B5%EC%9E%A5/",
        "teaser": null
      },{
        "title": "[프로그래머스] 이중우선순위큐",
        "excerpt":"이중우선순위큐   Algorithm: 힙 Created: Apr 16, 2020 1:06 AM DoubleChk: No Type: 프로그래머스 level: 3 link: https://programmers.co.kr/learn/courses/30/lessons/42628   문제 설명   이중 우선순위 큐는 다음 연산을 할 수 있는 자료구조를 말합니다.   Untitled   이중 우선순위 큐가 할 연산 operations가 매개변수로 주어질 때, 모든 연산을 처리한 후 큐가 비어있으면 [0,0] 비어있지 않으면 [최댓값, 최솟값]을 return 하도록 solution 함수를 구현해주세요.   제한사항      operations는 길이가 1 이상 1,000,000 이하인 문자열 배열입니다.   operations의 원소는 큐가 수행할 연산을 나타냅니다.            원소는 “명령어 데이터” 형식으로 주어집니다.- 최댓값/최솟값을 삭제하는 연산에서 최댓값/최솟값이 둘 이상인 경우, 하나만 삭제합니다.           빈 큐에 데이터를 삭제하라는 연산이 주어질 경우, 해당 연산은 무시합니다.   입출력 예   Untitled   입출력 예 설명   16을 삽입 후 최댓값을 삭제합니다. 비어있으므로 [0,0]을 반환합니다.7,5,-5를 삽입 후 최솟값을 삭제합니다. 최대값 7, 최소값 5를 반환합니다.        #include &lt;string&gt;     #include &lt;vector&gt;     #include &lt;queue&gt;     #include &lt;algorithm&gt;     using namespace std;          deque &lt;int&gt; dq;     vector&lt;int&gt; solution(vector&lt;string&gt; operations) {         vector&lt;int&gt; answer;         for(auto oper : operations){             char order = oper[0];             string num = oper.substr(2, oper.length()-1);     \t\t\t\tint number = atoi(num.c_str());                          if(order == 'I'){                 dq.push_back(number);                 sort(dq.begin(), dq.end());             }else if(order == 'D' &amp;&amp; number == 1 &amp;&amp; !dq.empty()){                 dq.pop_back();             }else if(order == 'D' &amp;&amp; number == -1 &amp;&amp; !dq.empty()){                 dq.pop_front();             }         }                  if(dq.empty()){             answer.push_back(0);             answer.push_back(0);         }else{             answer.push_back(dq.back());             answer.push_back(dq.front());         }                  return answer;     }          문제 풀이       deque를 만들어서 push 할 때마다 sorting을 해 준다.       연산을 모두 수행 후에 dq가 비었다면 0, 0을 answer에 푸쉬 해 주고,       비어있지 않다면 가장 큰 값과 작은값을 푸쉬 해 준다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9D%B4%EC%A4%91%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84%ED%81%90/",
        "teaser": null
      },{
        "title": "[백준 17837] 새로운 게임 2",
        "excerpt":"새로운 게임 2   Algorithm: 시뮬레이션 Created: Apr 18, 2020 7:47 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/17837   문제   재현이는 주변을 살펴보던 중 체스판과 말을 이용해서 새로운 게임을 만들기로 했다. 새로운 게임은 크기가 N×N인 체스판에서 진행되고, 사용하는 말의 개수는 K개이다. 말은 원판모양이고, 하나의 말 위에 다른 말을 올릴 수 있다. 체스판의 각 칸은 흰색, 빨간색, 파란색 중 하나로 색칠되어있다.   게임은 체스판 위에 말 K개를 놓고 시작한다. 말은 1번부터 K번까지 번호가 매겨져 있고, 이동 방향도 미리 정해져 있다. 이동 방향은 위, 아래, 왼쪽, 오른쪽 4가지 중 하나이다.   턴 한 번은 1번 말부터 K번 말까지 순서대로 이동시키는 것이다. 한 말이 이동할 때 위에 올려져 있는 말도 함께 이동한다. 말의 이동 방향에 있는 칸에 따라서 말의 이동이 다르며 아래와 같다. 턴이 진행되던 중에 말이 4개 이상 쌓이는 순간 게임이 종료된다.      A번 말이 이동하려는 칸이            흰색인 경우에는 그 칸으로 이동한다. 이동하려는 칸에 말이 이미 있는 경우에는 가장 위에 A번 말을 올려놓는다.                    A번 말의 위에 다른 말이 있는 경우에는 A번 말과 위에 있는 모든 말이 이동한다.           예를 들어, A, B, C로 쌓여있고, 이동하려는 칸에 D, E가 있는 경우에는 A번 말이 이동한 후에는 D, E, A, B, C가 된다.                       빨간색인 경우에는 이동한 후에 A번 말과 그 위에 있는 모든 말의 쌓여있는 순서를 반대로 바꾼다.                    A, B, C가 이동하고, 이동하려는 칸에 말이 없는 경우에는 C, B, A가 된다.           A, D, F, G가 이동하고, 이동하려는 칸에 말이 E, C, B로 있는 경우에는 E, C, B, G, F, D, A가 된다.                       파란색인 경우에는 A번 말의 이동 방향을 반대로 하고 한 칸 이동한다. 방향을 반대로 바꾼 후에 이동하려는 칸이 파란색인 경우에는 이동하지 않고 가만히 있는다.       체스판을 벗어나는 경우에는 파란색과 같은 경우이다.           체스판의 크기와 말의 위치, 이동 방향이 모두 주어졌을 때, 게임이 종료되는 턴의 번호를 구해보자.   입력   첫째 줄에 체스판의 크기 N, 말의 개수 K가 주어진다. 둘째 줄부터 N개의 줄에 체스판의 정보가 주어진다. 체스판의 정보는 정수로 이루어져 있고, 각 정수는 칸의 색을 의미한다. 0은 흰색, 1은 빨간색, 2는 파란색이다.   다음 K개의 줄에 말의 정보가 1번 말부터 순서대로 주어진다. 말의 정보는 세 개의 정수로 이루어져 있고, 순서대로 행, 열의 번호, 이동 방향이다. 행과 열의 번호는 1부터 시작하고, 이동 방향은 4보다 작거나 같은 자연수이고 1부터 순서대로 →, ←, ↑, ↓의 의미를 갖는다.   같은 칸에 말이 두 개 이상 있는 경우는 입력으로 주어지지 않는다.   출력   게임이 종료되는 턴의 번호를 출력한다. 그 값이 1,000보다 크거나 절대로 게임이 종료되지 않는 경우에는 -1을 출력한다.   제한      4 ≤ N ≤ 12   4 ≤ K ≤ 10        #include &lt;string&gt;     #include &lt;vector&gt;     #include &lt;algorithm&gt;     #include &lt;map&gt;     #include &lt;queue&gt;     #include &lt;functional&gt;     #include &lt;iostream&gt;     #include &lt;typeinfo&gt;     using namespace std;     int N, K;     int dx[5] = {0, 0, 0, -1, 1};     int dy[5] = {0, 1, -1, 0, 0};     typedef struct {         int x;         int y;         int d;     }chess;     int board[13][13];     vector &lt;int&gt; v[13][13]; //말이 몇개 있는지 저장     chess Chess[13];     int moveDir(int d){         if(d == 1) return 2;         else if(d==2) return 1;         else if(d==3) return 4;         else return 3;     }     int move(int idx){              int nd = Chess[idx].d;         int nx = Chess[idx].x + dx[nd];         int ny = Chess[idx].y + dy[nd];              //파란색인 경우에는 A번 말의 이동 방향을 반대로 하고 한 칸 이동한다.         //방향을 반대로 바꾼 후에 이동하려는 칸이 파란색인 경우에는 이동하지 않고 가만히 있는다.         if(nx &gt; N || ny &gt; N || nx &lt;= 0 || ny &lt;= 0 || board[nx][ny] == 2){ //파란색, 범위 넘었을 경우             nd = moveDir(Chess[idx].d);             nx = Chess[idx].x + dx[nd];             ny = Chess[idx].y + dy[nd];             Chess[idx].d = nd;                  if(nx &gt; N || ny &gt; N ||nx &lt;= 0 || ny &lt;= 0 || board[nx][ny] == 2){                 return 0;             }         }              vector &lt;int&gt; &amp;cur = v[Chess[idx].x][Chess[idx].y]; //기존의 말들         vector &lt;int&gt; &amp;next = v[nx][ny]; //다음 칸의 말들         auto s = find(cur.begin(), cur.end(), idx); //idx의 말을 찾는다              //빨간색인 경우에는 이동한 후에 A번 말과 그 위에 있는 모든 말의 쌓여있는 순서를 반대로 바꾼다.         if(board[nx][ny] == 1){             reverse(s, cur.end());         }              //흰색인 경우에는 그 칸으로 이동한다. 이동하려는 칸에 말이 이미 있는 경우에는 가장 위에 A번 말을 올려놓는다.         for(auto it = s; it != cur.end(); ++it){             Chess[*it].x = nx, Chess[*it].y = ny;             next.push_back(*it);         }         cur.erase(s, cur.end());              return next.size();          }     void input(){         cin &gt;&gt; N &gt;&gt; K;         for(int i=1; i&lt;=N; i++){             for(int j=1; j&lt;=N; j++){                 cin &gt;&gt; board[i][j];             }         }              for(int i=1; i&lt;=K; i++){             int x, y, d;             cin &gt;&gt; x &gt;&gt; y &gt;&gt; d;             v[x][y].push_back(i); //i번째 말이 있음             Chess[i] = {x, y, d}; //말 정보 저장         }          }     int solve(){         int round, stack_cnt = 0;         for (round = 1; round &lt;= 1000; ++round)         {             for (int i = 1; i &lt;= K; ++i)             {                 stack_cnt = move(i);                 if (stack_cnt &gt;= 4) return round;             }         }              return -1;     }     int main(){              input();         int answer = solve();         cout &lt;&lt; answer &lt;&lt; endl;              return 0;     }          문제 풀이       체스 판을 저장할 2차원 배열 board[][]       체스 말을 저장할 1차원 배열 chess[] (chess는 구조체)       체스 판에 올라간 체스 말을 저장할 vector  v[x][y] → x, y에 vector의 말이 올라가 있음       1000번이 넘으면 종료해야 하기 때문에 반복문을 1000번 돌려준다.       말들을 순서대로 움직이면서, 말들이 얼마나 올라갔는지 세어 준다.       말들이 4개 이상 올라가 있다면 종료한다.       말들을 움직이는 로직이다.       다음 칸이 파란색이거나, 범위를 넘었다면 방향을 바꾸고, 한 칸 전진 해 준다.       바꾼 방향은 저장을 해 주어야 한다.       다음 칸이 빨간색이면, reverse 해 준다.       다음 칸이 하얀색이면, 그대로 올려준다.                     해당 칸에 몇 마리의 말이 올라와있는지 return 해 준다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-17837-%EC%83%88%EB%A1%9C%EC%9A%B4-%EA%B2%8C%EC%9E%84-2/",
        "teaser": null
      },{
        "title": "[leetcode] Jump Game",
        "excerpt":"Jump Game   Algorithm: 그리디 Created: Apr 18, 2020 9:36 PM DoubleChk: Yes Type: LeetCode level: 2 link: https://leetcode.com/problems/jump-game/   Given an array of non-negative integers, you are initially positioned at the first index of the array.   Each element in the array represents your maximum jump length at that position.   Determine if you are able to reach the last index.   Example 1:   Input: [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.   Example 2:   Input: [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum              jump length is 0, which makes it impossible to reach the last index.        Top-Down       class Solution {   public:       bool canJump(vector&lt;int&gt;&amp; nums) {           int farest = 0;           for(int i=0; i&lt;=farest; i++){           \tfarest = max(farest, nums[i] + i);           \tif(farest &gt;= nums.size()-1){           \t\treturn true;           \t}           }           return false;       }   };           Bottom-Up       class Solution {   public:       bool canJump(vector&lt;int&gt;&amp; nums) {           int lastGoodIdx = nums.size() - 1;           for(int i=lastGoodIdx; i&gt;=0; i--){           \tif(nums[i] + i &gt;= lastGoodIdx){           \t\tlastGoodIdx = i;           \t}           }           return lastGoodIdx == 0;       }   };                     문제 풀이       매우 유명한 알고리즘 중 하나이다.       dfs로 풀게 되면 시간초과가 나기 때문에, 그리디로 풀어야 한다.       top-down방식과 bottom-up방식 두 개 다 풀어보았다.       ### top-down       현재 인덱스에서 가장 멀리 갈수 있는 farest변수를 선언한다.       이 farest를 반복문을 돌면서 update 해 준다.       만약 farest가 배열의 길이보다 크거나 같으면(배열의 길이가 1개일 수도 있으므로) true를 리턴해주고,       반복문이 종료된다면 false를 리턴해준다.       ### bottom-up       끝에서부터 시작하면서, lastGoodIdx를 update해주는 방식이다.       앞의 인덱스가 lastGoodIdx에 갈 수 있다면(nums[i] + i), lastGoodIdx를 업데이트 해 준다.       만약 lastGoodIdx가 0이면 앞까지 도달했기 때문에 true이고, 아니라면 false이다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Jump-Game/",
        "teaser": null
      },{
        "title": "[프로그래머스] 크레인 인형뽑기 게임",
        "excerpt":"크레인 인형뽑기 게임   Algorithm: 스택 Created: Apr 19, 2020 2:14 PM DoubleChk: No Type: 프로그래머스 link: https://programmers.co.kr/learn/courses/30/lessons/64061   문제 설명   게임개발자인 죠르디는 크레인 인형뽑기 기계를 모바일 게임으로 만들려고 합니다.죠르디는 게임의 재미를 높이기 위해 화면 구성과 규칙을 다음과 같이 게임 로직에 반영하려고 합니다.      게임 화면은 1 x 1 크기의 칸들로 이루어진 N x N 크기의 정사각 격자이며 위쪽에는 크레인이 있고 오른쪽에는 바구니가 있습니다. (위 그림은 5 x 5 크기의 예시입니다). 각 격자 칸에는 다양한 인형이 들어 있으며 인형이 없는 칸은 빈칸입니다. 모든 인형은 1 x 1 크기의 격자 한 칸을 차지하며 격자의 가장 아래 칸부터 차곡차곡 쌓여 있습니다. 게임 사용자는 크레인을 좌우로 움직여서 멈춘 위치에서 가장 위에 있는 인형을 집어 올릴 수 있습니다. 집어 올린 인형은 바구니에 쌓이게 되는 데, 이때 바구니의 가장 아래 칸부터 인형이 순서대로 쌓이게 됩니다. 다음 그림은 [1번, 5번, 3번] 위치에서 순서대로 인형을 집어 올려 바구니에 담은 모습입니다.      만약 같은 모양의 인형 두 개가 바구니에 연속해서 쌓이게 되면 두 인형은 터뜨려지면서 바구니에서 사라지게 됩니다. 위 상태에서 이어서 [5번] 위치에서 인형을 집어 바구니에 쌓으면 같은 모양 인형 두 개가 없어집니다.      크레인 작동 시 인형이 집어지지 않는 경우는 없으나 만약 인형이 없는 곳에서 크레인을 작동시키는 경우에는 아무런 일도 일어나지 않습니다. 또한 바구니는 모든 인형이 들어갈 수 있을 만큼 충분히 크다고 가정합니다. (그림에서는 화면표시 제약으로 5칸만으로 표현하였음)   게임 화면의 격자의 상태가 담긴 2차원 배열 board와 인형을 집기 위해 크레인을 작동시킨 위치가 담긴 배열 moves가 매개변수로 주어질 때, 크레인을 모두 작동시킨 후 터트려져 사라진 인형의 개수를 return 하도록 solution 함수를 완성해주세요.   [제한사항]           board 배열은 2차원 배열로 크기는  이상  이하입니다.       5 x 5       30 x 30       board의 각 칸에는 0 이상 100 이하인 정수가 담겨있습니다.            0은 빈 칸을 나타냅니다.       1 ~ 100의 각 숫자는 각기 다른 인형의 모양을 의미하며 같은 숫자는 같은 모양의 인형을 나타냅니다.           moves 배열의 크기는 1 이상 1,000 이하입니다.   moves 배열 각 원소들의 값은 1 이상이며 board 배열의 가로 크기 이하인 자연수입니다.   입출력 예   Untitled   입출력 예에 대한 설명   입출력 예 #1   인형의 처음 상태는 문제에 주어진 예시와 같습니다. 크레인이 [1, 5, 3, 5, 1, 2, 1, 4] 번 위치에서 차례대로 인형을 집어서 바구니에 옮겨 담은 후, 상태는 아래 그림과 같으며 바구니에 담는 과정에서 터트려져 사라진 인형은 4개 입니다.           #include &lt;string&gt;     #include &lt;vector&gt;     #include &lt;stack&gt;     using namespace std;     stack &lt;int&gt; st;     int solution(vector&lt;vector&lt;int&gt;&gt; board, vector&lt;int&gt; moves) {         int answer = 0;         for(int i=0; i&lt;moves.size(); i++){             int move = moves[i]-1;             for(int j=0;j&lt;board.size();j++){                 if(board[j][move]!=0){                     if(!st.empty() &amp;&amp; st.top() == board[j][move]){                         st.pop();                         answer+=2;                     }else{                         st.push(board[j][move]);                     }                     board[j][move] = 0;                     break;                 }                  }              }              return answer;     }  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%81%AC%EB%A0%88%EC%9D%B8-%EC%9D%B8%ED%98%95%EB%BD%91%EA%B8%B0-%EA%B2%8C%EC%9E%84/",
        "teaser": null
      },{
        "title": "[백준 17825] 주사위 윷놀이",
        "excerpt":"주사위 윷놀이   Algorithm: dfs, 시뮬레이션 Created: Apr 21, 2020 3:11 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/17825   문제   주사위 윷놀이는 다음과 같은 게임판에서 하는 게임이다.   https://upload.acmicpc.net/43409ac6-54bf-4a21-b542-e01a8211e59f/-/preview/      처음에는 시작 칸에 말 4개가 있다.   말은 게임판에 그려진 화살표의 방향대로만 이동할 수 있다. 말이 파란색 칸에서 이동을 시작하면 파란색 화살표를 타야 하고, 이동하는 도중이거나 파란색이 아닌 칸에서 이동을 시작하면 빨간색 화살표를 타야 한다. 말이 도착 칸으로 이동하면 주사위에 나온 수와 관계 없이 이동을 마친다.   게임은 10개의 턴으로 이루어진다. 매 턴마다 1부터 5까지 한 면에 하나씩 적혀있는 5면체 주사위를 굴리고, 도착 칸에 있지 않은 말을 하나 골라 주사위에 나온 수만큼 이동시킨다.   말이 이동을 마치는 칸에 다른 말이 있으면 그 말은 고를 수 없다. 단, 이동을 마치는 칸이 도착 칸이면 고를 수 있다.   말이 이동을 마칠 때마다 칸에 적혀있는 수가 점수에 추가된다.   주사위에서 나올 수 10개를 미리 알고 있을 때, 얻을 수 있는 점수의 최댓값을 구해보자.     #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; #include &lt;map&gt; #include &lt;stack&gt; #include &lt;iostream&gt; using namespace std; map&lt;int, int&gt; red = {         { 0, 2 },{ 2, 4 },{ 4, 6 },         { 6, 8 },{ 8, 10 },{ 10, 12 },         { 12, 14 },{ 14, 16 },{ 16, 18 },         { 18, 20 },{ 20, 22 },{ 22, 24 },         { 24, 26 },{ 26, 28 },{ 28, 30 },         { 30, 32 },{ 32, 34 },{ 34, 36 },         { 36, 38 },{ 38, 40 },{ 40, 50 } };  map&lt;int, int&gt; blue = {         { 10, 13 },{ 13, 16 },{ 16, 19 },         { 19, 25 },{ 20, 22 },{ 22, 24 },         { 24, 25 },{ 30, 28 },{ 28, 27 },         { 27, 26 },{ 26, 25 }, };  map&lt;int, int&gt; blue_goal = {         { 25, 30 },{ 30, 35 },{ 35, 40 },{ 40, 50 } };  int ans; vector&lt;int&gt; dice; void input(){     for(int i=0; i&lt;10; i++){         int n;         cin &gt;&gt; n;         dice.push_back(n);     } } int move(int idx, int piece, vector&lt;pair&lt;int, int&gt;&gt;&amp; pieces){      //해당 piece의 방향 알기     int dir = pieces[piece].second;     int now = pieces[piece].first;     int cnt = dice[idx];      for(int i=0; i&lt;cnt; i++){          if(dir == 0){             now = red[now];         }else if(dir == 1){             now = blue[now];         }else if(dir == 2){             now = blue_goal[now];         }          if(now == 25) dir = 2;         else if(now == 50) break; //끝에 도달     }      int check = true;     if(now == 50){         pieces[piece].first = 50;     }else{          if(dir == 0 &amp;&amp; (now == 10 || now == 20 || now == 30)) dir = 1;          for(int i=0; i&lt;4; i++){ //중복된 말이 있는지 체크한다.             if(i == piece) continue;             if(pieces[i].first == now &amp;&amp; (now == 40 || dir == pieces[i].second)){                 check = false;             }         }          if(!check){             return -1;         }else{             pieces[piece].first = now;             pieces[piece].second = dir;             return now;         }      }      return 0; } void solve(int idx, int sum, vector&lt;pair&lt;int, int&gt;&gt;&amp; pieces){      if(idx &gt;= 10){         ans = max(ans, sum);         return;     }      //모든 말들 dfs     for(int i=0; i&lt;4; i++){         int prev = pieces[i].first;         int prev_dir = pieces[i].second;          int ret = move(idx, i, pieces);         if(ret &gt; -1){             solve(idx + 1, sum + ret, pieces);         }          pieces[i].first = prev;         pieces[i].second = prev_dir;     }  } int main(){     vector &lt;pair&lt;int, int&gt;&gt; pieces; //현재 위치, 방향     //0 -&gt; 제일 큰 동그라미     //1 -&gt; 꺾을 때     //2 -&gt; 25일 때      pieces ={{0, 0},{0, 0},{0, 0},{0, 0}};      input();     solve(0, 0, pieces);      cout &lt;&lt; ans &lt;&lt; endl;      return 0; }           문제 풀이       map을 사용해서 윷놀이 판을 구현한다.       4개의 말을 10번 돌리는 모든 경우의 수를 파악하여 제일 큰 값을 저장해야 하기 때문에, dfs로 풀어준다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-17825-%EC%A3%BC%EC%82%AC%EC%9C%84-%EC%9C%B7%EB%86%80%EC%9D%B4/",
        "teaser": null
      },{
        "title": "[프로그래머스] 튜플",
        "excerpt":"튜플   Algorithm: 배열 Created: Apr 21, 2020 4:16 PM DoubleChk: No Type: 프로그래머스 link: https://programmers.co.kr/learn/courses/30/lessons/64065   문제 설명   셀수있는 수량의 순서있는 열거 또는 어떤 순서를 따르는 요소들의 모음을 튜플(tuple)이라고 합니다. n개의 요소를 가진 튜플을 n-튜플(n-tuple)이라고 하며, 다음과 같이 표현할 수 있습니다.      (a1, a2, a3, …, an)   튜플은 다음과 같은 성질을 가지고 있습니다.      중복된 원소가 있을 수 있습니다. ex : (2, 3, 1, 2)   원소에 정해진 순서가 있으며, 원소의 순서가 다르면 서로 다른 튜플입니다. ex : (1, 2, 3) ≠ (1, 3, 2)   튜플의 원소 개수는 유한합니다.   원소의 개수가 n개이고, 중복되는 원소가 없는 튜플 (a1, a2, a3, ..., an)이 주어질 때(단, a1, a2, …, an은 자연수), 이는 다음과 같이 집합 기호 ‘{‘, ‘}’를 이용해 표현할 수 있습니다.      {{a1}, {a1, a2}, {a1, a2, a3}, {a1, a2, a3, a4}, … {a1, a2, a3, a4, …, an}}   예를 들어 튜플이 (2, 1, 3, 4)인 경우 이는      {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}   와 같이 표현할 수 있습니다. 이때, 집합은 원소의 순서가 바뀌어도 상관없으므로      {{2}, {2, 1}, {2, 1, 3}, {2, 1, 3, 4}}   {{2, 1, 3, 4}, {2}, {2, 1, 3}, {2, 1}}   {{1, 2, 3}, {2, 1}, {1, 2, 4, 3}, {2}}   는 모두 같은 튜플 (2, 1, 3, 4)를 나타냅니다.   특정 튜플을 표현하는 집합이 담긴 문자열 s가 매개변수로 주어질 때, s가 표현하는 튜플을 배열에 담아 return 하도록 solution 함수를 완성해주세요.   [제한사항]      s의 길이는 5 이상 1,000,000 이하입니다.   s는 숫자와 ‘{‘, ‘}’, ‘,’ 로만 이루어져 있습니다.   숫자가 0으로 시작하는 경우는 없습니다.   s는 항상 중복되는 원소가 없는 튜플을 올바르게 표현하고 있습니다.   s가 표현하는 튜플의 원소는 1 이상 100,000 이하인 자연수입니다.   return 하는 배열의 길이가 1 이상 500 이하인 경우만 입력으로 주어집니다.        #include &lt;string&gt;     #include &lt;vector&gt;     #include &lt;algorithm&gt;          using namespace std;     int check[100001];          bool size_cmp(vector&lt;int&gt; a, vector&lt;int&gt; b) {         return a.size() &lt; b.size();     }     vector&lt;int&gt; solution(string s) {         vector&lt;int&gt; answer;         vector &lt;vector&lt;int&gt;&gt; numbers;         vector &lt;int&gt; temp;         string numberString = \"\";         for (int i = 1; i &lt; s.length() - 1; i++) {             if (s[i] == ',') {                 temp.push_back(atoi(numberString.c_str()));                 numberString = \"\";             }             else if (s[i] == '{') {                 //             }             else if (s[i] == '}') {                 temp.push_back(atoi(numberString.c_str()));                 numberString = \"\";                 numbers.push_back(temp);                 temp.clear();                 i++; // '}' 바로 다음에 나오는 ',' 무시하기 위함             }             else {                 numberString += s[i];             }         }              //작은 순대로 정렬         sort(numbers.begin(), numbers.end(), size_cmp);                  for(int i=0; i&lt;numbers.size(); i++){             for(auto num : numbers[i]){                 if(!check[num]){                     check[num] = 1;                     answer.push_back(num);                 }             }         }              return answer;     }          문제 풀이       vector&lt;vector&gt; numbers;에 string을 쪼개서 int 형태로 바꾸어 넣어준다.       배열의 크기 별로 정리 한 후, 중복되지 않은 숫자를 답에 넣으면 된다.       ”{{4,2,3},{3},{2,3,4,1},{2,3}}”       를 예시로 들자면,       크기 별로 정리하면 다음과 같게 된다.       [3]       [2, 3]       [4, 2, 3]       [2, 3, 4, 1]       답은 [3, 2, 4, 1] 이다.       제일 작은 숫자가 tuple의 시작이 된다.       K번째 줄에 K-1의 숫자를 제외한 숫자가 답이다.       check라는 1차원 배열로 해당 원소를 답에 넣었는지 안 넣었는지 확인 해 준다.       check 처리 후 배열에 넣어준다.      ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%8A%9C%ED%94%8C/",
        "teaser": null
      },{
        "title": "[프로그래머스] 불량 사용자",
        "excerpt":"불량 사용자   Algorithm: dfs Created: Apr 22, 2020 2:46 PM DoubleChk: No Type: 프로그래머스 level: 3 link: https://programmers.co.kr/learn/courses/30/lessons/64064   문제 설명   개발팀 내에서 이벤트 개발을 담당하고 있는 무지는 최근 진행된 카카오이모티콘 이벤트에 비정상적인 방법으로 당첨을 시도한 응모자들을 발견하였습니다. 이런 응모자들을 따로 모아 불량 사용자라는 이름으로 목록을 만들어서 당첨 처리 시 제외하도록 이벤트 당첨자 담당자인 프로도 에게 전달하려고 합니다. 이 때 개인정보 보호을 위해 사용자 아이디 중 일부 문자를 ‘’ 문자로 가려서 전달했습니다. 가리고자 하는 문자 하나에 ‘’ 문자 하나를 사용하였고 아이디 당 최소 하나 이상의 ‘*’ 문자를 사용하였습니다.무지와 프로도는 불량 사용자 목록에 매핑된 응모자 아이디를 제재 아이디 라고 부르기로 하였습니다.   예를 들어, 이벤트에 응모한 전체 사용자 아이디 목록이 다음과 같다면   Untitled   다음과 같이 불량 사용자 아이디 목록이 전달된 경우,   Untitled   불량 사용자에 매핑되어 당첨에서 제외되어야 야 할 제재 아이디 목록은 다음과 같이 두 가지 경우가 있을 수 있습니다.   Untitled   Untitled   이벤트 응모자 아이디 목록이 담긴 배열 user_id와 불량 사용자 아이디 목록이 담긴 배열 banned_id가 매개변수로 주어질 때, 당첨에서 제외되어야 할 제재 아이디 목록은 몇가지 경우의 수가 가능한 지 return 하도록 solution 함수를 완성해주세요.   [제한사항]      user_id 배열의 크기는 1 이상 8 이하입니다.   user_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.            응모한 사용자 아이디들은 서로 중복되지 않습니다.       응모한 사용자 아이디는 알파벳 소문자와 숫자로만으로 구성되어 있습니다.           banned_id 배열의 크기는 1 이상 user_id 배열의 크기 이하입니다.   banned_id 배열 각 원소들의 값은 길이가 1 이상 8 이하인 문자열입니다.            불량 사용자 아이디는 알파벳 소문자와 숫자, 가리기 위한 문자 ‘*’ 로만 이루어져 있습니다.       불량 사용자 아이디는 ‘*’ 문자를 하나 이상 포함하고 있습니다.       불량 사용자 아이디 하나는 응모자 아이디 중 하나에 해당하고 같은 응모자 아이디가 중복해서 제재 아이디 목록에 들어가는 경우는 없습니다.           제재 아이디 목록들을 구했을 때 아이디들이 나열된 순서와 관계없이 아이디 목록의 내용이 동일하다면 같은 것으로 처리하여 하나로 세면 됩니다.        #include &lt;string&gt;     #include &lt;vector&gt;     #include &lt;set&gt;     #include &lt;algorithm&gt;     #include &lt;map&gt;     using namespace std;          set &lt;set&lt;string&gt;&gt; s;     map &lt;string, int&gt; m;          void dfs(int idx, set&lt;string&gt;&amp; candidates, vector&lt;string&gt;&amp; user_id, vector&lt;string&gt; banned_id){         if(idx == banned_id.size()){             s.insert(candidates);             return;         }              string target = banned_id[idx];         for(int i=0; i&lt;user_id.size(); i++){                  if(!m[user_id[i]] &amp;&amp; target.length() == user_id[i].length()){                      bool chk = true;                 for(int j=0; j&lt;user_id[i].length(); j++){                     if(target[j] == '*') continue;                          if(user_id[i][j] != target[j]){                         chk = false;                         break;                     }                 }                      if(chk){                     m[user_id[i]] = 1;                     candidates.insert(user_id[i]);                     dfs(idx + 1, candidates, user_id, banned_id);                     candidates.erase(user_id[i]);                     m[user_id[i]] = 0;                 }             }         }          }     int solution(vector&lt;string&gt; user_id, vector&lt;string&gt; banned_id) {              set &lt;string&gt; candidates;         dfs(0, candidates, user_id, banned_id);                   return s.size();     }          문제 풀이       dfs로 푼 문제이다.       답을 저장할 candidates을 만들어준다. 중복되지 않게 하기 위해 set으로 만들어준다.       dfs              candidates의 길이가 banned_id의 길이와 같다면 set에 넣고 return. (기저조건)       벡터 user_id의 길이만큼 돌면서, user_id와 banned_id의 길이가 같고, 방문하지 않았을 경우에 반복문에 진입한다.       해당 user_id의 길이만큼 돌면서, banned_id와 비교한다.       해당되는 id이면, 방문처리를 하고, candidates에 넣고, dfs를 반복한다.          ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%B6%88%EB%9F%89-%EC%82%AC%EC%9A%A9%EC%9E%90/",
        "teaser": null
      },{
        "title": "[React] useContext 배열 예제",
        "excerpt":"React CreateContext   Created By: 성희 배 Last Edited: Apr 23, 2020 7:28 PM         호텔 사이트 클론 프로젝트 진행중에, 호텔을 클릭 시 위쪽 컴포넌트에 클릭한 호텔의 이름을 삽입하는 기능을 구현하고자 했다. 두 개는 독립된 컴포넌트라서 콜백으로 진행하기는 어려울 것 같아, 따로 js파일을 만들어 전역 변수로 배열을 두고 queue 기능을 구현 하였다. 하지만 이렇게 하니, 두 컴포넌트의 바인딩을 어떻게 해야 할지 감이 잡히지 않았다.   useRef를 사용해보려고 했지만, 변화를 잡아내지 못했다.. 그래서 확장성은 떨어지지만 useContext를 사용하여 구현하고자 하였다.     RecentContext.js      context를 생성하고 관리할 js 파일을 하나 만들었다.   외부에서 호출할 값과 함수를 createContext 안에 선언 해 준다.       const RecentContext = createContext({     clickedHotels: [],     pushHotels: () =&gt; { }   });           clickedHotels : 클릭한 호텔들을 저장할 배열   pushHotels : 클릭한 호텔을 clickedHotels에 넣는 함수        그 아래에 provider를 선언하였다.   provider는 context를 구독하는 컴포넌트들에게 context의 변화를 알리는 역할을 한다.       export const RecentProvider = ({ children }) =&gt; {     const [clickedHotels, setHotel] = useState([]);          const value = {       clickedHotels,       pushHotels     }          return (       &lt;RecentContext.Provider value={value}&gt;{children}&lt;/RecentContext.Provider&gt;     );   };        export default RecentContext           useState로 어떠한 값에 변화를 줄지 선언 해 주었다.   value ={value} : 자식들에게 리턴해줄 객체들을 value에 선언 후, 인자로 넘겨 주었다.     App.js       function App() {       return (         &lt;Router&gt;           &lt;RecentProvider&gt;             &lt;Route exact path=\"/\" component={Home}&gt;&lt;/Route&gt;             &lt;Route path=\"/hotels\" component={Hotels}&gt;&lt;/Route&gt;           &lt;/RecentProvider&gt;         &lt;/Router&gt;       );     }     Router 밖에 RecentProvider 로 감싸준다.        이제 기본 셋팅은 다 됐다.   그럼 react에서 어떻게 사용하면 되는가?   Recent.js       import RecentContext from './RecentContext'     상단에 import를 해 준다.       const { clickedHotels } = useContext(RecentContext);           함수 내부에서 useContext hooks를 사용해 provider가 제공해주는 객체들에 접근할 수 있다!     Full Code   RecentContext.js       import React, { useState, createContext } from 'react'          const RecentContext = createContext({       clickedHotels: [],       pushHotels: () =&gt; {}     });          export const RecentProvider = ({ children }) =&gt; {       const [clickedHotels, setHotel] = useState([]);            const pushHotels = (name) =&gt; {                  if (clickedHotels.length &gt;= 5) {           clickedHotels.shift();         }              let retArr = clickedHotels.filter((hotel)=&gt;{           return hotel !== name;         });              setHotel([...retArr, name]);       }            const value = {         clickedHotels,         pushHotels       }            return (         &lt;RecentContext.Provider value={value}&gt;{children}&lt;/RecentContext.Provider&gt;       );     };          export default RecentContext  Recent.js       import React, { useContext } from 'react'     import styled from 'styled-components'     import RecentContext from './RecentContext'     const Container = styled.div`         display : flex;         width : 100%;         background-color : white;         align-items: center;     `;     const ClickedHotel = styled.div`         background-color : gray;         padding: 10px 10px 10px 10px;         margin-left: 10px;         `;     export default () =&gt; {          const { clickedHotels } = useContext(RecentContext);                  return (             &lt;Container&gt;                 {clickedHotels.map(hotel =&gt; &lt;ClickedHotel key={Math.random()}&gt;{hotel}&lt;/ClickedHotel&gt;)}             &lt;/Container&gt;         )     }  Hotel.js       import React, {useContext} from 'react'     import styled from 'styled-components'     import RecentContext from './RecentContext';          const Container = styled.div`         height : 250px;         width : 75%;         display: flex;         margin : 3% 3% 3% 3%;     `;          const Column = styled.div`         width: 40%;         height : 100%;     `;          const Column2 = styled.div`         width: 60%;         height : 100%;         padding: 0pt 10pt 0pt 10pt;         background-color : white;     `;          const HotelImage = styled.div`         width : 100%;         height : 100%;         background-image : url(${props =&gt; props.img});         background-size : cover;     `;          const HotelInfo = styled.div`         display : flex;         flex-direction: column;         width : 100%;         height : 90%;         justify-content : space-evenly;     `;          const Facilities = styled.div`         display : flex;     `;          const Service = styled.div`         color : limegreen;         border-radius : 5px;         border : 1px solid limegreen;         font-size : 10pt;         margin-left : 5pt;         padding : 3pt 3pt 3pt 3pt;     `;          const Name = styled.div`         font-weight : 600;         font-size : 15pt;              `;          const PriceInfo = styled.div`         width: 100%;         height : 10%;     `;          const Price = styled.div`         float: right;         background-color: cornflowerblue;         color: white;         padding: 0pt 10pt 0pt 10pt;     `;          const ReviewScore = styled.span`         border-radius: 4pt;         width : 30px;         height: 30px;         text-align : center;         background-color: darkblue;         color: white;         display: flex;         justify-content: center;         align-items: center;         margin-left : 3pt;     `;          const ReviewInfo = styled.div`         margin-left : auto;         align-items : center;         display : flex;     `;          const Row = styled.div`         display:flex;         height : 30px;         width : 100%;         align-items : center;     `;          export default ({ info }) =&gt; {              const { pushHotels, clickedHotels } = useContext(RecentContext);              const handleClickHotel = (hotelName, e) =&gt; {             alert(`${hotelName} 을 조회하였습니다.`)             pushHotels(hotelName)         }              return (             &lt;Container onClick={handleClickHotel.bind(this, info.name)}&gt;                 &lt;Column&gt;                     &lt;HotelImage img={info.imageUrl} /&gt;                 &lt;/Column&gt;                 &lt;Column2&gt;                     &lt;HotelInfo&gt;                         &lt;Row&gt;                             &lt;Name&gt;{info.name}&lt;/Name&gt;                             &lt;ReviewInfo&gt;                                 &lt;div&gt;{info.totalReviewCount}개의 이용 후기&lt;/div&gt;                                 &lt;ReviewScore&gt;{info.reviewScore}&lt;/ReviewScore&gt;                             &lt;/ReviewInfo&gt;                         &lt;/Row&gt;                              &lt;Facilities&gt;                             {info.freeServices.map((service, idx) =&gt; &lt;Service key={idx}&gt;{service}&lt;/Service&gt;)}                         &lt;/Facilities&gt;                         &lt;p&gt;{info.rate}성급 호텔&lt;/p&gt;                     &lt;/HotelInfo&gt;                          &lt;PriceInfo&gt;                         &lt;Price&gt;                             hello원~                         &lt;/Price&gt;                     &lt;/PriceInfo&gt;                 &lt;/Column2&gt;             &lt;/Container&gt;         )     }    실행 결과      It works! :D  ","categories": ["react"],
        "tags": [],
        "url": "/react/React-useContext-%EB%B0%B0%EC%97%B4-%EC%98%88%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[TIL] 이벤트 버블링, 이벤트 캡쳐링, 해결 방법",
        "excerpt":"Created By: 성희 배 Last Edited: Apr 24, 2020 6:58 PM Tags: cs      호텔 클로닝 사이드 프로젝트에서 발생한 문제이다.   자식 버튼을 누를 시에 부모의 이벤트가 호출되는 현상이 나타났다. 문제는 이벤트 버블링 때문이었다.     이벤트 버블링      하위 엘리먼트에 이벤트 발생 시 그 엘리먼트부터 상위 요소까지 이벤트가 전달되는 방식         위와 같은 형식이 있을 때, li 를 클릭하게 되면 li→ul→div 순으로 호출된다.   이벤트 캡쳐링      하위 엘리먼트에 이벤트 핸들러가 있을 때 상위 엘리먼트부터 이벤트가 발생 해 하위 엘리먼트까지 이벤트가 전달됨         똑같은 형식에 li를 클릭 시 ul을 호출하고 싶을때, ul의 이벤트 리스너에 {capture : true}로 우선순위를 부여할 수 있다.     이벤트 위임 (참고)  조상에 이벤트를 등록하여 조상이 하위 element에 이벤트를 위임하는 방식.   PROS     element의 공통 조상에만 핸들러를 달면 하위 element들에도 적용할 수 있다. → 메모리 절약            ex) 테이블의 경우 &lt;table&gt;에 핸들러를 달고, e.target으로 구별 후 작업           element가 추가 되어도 부모가 핸들링 하기 때문에 각각 리스너를 부여할 필요가 없다. → 코드가 짧아진다.   CONS     이벤트가 반드시 버블링 되어야 한다.     버블링 해결           그래서 버블링을 해결하기 위해 어떻게 해야할까? 몇 가지 방법이 있다.       ### event.preventDefault();              브라우저 동작은 막아주지만 (href 같은 것) 이벤트가 DOM에서 bubbling 되는 건 막지 못한다.           ### event.stopPropagation();              이벤트가 DOM에서 bubbling 되는 건 막지만, 브라우저 동작은 막지 못한다.           ### return false;              JQuery 코드에서 많이 쓰이고, 브라우저 동작과 이벤트 버블링을 막고 어떤 콜백에서든 즉시 return한다.             const handleErrorBtnClicked = (e) =&gt;{         e.stopPropagation();         if(retryCnt &gt;= 3) {             setError(true)             return;         }         setRetryCnt(retryCnt+1);         refetch();     }      bubbling되어서 부모의 onclick에 접근하였기 때문에, 버블링을 막기 위해 event.stopPropagation()을 리스너 상단에 추가 해 주었다.      이제 retry 버튼을 클릭 하여도 부모 이벤트가 실행되지 않는다!   It works! :)      참고   How to correctly use preventDefault(), stopPropagation(), or return false; on events   ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EB%B2%84%EB%B8%94%EB%A7%81,-%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%BA%A1%EC%B3%90%EB%A7%81,-%ED%95%B4%EA%B2%B0-%EB%B0%A9%EB%B2%95/",
        "teaser": null
      },{
        "title": "[프로그래머스] 징검다리 건너기",
        "excerpt":"징검다리 건너기   Algorithm: 이분탐색 Created: Apr 27, 2020 7:53 PM DoubleChk: No Type: 프로그래머스 level: 3 link: https://programmers.co.kr/learn/courses/30/lessons/64062   문제 설명   [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]   카카오 초등학교의 니니즈 친구들이 라이언 선생님과 함께 가을 소풍을 가는 중에 징검다리가 있는 개울을 만나서 건너편으로 건너려고 합니다. 라이언 선생님은 니니즈 친구들이 무사히 징검다리를 건널 수 있도록 다음과 같이 규칙을 만들었습니다.      징검다리는 일렬로 놓여 있고 각 징검다리의 디딤돌에는 모두 숫자가 적혀 있으며 디딤돌의 숫자는 한 번 밟을 때마다 1씩 줄어듭니다.   디딤돌의 숫자가 0이 되면 더 이상 밟을 수 없으며 이때는 그 다음 디딤돌로 한번에 여러 칸을 건너 뛸 수 있습니다.   단, 다음으로 밟을 수 있는 디딤돌이 여러 개인 경우 무조건 가장 가까운 디딤돌로만 건너뛸 수 있습니다.   니니즈 친구들은 개울의 왼쪽에 있으며, 개울의 오른쪽 건너편에 도착해야 징검다리를 건넌 것으로 인정합니다.니니즈 친구들은 한 번에 한 명씩 징검다리를 건너야 하며, 한 친구가 징검다리를 모두 건넌 후에 그 다음 친구가 건너기 시작합니다.   디딤돌에 적힌 숫자가 순서대로 담긴 배열 stones와 한 번에 건너뛸 수 있는 디딤돌의 최대 칸수 k가 매개변수로 주어질 때, 최대 몇 명까지 징검다리를 건널 수 있는지 return 하도록 solution 함수를 완성해주세요.   [제한사항]      징검다리를 건너야 하는 니니즈 친구들의 수는 무제한 이라고 간주합니다.   stones 배열의 크기는 1 이상 200,000 이하입니다.   stones 배열 각 원소들의 값은 1 이상 200,000,000 이하인 자연수입니다.   k는 1 이상 stones의 길이 이하인 자연수입니다.     [입출력 예]   Untitled   입출력 예에 대한 설명     입출력 예 #1   첫 번째 친구는 다음과 같이 징검다리를 건널 수 있습니다.      첫 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.   두 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.      두 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.   세 번째 친구도 아래 그림과 같이 징검다리를 건널 수 있습니다.      세 번째 친구가 징검다리를 건넌 후 디딤돌에 적힌 숫자는 아래 그림과 같습니다.   네 번째 친구가 징검다리를 건너려면, 세 번째 디딤돌에서 일곱 번째 디딤돌로 네 칸을 건너뛰어야 합니다. 하지만 k = 3 이므로 건너뛸 수 없습니다.      따라서 최대 3명이 디딤돌을 모두 건널 수 있습니다.     #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt;  using namespace std; bool check(vector &lt;int&gt;&amp; stones, int k, int mid){     int cntZero = 0;     for(int i=0; i&lt;stones.size(); i++){         if(stones[i] - mid &lt;= 0){             cntZero++;             if(cntZero &gt;= k) return false;         }else{             cntZero = 0;         }     }              return true; } int solution(vector&lt;int&gt; stones, int k) {          int left = 0;     int right = 200000001;          while(left &lt;= right){                  int mid = (left + right) / 2;         bool isCrossed = check(stones, k, mid);                  if(isCrossed){             //좀더 건널 수 있는지 확인             left = mid + 1;         }else{             right = mid - 1;         }              }     return left; }      이분 탐색으로 푸는 문제이다.   0이 연속해서 K개 이상 나온다면 건널 수 없다는 것까지는 풀었지만, 시간 초과로 인해 틀렸다. 돌의 높이가 2억이 넘으므로 nlogn의 시간 복잡도로 해결 해야 했다.   mid를 넘을 수 있는 니니즈라고 생각하고 연속된 0이 k개 이상 인지 아닌지를 확인한다.   건널 수 있다면, left를 더 늘려 좀 더 많은 니니즈도 건널 수 있는지 확인한다.   건널 수 없다면, right를 줄여 좀 더 적은 니니즈는 건널 수 있는지 확인한다.   left ≤ right를 충족하면, left를 리턴한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A7%95%EA%B2%80%EB%8B%A4%EB%A6%AC-%EA%B1%B4%EB%84%88%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[GraphQL] graphql의 개념과 특징",
        "excerpt":"GraphQL과 SQL  SQL       Structed Query Language   엔드 포인트가 여러 개            ex) /content, /api…           GQL        한 개의 엔드포인트   데이터 스키마에 따라 쿼리 변경   GraphQL의 특징  위계적     필드가 중첩 가능   쿼리와 반환 데이터가 같다.   제품 중심적     client가 요구하는 데이터, 지원하는 언어 및 런타임에 맞춰 동작한다.   엄격한 타입 제한     서버에서 타입 유효성을 검사한다. -&gt; 안전성   클라이언트 맞춤 쿼리  인트로스펙티브 (Introspective)   기존 SQL의 단점  over-fetching     요청한 정보보다 많은 정보를 수신하는 경우   ex) username만 필요한데 DB에서 user의 모든 정보를 수신   under-fetching     REST에서 어떤 기능을 완성하려고 많은 소스를 요청하는 경우   ex) 메인페이지에서 /feed, /user…등 여러 request 호출   URL     여러 엔드포인트 사용   URL 설계가 복잡해질 수 있음.   GraphQL이 해결!  over-fetching     쿼리를 사용 해 필요한 데이터만 가져올 수 있다.   under-fetching &amp; URL-free     쿼리를 사용 해 필요한 데이터를 모두 가져올 수 있다.   엔드포인트를 한 개만 사용하므로 한 번의 호출만 필요하다.     다음 포스팅엔 graphql 서비스 구현에 필요한 개념들을 정리하겠습니다.   ","categories": ["graphql"],
        "tags": [],
        "url": "/graphql/GQL-graphql_01/",
        "teaser": null
      },{
        "title": "[백준 17779] 게리맨더링 2",
        "excerpt":"[백준 17779] 게리맨더링 2   Algorithm: 시뮬레이션 Created: Apr 30, 2020 10:36 PM DoubleChk: No link: https://www.acmicpc.net/problem/17779   문제   재현시의 시장 구재현은 지난 몇 년간 게리맨더링을 통해서 자신의 당에게 유리하게 선거구를 획정했다. 견제할 권력이 없어진 구재현은 권력을 매우 부당하게 행사했고, 심지어는 시의 이름도 재현시로 변경했다. 이번 선거에서는 최대한 공평하게 선거구를 획정하려고 한다.   재현시는 크기가 N×N인 격자로 나타낼 수 있다. 격자의 각 칸은 구역을 의미하고, r행 c열에 있는 구역은 (r, c)로 나타낼 수 있다. 구역을 다섯 개의 선거구로 나눠야 하고, 각 구역은 다섯 선거구 중 하나에 포함되어야 한다. 선거구는 구역을 적어도 하나 포함해야 하고, 한 선거구에 포함되어 있는 구역은 모두 연결되어 있어야 한다. 구역 A에서 인접한 구역을 통해서 구역 B로 갈 수 있을 때, 두 구역은 연결되어 있다고 한다. 중간에 통하는 인접한 구역은 0개 이상이어야 하고, 모두 같은 선거구에 포함된 구역이어야 한다.   구역 (r, c)의 인구는 A[r][c]이고, 선거구의 인구는 선거구에 포함된 구역의 인구를 모두 합한 값이다. 선거구를 나누는 방법 중에서, 인구가 가장 많은 선거구와 가장 적은 선거구의 인구 차이의 최솟값을 구해보자.     #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;map&gt; #include &lt;string.h&gt; using namespace std; int N; int temp[21][21]; int arr[21][21]; void input(){     cin &gt;&gt; N;     for(int i=1; i&lt;=N; i++){         for(int j=1; j&lt;=N; j++){             cin &gt;&gt; arr[i][j];         }     } } int drawLine(int x, int y, int d1, int d2){      //5번 선거구     temp[x][y] = 5;     for(int i=1; i&lt;=d1; i++) temp[x+i][y-i] = 5;     for(int i=1; i&lt;=d2; i++) temp[x+i][y+i] = 5;     for(int i=1; i&lt;=d2; i++) temp[x+d1+i][y-d1+i] = 5;     for(int i=1; i&lt;=d1; i++) temp[x+d2+i][y+d2-i] = 5;      //나머지 선거구들     for(int i=1; i&lt;x+d1; i++){         for(int j=1; j&lt;=y; j++){             if(temp[i][j]) break;             temp[i][j] = 1;         }     }      for(int i = 1; i &lt;= x + d2; i++) {         for(int j = N; j &gt; y; j--) {             if(temp[i][j]) break;             temp[i][j] = 2;         }     }      for(int i=x+d1; i&lt;=N; i++){         for(int j=1; j&lt;y-d1+d2; j++){             if(temp[i][j]) break;             temp[i][j] = 3;         }     }      for(int i = x + d2 + 1; i &lt;= N; i++) {         for(int j = N; j &gt;= y - d1 + d2; j--) {             if(temp[i][j]) break;             temp[i][j] = 4;         }     }      int people[6] = {0, };      //인구 수 세기     for(int i=1; i&lt;=N; i++){         for(int j=1; j&lt;=N; j++){             people[temp[i][j]] += arr[i][j];         }     }     people[5] += people[0];      int min_cnt = 987654321;     int max_cnt = 0;      for(int i=1; i&lt;=5; i++){         min_cnt = min(min_cnt, people[i]);         max_cnt = max(max_cnt, people[i]);     }          return max_cnt - min_cnt; } void solve(){      int ans = 987654321;     for(int x=1; x&lt;=N-2;x++){         for(int y=1; y&lt;=N-1; y++){             for(int d1 =1; d1&lt;=y-1; d1++){                 for(int d2=1; d2&lt;=N-y; d2++){                     if(x+d1+d2 &lt;= N &amp;&amp; y-d1 &lt; y &amp;&amp; y+d2 &lt;= N){                         memset(temp, 0, sizeof(temp));                         ans = min(ans, drawLine(x, y, d1, d2));                     }                 }             }         }     }      cout &lt;&lt; ans &lt;&lt; endl;  } int main(){     input();     solve();     return 0; }      5번 선거 구역을 먼저 그려준다.   1~4번 구역을 채워준다.   인구 수를 세고, 답을 업데이트 한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-17779-%EA%B2%8C%EB%A6%AC%EB%A7%A8%EB%8D%94%EB%A7%81-2/",
        "teaser": null
      },{
        "title": "[프로그래머스] 방금 그곡",
        "excerpt":"[프로그래머스] 방금 그곡   Algorithm: 시뮬레이션 Created: Apr 30, 2020 7:27 PM DoubleChk: No link: https://programmers.co.kr/learn/courses/30/lessons/17683#   #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;map&gt; #include &lt;sstream&gt; using namespace std; typedef struct {     int time;     string name;     string music; } info; vector&lt;info&gt; infos; int getTime(string start, string end) {      vector&lt;int&gt; s, e;     istringstream is(start);     string buffer;     while (getline(is, buffer, ':'))     {         s.push_back(atoi(buffer.c_str()));     }      is.clear();     is.str(end);     while (getline(is, buffer, ':'))     {         e.push_back(atoi(buffer.c_str()));     }      int ret = 0;     ret += (e[0] * 60 + e[1]) - (s[0] * 60 + s[1]);     return ret; } string addAllNotes(int time, string str){      string ret = \"\";     if(time &gt; str.length()) time--;     for(int i=0; i&lt;=time; i++){         ret += str[i % str.length()];     }     return ret; } string removeSharp(string str) {     size_t pos = 0;     size_t offset = 0;      while ((pos = str.find(\"#\", offset)) != string::npos)     {         pos--;         char note = str[pos] - ('A' - 'a');         string replace = \"\";         replace += note;         str.replace(pos, 2, replace);         offset = pos + 1;     }     return str; }  string solution(string m, vector&lt;string&gt; musicinfos) {     m = removeSharp(m);     for (string music : musicinfos)     {         istringstream is(music);         string buffer;         vector&lt;string&gt; v;         while (getline(is, buffer, ','))         {             v.push_back(buffer);         }          int time = getTime(v[0], v[1]);         v[3] = addAllNotes(time, removeSharp(v[3]));         infos.push_back({time, v[2], v[3]});     }      int cnt = 0;     string answer = \"(None)\";     string::size_type n;     for (info cur : infos)     {         n = cur.music.find(m);         if((int)n &gt;= 0){             if(cnt &lt; cur.time){                 answer = cur.name;                 cnt = max(cnt, cur.time);                 continue;             }         }     }          return answer; } int main() {      string ans = solution(\"ABC\", {\"12:01,12:14,HELLO,C#DEFGAB\", \"13:00,13:05,WORLD,ABCDEF\"});      std::cout &lt;&lt; ans &lt;&lt; endl;      return 0; }      c++ 문자열 다루기 진짜 귀찮다..   #이 들어가 있는 모든 글자를 바꿔준다. (소문자로 바꿔줌)   m을 musicinfos에 있다면 답을 업데이트 해 준다. 이 때, cur.time으로 재생 시간을 비교 해 더 오래 틀어진 것으로 업데이트 해 준다.   27번 테스트 케이스가 계속 오류나서 getTime함수를 바꿔주니 됐다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%B0%A9%EA%B8%88-%EA%B7%B8%EA%B3%A1/",
        "teaser": null
      },{
        "title": "[프로그래머스] 호텔 방 배정",
        "excerpt":"[프로그래머스] 호텔 방 배정   Algorithm: 유니온파인드 Created: Apr 30, 2020 4:31 PM DoubleChk: No link: https://programmers.co.kr/learn/courses/30/lessons/64063   문제 설명   [본 문제는 정확성과 효율성 테스트 각각 점수가 있는 문제입니다.]   스노우타운에서 호텔을 운영하고 있는 스카피는 호텔에 투숙하려는 고객들에게 방을 배정하려 합니다. 호텔에는 방이 총 k개 있으며, 각각의 방은 1번부터 k번까지 번호로 구분하고 있습니다. 처음에는 모든 방이 비어 있으며 스카피는 다음과 같은 규칙에 따라 고객에게 방을 배정하려고 합니다.      한 번에 한 명씩 신청한 순서대로 방을 배정합니다.   고객은 투숙하기 원하는 방 번호를 제출합니다.   고객이 원하는 방이 비어 있다면 즉시 배정합니다.   고객이 원하는 방이 이미 배정되어 있으면 원하는 방보다 번호가 크면서 비어있는 방 중 가장 번호가 작은 방을 배정합니다.   예를 들어, 방이 총 10개이고, 고객들이 원하는 방 번호가 순서대로 [1, 3, 4, 1, 3, 1] 일 경우 다음과 같이 방을 배정받게 됩니다.   전체 방 개수 k와 고객들이 원하는 방 번호가 순서대로 들어있는 배열 room_number가 매개변수로 주어질 때, 각 고객에게 배정되는 방 번호를 순서대로 배열에 담아 return 하도록 solution 함수를 완성해주세요.   [제한사항]           k는 1 이상 10 이하인 자연수입니다.       12       room_number 배열의 크기는 1 이상 200,000 이하입니다.   room_number 배열 각 원소들의 값은 1 이상 k 이하인 자연수입니다.   room_number 배열은 모든 고객이 방을 배정받을 수 있는 경우만 입력으로 주어집니다.            예를 들어, k = 5, room_number = [5, 5] 와 같은 경우는 방을 배정받지 못하는 고객이 발생하므로 이런 경우는 입력으로 주어지지 않습니다.             [입출력 예]   Untitled   입출력 예에 대한 설명   입출력 예 #1   문제의 예시와 같습니다.   첫 번째 ~ 세 번째 고객까지는 원하는 방이 비어 있으므로 즉시 배정받을 수 있습니다. 네 번째 고객의 경우 1번 방을 배정받기를 원했는데, 1번 방은 빈 방이 아니므로, 1번 보다 번호가 크고 비어 있는 방 중에서 가장 번호가 작은 방을 배정해야 합니다. 1번 보다 번호가 크면서 비어있는 방은 [2번, 5번, 6번…] 방이며, 이중 가장 번호가 작은 방은 2번 방입니다. 따라서 네 번째 고객은 2번 방을 배정받습니다. 마찬가지로 5, 6번째 고객은 각각 5번, 6번 방을 배정받게 됩니다.     #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;map&gt; using namespace std; map&lt;long long, int&gt; m;  long long find_room(long long room){      if(!m[room]) return room;     return m[room] = find_room(m[room]); } vector&lt;long long&gt; solution(long long k, vector&lt;long long&gt; room_number){     vector&lt;long long&gt; answer;      for(long long room : room_number){         long long emptyRoom = find_room(room);         answer.push_back(emptyRoom);         m[emptyRoom] = emptyRoom + 1;     }     return answer; }      union-find로 푸는 문제   dfs, 이분탐색 모두 시간 초과가 난다.   find_room으로 빈 방을 찾는다. 요청한 방이 빈 방이면, 바로 return 한다.   찾은 방의 부모를 +1로 다음 칸으로 업데이트 해 준다.   빈 방이 아니면, 그 방의 부모를 dfs 돌린다. (m[room])   빈 방을 찾을 때까지 반복한다.   빈 방을 찾으면 +1로 업데이트 해 준다.   즉, m[room]은 다음 빈 방을 의미한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%ED%98%B8%ED%85%94-%EB%B0%A9-%EB%B0%B0%EC%A0%95/",
        "teaser": null
      },{
        "title": "[TIL] 자바스크립트 클로저",
        "excerpt":"클로저  함수와 함수가 선언된 어휘적 환경의 조합   function myClosure(){     var name = \"Sonia\";     function displayName(){         alert(name);     }     return displayName; }  var myFunc = myClosure(); //유효범위의 어휘적 환경을 유지 myFunc(); // 리턴된 displayName 함수 실행      클로저는 외부 함수가 끝난 이후에도 자유함수의 인자, 지역 변수 등에 접근 가능하다. =&gt; 자유 변수 (free variable)   이 자유 변수를 가지는 코드를 클로저라고 한다.   클로저가 생성 될 때 지역변수를 자유변수로 변환하는 것을 캡쳐(capture) 라고 한다.   private 접근 지정자와 비슷하다.  ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%81%B4%EB%A1%9C%EC%A0%80/",
        "teaser": null
      },{
        "title": "[프로그래머스] 뉴스 클러스터링",
        "excerpt":"#include &lt;string&gt; #include &lt;map&gt; #include &lt;vector&gt; using namespace std;  int solution(string str1, string str2) {     int answer = 0;      string clean_str1 = \"\";     string clean_str2 = \"\";      //둘 다 소문자로 바꾸고     for (char c : str1)         clean_str1 += tolower(c);      for (char c : str2)         clean_str2 += tolower(c);      //비교     map&lt;string, int&gt; m1;     map&lt;string, int&gt; m2;     vector&lt;string&gt; v1;     vector&lt;string&gt; v2;      for (int i = 0; i &lt; clean_str1.length() - 1; i++)     {         string tmp = \"\";                  if(isalpha(clean_str1[i]) &amp;&amp; isalpha(clean_str1[i+1])){             tmp += clean_str1[i];             tmp += clean_str1[i + 1];             v1.push_back(tmp);             m1[tmp]++;         }     }     for (int i = 0; i &lt; clean_str2.length() - 1; i++)     {         string tmp = \"\";         if(isalpha(clean_str2[i]) &amp;&amp; isalpha(clean_str2[i+1])){             tmp += clean_str2[i];             tmp += clean_str2[i + 1];             v2.push_back(tmp);             m2[tmp]++;         }     }       double cnt_inter = 0; //교집합     double cnt_union = 0; //합집합     int total_size = v1.size() + v2.size();     if(total_size == 0){         return 65536;     }     //합집합, 교집합 찾기     if (v1.size() &lt; v2.size())     {         for (int i = 0; i &lt; v2.size(); i++)         {             string cmp = v2[i];             if(m1[cmp]){                 if(m1[cmp] &lt; m2[cmp]){                     cnt_inter += m1[cmp];                     m1[cmp] = 0;                 }else{                     cnt_inter += m2[cmp];                     m2[cmp] = 0;                 }             }         }     }else{         for (int i = 0; i &lt; v1.size(); i++)         {             string cmp = v1[i];             if(m2[cmp]){                 if(m1[cmp] &lt; m2[cmp]){                     cnt_inter += m1[cmp];                     m1[cmp] = 0;                 }else{                     cnt_inter += m2[cmp];                     m2[cmp] = 0;                 }             }         }     }     cnt_union = total_size - cnt_inter;      double jacard = cnt_inter / cnt_union;     return jacard * 65536; }  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%89%B4%EC%8A%A4-%ED%81%B4%EB%9F%AC%EC%8A%A4%ED%84%B0%EB%A7%81/",
        "teaser": null
      },{
        "title": "[백준 15686] 치킨 배달",
        "excerpt":"[백준 15686] 치킨 배달   Algorithm: dfs, 시뮬레이션 Created: Apr 30, 2020 10:50 PM DoubleChk: No Type: 백준 link: https://www.acmicpc.net/problem/15686   문제   크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다.   이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은 ”치킨 거리“라는 말을 주로 사용한다. 치킨 거리는 집과 가장 가까운 치킨집 사이의 거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은 치킨 거리를 가지고 있다. 도시의 치킨 거리는 모든 집의 치킨 거리의 합이다.                  임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는       r1-r2       +       c1-c2       로 구한다.           예를 들어, 아래와 같은 지도를 갖는 도시를 살펴보자.   0 2 0 1 0 1 0 1 0 0 0 0 0 0 0 0 0 0 1 1 0 0 0 1 2    0은 빈 칸, 1은 집, 2는 치킨집이다.                  (2, 1)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는       2-1       +       1-2       = 2, (5, 5)에 있는 치킨집과의 거리는       2-5       +       1-5       = 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다.                          (5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는       5-1       +       4-2       = 6, (5, 5)에 있는 치킨집과의 거리는       5-5       +       4-5       = 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다.           이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다. 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는 치킨집의 개수는 최대 M개라는 사실을 알아내었다.   도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게 고르면, 도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성하시오.     #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;cstring&gt; #include &lt;queue&gt; #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;map&gt; #include &lt;string.h&gt; #include &lt;sstream&gt; ~~u~~sing namespace std; int N, M; int city[51][51]; vector &lt;pair&lt;int, int&gt;&gt; chicken; // 치킨집의 위치 vector &lt;pair&lt;int, int&gt;&gt; house; //집의 위치 int ans = 987654321;  //치킨 거리 : 집과 가장 '가까운' 치킨집과의 거리 //치킨 집을 최대 M개를 골라서 =&gt; 조합 (dfs) //거리를 센다 //치킨 거리의 최솟값을 리턴  void input(){     cin &gt;&gt; N &gt;&gt; M;     for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;N; j++){             cin &gt;&gt; city[i][j];             if(city[i][j] == 2){                 chicken.push_back({i, j});             }             if(city[i][j] == 1){                 house.push_back({i, j});             }         }     } }  void select_chicken(int idx, vector &lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&amp; selected, vector &lt;pair&lt;int, int&gt;&gt;&amp; candidates){     if(candidates.size()&gt; M ||candidates.size() &gt; chicken.size()){         return;     }     if(!candidates.empty())         selected.push_back(candidates);      for(int i=idx; i&lt;chicken.size(); i++){         candidates.push_back(chicken[i]);         select_chicken(i+1, selected, candidates);         candidates.pop_back();     } }  void solve(){     vector &lt;vector&lt;pair&lt;int, int&gt;&gt;&gt; selected;     vector &lt;pair&lt;int, int&gt;&gt; candidates;     //없앨 치킨집을 최대 M개 까지 고른다     select_chicken(0, selected, candidates);      for(int i=0; i&lt;selected.size(); i++){ //경우의 수만큼                  int chicken_dist = 0;         //거리 계산         for(int j=0; j&lt;house.size(); j++){             int dist = 987654321;             int house_x = house[j].first;             int house_y = house[j].second;              for(int k=0; k&lt;selected[i].size(); k++){                 int calc = abs(house_x - selected[i][k].first) + abs(house_y - selected[i][k].second);                 dist = min(dist, calc);             }             chicken_dist += dist;         }          ans = min(ans, chicken_dist);     }  } int main() {     input();          solve();     cout &lt;&lt; ans &lt;&lt; endl;     return 0; }  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-15686-%EC%B9%98%ED%82%A8-%EB%B0%B0%EB%8B%AC/",
        "teaser": null
      },{
        "title": "[프로그래머스] 오픈채팅방",
        "excerpt":"기존 코드   #include &lt;string&gt; #include &lt;vector&gt; #include &lt;map&gt; #include &lt;sstream&gt;  using namespace std;  vector&lt;string&gt; solution(vector&lt;string&gt; record) {     vector&lt;string&gt; answer;      vector&lt;vector &lt;string&gt;&gt;order;      for(string cur : record){         istringstream ss(cur);         string buffer = \"\";         vector &lt;string&gt; save;         while (getline(ss, buffer, ' ')){             save.push_back(buffer);         }         order.push_back(save);     }      map &lt;string, string&gt; chat; //uid, 닉네임     for(vector &lt;string&gt; cur : order){         string act = cur[0];         string uid = cur[1];         string nickname = cur[2];          if(act == \"Enter\"){             if(chat[uid] == nickname) continue; //이미 존재             chat[uid] = nickname;         }else if(act == \"Change\"){             chat[uid] = nickname;         }     }      for(vector &lt;string&gt; cur : order){         string act = cur[0];         string uid = cur[1];          if(act == \"Enter\"){             answer.push_back(chat[uid] + \"님이 들어왔습니다.\");         }else if(act == \"Leave\"){ //leave             answer.push_back(chat[uid] + \"님이 나갔습니다.\");         }     }     return answer; }      C++ exception with description “basic_string::_M_construct null not valid” thrown in the test body.       이런 오류가 났음..   벡터 iterating 하는 부분에서 오류가 생겼다.   구글링 해보니 dangaling reference 때문이라고 한다.   #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;string&gt; #include &lt;map&gt; #include &lt;sstream&gt; using namespace std; vector&lt;string&gt; solution(vector&lt;string&gt; record) {     vector&lt;string&gt; answer;      vector&lt;vector&lt;string&gt;&gt; orders;      for (string cur : record)     {         istringstream ss(cur);         string buffer = \"\";         vector&lt;string&gt; save;         while (getline(ss, buffer, ' '))             save.push_back(buffer);                      orders.push_back(save);     }      map&lt;string, string&gt; chat; //uid, 닉네임      for (vector &lt;string&gt; order : orders)     {         if (order[0] == \"Enter\" || order[0] == \"Change\")             chat[order[1]] = order[2];     }      for (vector&lt;string&gt; order : orders)     {         string act = order[0];         string uid = order[1];          if (act == \"Enter\")             answer.push_back(chat[uid] + \"님이 들어왔습니다.\");         else if (act == \"Leave\")             answer.push_back(chat[uid] + \"님이 나갔습니다.\");     }      return answer; } int main() {     vector&lt;string&gt; ans = solution({\"Enter uid1234 Muzi\",                                    \"Enter uid4567 Prodo\", \"Leave uid1234\", \"Enter uid1234 Prodo\", \"Change uid4567 Ryan\"});      for (auto c : ans)     {         cout &lt;&lt; c &lt;&lt; endl;     }     return 0; }      바꾼 코드. 잘 돌아간다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%98%A4%ED%94%88%EC%B1%84%ED%8C%85%EB%B0%A9/",
        "teaser": null
      },{
        "title": "[백준 3055] 탈출",
        "excerpt":"[백준 3055] 탈출  문제 링크  #include \"header.h\" using namespace std; int r, c; char board[51][51]; int water_day[51][51]; int days[51][51]; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; queue&lt;pair&lt;int, int&gt;&gt; water_q; queue&lt;pair&lt;int, int&gt;&gt; q; pair&lt;int, int&gt; bieber; void input() {     cin &gt;&gt; r &gt;&gt; c;     for (int i = 0; i &lt; r; i++)     {         for (int j = 0; j &lt; c; j++)         {             cin &gt;&gt; board[i][j];             if (board[i][j] == 'S')             {                 q.push({i, j});             }             if (board[i][j] == '*')                 water_q.push({i, j});             if (board[i][j] == 'D')                 bieber = {i, j};         }     } } void get_water() {     while (!water_q.empty())     {         int x = water_q.front().first;         int y = water_q.front().second;         water_q.pop();          for (int j = 0; j &lt; 4; j++)         {             int nx = x + dx[j];             int ny = y + dy[j];              if (nx &gt;= r || nx &lt; 0 || ny &gt;= c || ny &lt; 0)                 continue;              if (board[nx][ny] == '.' &amp;&amp; water_day[nx][ny] == 0)             {                 //물 채우기                 water_day[nx][ny] = water_day[x][y] + 1;                 water_q.push({nx, ny});             }         }     } } void move_hedgehog() {     int cnt = 0;      while (!q.empty())     {         int x = q.front().first;         int y = q.front().second;         q.pop();          for (int i = 0; i &lt; 4; i++)         {             int nx = x + dx[i];             int ny = y + dy[i];              if (nx &gt;= r || nx &lt; 0 || ny &gt;= c || ny &lt; 0)                 continue;             if (days[nx][ny] == 0 &amp;&amp; (board[nx][ny] == '.' || board[nx][ny] == 'D'))             {                 if (water_day[nx][ny] == 0 || water_day[nx][ny] &gt; days[x][y] + 1)                 {                     days[nx][ny] = days[x][y] + 1;                     q.push(make_pair(nx, ny));                 }             }         }     } } void solve() {     get_water();     move_hedgehog();      if (days[bieber.first][bieber.second] != 0)     {         cout &lt;&lt; days[bieber.first][bieber.second];     }     else     {         cout &lt;&lt; \"KAKTUS\";     } } int main() {     input();     solve();     return 0; }      시뮬레이션 + bfs 문제.   bieber(이제 찾아보니 beaver가 맞다..ㅋㅋㅋㅋㅋㅋㅋㅋㅋ)가 아닌 r-1, c-1을 출력해서 계속해서 틀렸다고 나왔다. 어이없는 실수..   물을 하루씩 늘려주면서 언제 채워지는지 bfs로 저장 해 주고,   고슴도치를 움직일 때마다 저장된 물과 비교해주면서, 다음날 물이 채워지지 않는 곳만 탐색한다.   water_days가 0일 경우 -&gt; 물이 침범하지 못하는 곳이거나, 답이기 때문에 넣어줘야 한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-3055-%ED%83%88%EC%B6%9C/",
        "teaser": null
      },{
        "title": "[백준 17144] 미세먼지 안녕!",
        "excerpt":"[백준 17144] 미세먼지 안녕!  문제 링크   #include \"header.h\" using namespace std; //1.5h  int r, c, T; int room[51][51]; int temp_room[51][51]; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; queue&lt;pair&lt;int, int&gt;&gt; dust; vector&lt;pair&lt;int, int&gt;&gt; robot; void input() {     cin &gt;&gt; r &gt;&gt; c &gt;&gt; T;     for (int i = 0; i &lt; r; i++)     {         for (int j = 0; j &lt; c; j++)         {             cin &gt;&gt; room[i][j];             if (room[i][j]){                 if (room[i][j] == -1) robot.push_back({i, j});                 else dust.push({i, j});             }         }     } } void spreadDust() {     memset(temp_room, 0, sizeof(temp_room));      while (!dust.empty())     {         int top_x = dust.front().first;         int top_y = dust.front().second;         dust.pop();          int cnt_spread = 0;         int spread_amount = room[top_x][top_y] / 5;         for (int i = 0; i &lt; 4; i++)         {             int nx = top_x + dx[i];             int ny = top_y + dy[i];              if (room[nx][ny] == -1 || nx &lt; 0 || ny &lt; 0 || nx &gt;= r || ny &gt;= c)                 continue;             cnt_spread++;             temp_room[nx][ny] += spread_amount;         }         temp_room[top_x][top_y] += room[top_x][top_y] - (spread_amount * cnt_spread);     }      memcpy(room, temp_room, sizeof(room)); } void cleanDust() {     pair&lt;int, int&gt; upperWind = robot[0];     pair&lt;int, int&gt; underWind = robot[1];     memset(temp_room, 0, sizeof(temp_room));      //upper     int x = upperWind.first;     int y = upperWind.second;      for (int i = x - 1; i &gt; 0; i--) temp_room[i][0] = room[i - 1][0];     for (int i = 0; i &lt; c - 1; i++) temp_room[0][i] = room[0][i + 1];     for (int i = 1; i &lt;= x; i++) temp_room[i - 1][c - 1] = room[i][c - 1];     for (int i = c - 1; i &gt; 1; i--) temp_room[x][i] = room[x][i - 1];      //under     x = underWind.first;     y = underWind.second;      for (int i = x + 1; i &lt; r - 1; i++) temp_room[i][0] = room[i + 1][0];     for (int i = 0; i &lt; c - 1; i++) temp_room[r - 1][i] = room[r - 1][i + 1];     for (int i = r - 1; i &gt;= x; i--) temp_room[i][c - 1] = room[i - 1][c - 1];     for (int i = c - 1; i &gt; 1; i--) temp_room[x][i] = room[x][i - 1];       //공기청정기의 바람이 닿지 않는 곳     for(int i=1; i&lt;upperWind.first; i++){         for(int j=1; j&lt;c-1; j++){             temp_room[i][j] = room[i][j];         }     }      for(int i=underWind.first+1; i&lt;r-1; i++){         for(int j=1; j&lt;c-1; j++){             temp_room[i][j] = room[i][j];         }     }      memcpy(room, temp_room, sizeof(temp_room));  }  int addDust() {     int ret = 0;      for (int i = 0; i &lt; r; i++)     {         for (int j = 0; j &lt; c; j++)         {             if(room[i][j]&lt;=0) continue;             ret += room[i][j];         }     }      return ret; } void pushDust(){     while (!dust.empty()) dust.pop();          for(int i=0; i&lt;r; i++){         for(int j=0; j&lt;c; j++){             if(room[i][j] &gt;= 0) dust.push({i, j});         }     } } void solve() {     for (int i = 0; i &lt; T; i++)     {         spreadDust();         cleanDust();         pushDust();     }      cout &lt;&lt; addDust() &lt;&lt; endl; } int main() {     input();     solve();      return 0; }      간단한 구현문제. bfs로 풀었다.   공기 청정기를 돌릴 때 하드코딩으로 풀었는데, 시계방향과 반시계방향을 고려해서 푸는 방법도 있는 듯.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-%EB%AF%B8%EC%84%B8%EB%A8%BC%EC%A7%80-%EC%95%88%EB%85%95!/",
        "teaser": null
      },{
        "title": "[TIL] ECMA Script와 Babel",
        "excerpt":"   ES5, ES6 이런 용어들을 많이 봤는데, 실제로 무슨 의미인지 알지 못해서 정리한다.   ECMA Script     ECMA라는 정보 표준 제정 비영리기구가 있다.   Script 언어란 이렇게 돼야 해요, 라는 것을 지정한 것이다.   JavaScript     ECMA가 지정해놓은 표준에 따른 스크립트 언어이다.   JS엔진     Javascript를 이해하고 실행하는 프로그램, 또는 인터프리터   비교            performance (속도)       호환성 (ECMA를 얼마나 지원하는지)           그래서 ES5, ES6가 뭔데?     ECMA Script ver.   개정이 될 때마다 올라간다.   2015년부터 매년 개정되기 때문에 ES2017 이런식으로 명명될 것.   Babel?     웹 브라우저의 호환성 때문에 es 최신 기능을 사용할 수 없는 경우가 있음.   호환되지 않는 브라우저에서 구버전의 코드로 바꿔주는 기능을 하는 것이 Babel이다.        .babelrc에서 프로젝트에 사용할 버젼을 설정해줄 수 있다.       {   \"presets\": [\"env\", \"stage-3\"] }                 여기서 stage-3는 다음 후보가 될 것들을 말한다.   babel7부터는 @가 붙는다. ex) @babel/cli   ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-ECMA-Script%EC%99%80-Babel/",
        "teaser": null
      },{
        "title": "[TIL] 스로틀과 디바운스",
        "excerpt":"스로틀과 디바운싱     my real hotel 사이드 프로젝트 중 스로틀과 디바운싱에 대해서 공부하게 되었다. 스로틀과 디바운싱은 둘다 Javascript에서 양이 많은 이벤트를 제어하는 방법이다.   스크롤링과 같은 이벤트는 호출이 매우 많다. 한번 휠을 돌리는 것만으로도 20번 이상의 이벤트가 호출 될 수 있다.   이벤트 핸들러 내부의 기능이 중복적으로, 여러번 호출 될 수가 있다.   유료 API를 사용할 경우, 이런 많은 호출은 많은 비용으로 이어질 수 있다.     스로틀 (Throttle)     이벤트를 일정한 주기마다 발생하여 실행 횟수를 제어한다. -&gt; 정기적인 호출이 보장된다.   스로틀을 영어로 검색 해 보면 밸브의 한 종류가 나온다.            밸브처럼 잠금으로서 함수가 재호출 되지 않도록 제어한다.           이벤트의 성능 문제에서 많이 사용한다.        스크롤링의 예시가 대표적이다.            sample code       js코드      function throttle(fn, delay) {   let timer;   return function() {       if (!timer){ //타이머가 없다면 셋팅           timer = setTimeout(() =&gt; {               timer = null //타이머 초기화               fn.apply(this, arguments) //일정 시간 이후에 호출           }, delay)       }   }}             디바운스 (Debounce)     특정 시간 이후, 맨 마지막 이벤트(혹은 맨 처음)만 호출   자동완성의 예시가 대표적이다.            사용자가 입력하는 정보를 저장할 때, 모든 key stroke를 저장하게 되면 하나를 입력 할 때마다 핸들러가 호출이 된다.       ex)ㄱ 거 검 검ㅅ 검새 검색       따라서 key down 이벤트가 생기고 몇 초 이후에 저장하는 함수를 호출하면 횟수가 크게 줄어들 것이다.                sample code       리액트 코드        const [debouncedValue, setDebouncedValue] = useState(value);    useEffect(() =&gt; {     // delay 이후에 value 업데이트     const handler = setTimeout(() =&gt; {       setDebouncedValue(value);     }, delay);      // 값이 바뀌면 타임아웃 재설정     return () =&gt; {       clearTimeout(handler);     };   },[value, delay] // value나 delay가 변경 되는 경우에만 호출   );           js 코드      function debounce(fn, delay) {   let timer;   return function() {       clearTimeout(timer); //호출 될때마다 타이머 초기화       timer = setTimeout(() =&gt; {           fn.apply(this, arguments); //일정 시간 이후 호출       }, delay);   } }          ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-%EC%8A%A4%EB%A1%9C%ED%8B%80%EA%B3%BC-%EB%94%94%EB%B0%94%EC%9A%B4%EC%8B%B1/",
        "teaser": null
      },{
        "title": "[백준 16235]나무 재테크",
        "excerpt":"[백준 16235]나무 재테크  문제 링크   #include \"header.h\" using namespace std; int n, m, k, ans; int nutrition[12][12]; int forest[12][12]; typedef struct {     int x; //위치     int y;     int z; //나이 } Tree; deque&lt;Tree&gt; tree[12][12]; void input() {     cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;     for (int i = 1; i &lt;= n; i++)     {         for (int j = 1; j &lt;= n; j++)         {             cin &gt;&gt; forest[i][j];             nutrition[i][j] = 5;         }     }      for (int i = 1; i &lt;= m; i++)     {         int x, y, z;         cin &gt;&gt; x &gt;&gt; y &gt;&gt; z;         tree[x][y].push_back({x, y, z});     } } vector &lt;Tree&gt; spring() {     vector &lt;Tree&gt; dead;     // 봄에는 나무가 자신의 나이만큼 양분을 먹고, 나이가 1 증가한다.     // 각각의 나무는 나무가 있는 1×1 크기의 칸에 있는 양분만 먹을 수 있다.     // 하나의 칸에 여러 개의 나무가 있다면, 나이가 어린 나무부터 양분을 먹는다.     // 만약, 땅에 양분이 부족해 자신의 나이만큼 양분을 먹을 수 없는 나무는 양분을 먹지 못하고 즉시 죽는다.     for (int i = 1; i &lt;= n; i++)     {         for (int j = 1; j &lt;= n; j++)         {             if (tree[i][j].size() &gt; 0)             {                 int size = tree[i][j].size();                 for (int k = 0; k &lt; size; k++)                 {                     Tree t = tree[i][j].front();                     tree[i][j].pop_front();                                          if(t.z &lt;= nutrition[i][j]){                         int age = t.z;                         nutrition[i][j] -= age;                         tree[i][j].push_back({i, j, age+1});                     }else if(t.z &gt; nutrition[i][j]){                         dead.push_back(t);                     }                 }             }         }     }     return dead; } void fall(){     //가을에는 나무가 번식한다.     //번식하는 나무는 나이가 5의 배수이어야 하며, 인접한 8개의 칸에 나이가 1인 나무가 생긴다.     //어떤 칸 (r, c)와 인접한 칸은 (r-1, c-1), (r-1, c), (r-1, c+1), (r, c-1), (r, c+1), (r+1, c-1),      //(r+1, c), (r+1, c+1) 이다.     //상도의 땅을 벗어나는 칸에는 나무가 생기지 않는다.     int dx[8] = {-1, -1, -1, 0, 0, 1, 1, 1};     int dy[8] = {-1, 0, 1, -1, 1, -1, 0, 1};     for (int i = 1; i &lt;= n; i++)     {         for (int j = 1; j &lt;= n; j++)         {             if (tree[i][j].size() &gt; 0)             {                 for(int k=0; k&lt;tree[i][j].size(); k++){                     if(tree[i][j][k].z % 5 == 0){                         for(int a=0; a&lt;8; a++){                             int nx = i + dx[a];                             int ny = j + dy[a];                              if(nx &gt; n || ny &gt; n || nx &lt;= 0 || ny &lt;= 0) continue;                                                          //새로운 나무                             tree[nx][ny].push_front({nx, ny, 1});                         }                     }                 }             }         }     }  } int winter(){     //겨울에는 S2D2가 땅을 돌아다니면서 땅에 양분을 추가한다.     //각 칸에 추가되는 양분의 양은 A[r][c]이고, 입력으로 주어진다.     int cnt=0;     for(int i=1; i&lt;=n; i++){         for(int j=1; j&lt;=n; j++){             if(tree[i][j].size() &gt; 0){                 cnt += tree[i][j].size();             }             nutrition[i][j] += forest[i][j];         }     }      return cnt;  } void summer(vector &lt;Tree&gt;&amp; dead){     for(int i=0; i&lt;dead.size(); i++){         int age = dead[i].z / 2;         int x = dead[i].x;         int y = dead[i].y;          nutrition[x][y] += age;     } } void solve() {     for(int i=0; i&lt;k; i++)     {         vector &lt;Tree&gt; dead = spring();         summer(dead);         fall();         ans = winter();     }          cout &lt;&lt; ans &lt;&lt; endl; } int main() {     ios_base :: sync_with_stdio(false);     cin.tie(NULL);     cout.tie(NULL);      input();     solve();     return 0; }      deque가 아닌 vector로 tree를 만들고, 봄이 올때마다 sorting을 해주니 시간초과가 났다.   새로운 나무가 심어지면 1로 심어져서, 가장 작은 나이이기 때문에 deque에 push_front()를 해준다.   spring에서 deque의 사이즈만큼 돌면서 죽은 나무는 vector에 넣어주고, 살아있는 나무는 push_back으로 계속 살려준다.   ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-16235-%EB%82%98%EB%AC%B4-%EC%9E%AC%ED%85%8C%ED%81%AC/",
        "teaser": null
      },{
        "title": "[백준 14891]톱니바퀴",
        "excerpt":"[백준 14891]톱니바퀴  문제 링크   #include \"header.h\" using namespace std; int k; vector &lt;pair&lt;int, int&gt;&gt; order; //톱니바퀴 번호, 방향 int gear[4][8]; int temp_gear[4][8];  void input(){     for(int i=0; i&lt;4; i++){         for(int j=0; j&lt;8; j++){             scanf(\"%1d\", &amp;gear[i][j]);         }     }      cin &gt;&gt; k;     for(int i=0; i&lt;k; i++){                int x, y;         cin &gt;&gt; x;         cin &gt;&gt; y;         order.push_back({x-1, y});     } } void counter_clockwise(int i){     temp_gear[i][7] = gear[i][0];     for(int j=7; j&gt;=1; j--){         temp_gear[i][j-1] = gear[i][j];     } } void clockwise(int i){     temp_gear[i][0] = gear[i][7];     for(int j=0; j&lt;7; j++){         temp_gear[i][j+1] = gear[i][j];     } } void copy(){     for(int i=0; i&lt;4; i++){         for(int j=0; j&lt;8; j++){             gear[i][j] = temp_gear[i][j];         }     } } void pre_work(int idx, int flag){     for(int i=idx-1; i&gt;=0; i--){             if(gear[i+1][6] == gear[i][2]){                 break; //같으면 더이상 돌아가지 않는다.             }else{                 //다르면 돌리기                 if(flag == 1){ // 이전에 시계 방향으로 돌렸으면                     //반시계 방향으로 돌아간다.                     counter_clockwise(i);                     flag = -1;                 }else{                     //시계 방향                     clockwise(i);                     flag = 1;                 }             }         } } void post_work(int idx, int flag){     for(int i=idx+1; i&lt;4; i++){             if(gear[i-1][2] == gear[i][6]){                 break;             }else{                 if(flag == 1){                     counter_clockwise(i);                     flag = -1;                 }else{                     clockwise(i);                     flag = 1;                 }             }         }  } void turn_gear(pair &lt;int, int&gt;&amp; turn){     int idx = turn.first; // 톱니바퀴 번호     int dir = turn.second; // 방향     // 첫 번째 정수는 회전시킨 톱니바퀴의 번호, 두 번째 정수는 방향이다.     int flag = dir;     if(dir == 1){ //시계 방향          pre_work(idx, flag); //1번 ~ 돌린 톱니바퀴 - 1         flag = dir;         post_work(idx, flag); //돌린 톱니바퀴 + 1 ~ 끝까지         clockwise(idx); //해당 톱니바퀴 돌리기         //복사         copy();      }else{          pre_work(idx, flag);         flag = dir;         post_work(idx, flag);         counter_clockwise(idx);          copy();     }      } int count_all(){     int ret = 0;      gear[0][0] == 0 ? ret += 0 : ret += 1;     gear[1][0] == 0 ? ret += 0 : ret += 2;     gear[2][0] == 0 ? ret += 0 : ret += 4;     gear[3][0] == 0 ? ret += 0 : ret += 8;      return ret; } void solve(){     memcpy(temp_gear, gear, sizeof(gear));      for(int i=0; i&lt;k; i++){         pair&lt;int, int&gt; turn = order[i];         turn_gear(turn);     }      int ans = count_all();     cout &lt;&lt; ans &lt;&lt; endl; } int main() {     // ios_base ::sync_with_stdio(false);     // cin.tie(NULL);     // cout.tie(NULL);      input();     solve();          return 0; }  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-14891-%ED%86%B1%EB%8B%88%EB%B0%94%ED%80%B4/",
        "teaser": null
      },{
        "title": "[프로그래머스] 모의고사",
        "excerpt":"[프로그래머스] 모의고사  문제 링크    #include \"header.h\" using namespace std; vector &lt;vector&lt;int&gt;&gt; supo = {{1, 2, 3, 4, 5}, {2, 1, 2, 3, 2, 4, 2, 5}, {3, 3, 1, 1, 2, 2, 4, 4, 5, 5}}; int sz[3] = {5, 8, 10}; vector&lt;int&gt; solution(vector&lt;int&gt; answers) {     vector&lt;int&gt; answer;     vector &lt;int&gt; score(3);     int max_score = 0;          for(int i=0; i&lt;answers.size(); i++){         for(int j=0; j&lt;3; j++){             if(answers[i] == supo[j][i % sz[j]]){                 score[j]++;                 max_score = max(max_score, score[j]);             }         }     }          for(int i=0; i&lt;3; i++){         if(score[i] == max_score){             answer.push_back(i+1);         }     }     for(auto a : score){         cout &lt;&lt; a;     }     cout &lt;&lt; endl;     sort(answer.begin(), answer.end());          return answer; }  int main(){     vector &lt;int&gt;ans = solution({1,3,2,4,2});     cout &lt;&lt; \"ans\" &lt;&lt; endl;     for(auto a : ans){         cout &lt;&lt; a &lt;&lt; endl;     }     return 0; }       수포자가 3명 밖에 없기 때문에 미리 벡터로 선언 해 주었다.   계속해서 같은 번호로 찍기 때문에 첫 번째 반복문에서 모듈화 연산을 통해 answer의 크기만큼 반복할 수 있도록 해주었다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%AA%A8%EC%9D%98%EA%B3%A0%EC%82%AC/",
        "teaser": null
      },{
        "title": "[TIL] 프로세스와 스레드",
        "excerpt":"프로세스     운영체제로부터 할당 받은 자원을 사용하는 작업의 단위   실행되는 프로그램 자체와 그 주변환경을 뜻함.            사용중인 파일, 데이터, 메모리 주소공간 등           프로세스는 서로 독립적이다.   한 프로세스가 다른 프로세스의 자원에 접근하려면 파이프 통신, 소켓 통신 등을 사용해야 한다.   스레드     프로세스가 할당 받은 자원을 사용하는 실행의 단위   스레드는 프로세스 내에서 stack만 할당 받고, code, data, heap은 공유한다.   멀티 프로세스     하나의 응용 프로그램을 여러개의 프로세스가 작업   장점            서로 독립적이어서 하나의 프로세스에 문제가 생기더라도 다른 프로세스에 오류가 확장되지 않는다.           단점            Context Switching에서의 오버헤드       프로세스간 통신 기법이 복잡하다.           멀티 스레드     하나의 프로세스를 여러 개의 스레드가 작업   웹 서버, 윈도우, 리눅스 등   장점            자원의 효율적인 사용       처리 비용 감소       간단한 통신 문제           단점            설계의 복잡성       디버깅이 까다로움       단일 프로세스의 경우 효과 미미       동기화 문제       오류 발생 시 다른 스레드에도 영향       다른 프로세스에서 스레드를 제어할 수 없다.           멀티 스레드를 사용하는 이유?     멀티 프로세스를 사용하게 되면, 프로세스를 생성하며 생기는 시스템 콜이 추가된다.   멀티 스레드를 사용하면 이 시스템 콜을 하지 않아 자원을 절약할 수 있다.   프로세스간의 통신보다 스레드간의 통신이 더 비용이 적기 때문에 부담이 줄어들게 된다.   하지만 프로세스 내부의 자원을 전역 변수로 여러 스레드가 접근하기 때문에 동기화 문제를 신경 써야 한다.  ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%99%80-%EC%8A%A4%EB%A0%88%EB%93%9C/",
        "teaser": null
      },{
        "title": "[백준 6064]카잉 달력",
        "excerpt":"[백준 6064]카잉 달력  문제 링크   #include \"header.h\" using namespace std; int T;  int gcd(int a, int b){     if(a % b == 0) return b;      return gcd(b, a % b); }  int lcm(int a, int b){     return a * b / gcd(a, b); }  int main(){      cin &gt;&gt; T;      for(int i=0; i&lt;T; i++){         int M, N, x, y;         cin &gt;&gt; M &gt;&gt; N &gt;&gt; x &gt;&gt; y;          int limit = lcm(M, N);         int j = x;         for(j=x; j&lt;=limit; j+=M){             int y_temp = j % N;             if(y_temp == 0) y_temp = N;             if(y_temp == y){                 cout &lt;&lt; j &lt;&lt; endl;                 break;             }         }         if(j &gt;= limit){             cout &lt;&lt; -1 &lt;&lt; endl;         }      }      return 0; }      N과 M의 최소공배수가 지구 멸망의 달이다.   최소 공배수를 구하려면 최대 공약수를 알아야 한다. (유클리드 호제법)   x가 M이 될 때 마다 +1이 되기 때문에, x를 기준으로 한다.   기준이 되는 x에서 % N을 한 것이 y가 된다.   y가 입력으로 주어진 y가 되면 break를 해 준다.   이 때, y가 0이 되면, N으로 초기화를 시켜주어야 한다.   limit를 초과하게 되면, -1을 출력시켜준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-6064-%EC%B9%B4%EC%9E%89-%EB%8B%AC%EB%A0%A5/",
        "teaser": null
      },{
        "title": "[백준 1107] 리모컨",
        "excerpt":"[백준 1107] 리모컨  문제 링크   #include \"header.h\" using namespace std; int N, M; int broken[10];  int check(int num){     int cnt = 0;     //맨 처음, 0이 고장 났다면 0, 고장나지 않았다면 1     if(num == 0) {         if(broken[0]){             return 0;         }else{             return 1;         }     }      while(num){         int n = num % 10;         if(broken[n]) return 0; // 누를 수 없다면 return 0;         num /= 10;         cnt++;     }     return cnt; } int main(){          cin &gt;&gt; N;     cin &gt;&gt; M;     int start = 100;      if(start == N){         cout &lt;&lt; 0 &lt;&lt; endl;         return 0;     }      for(int i=0; i&lt;M; i++){         int n;         cin &gt;&gt; n;         broken[n] = 1;     }      //-- 입력 끝      int ans = abs(N - start); // 100에서 +1, -1씩 한 것 (최악의 경우)      // 0 ~ 1000000 까지 돌면서 제일 적게 버튼을 누른 횟수를 찾는다.     for(int i=0; i&lt;=1000000; i++){         int cmp = check(i); // 자릿수 찾기 (고장난 번호가 있으면 0)         if(cmp){             int press = abs(N - i) + cmp; // + 혹은 -를 누른 수 + 해당 숫자의 자릿수             ans = min(ans, press); // 업데이트         }     }      cout &lt;&lt; ans &lt;&lt; endl;      return 0; }  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1107-%EB%A6%AC%EB%AA%A8%EC%BB%A8/",
        "teaser": null
      },{
        "title": "[프로그래머스] 단속카메라",
        "excerpt":"[프로그래머스] 단속카메라  문제 링크   #include &lt;string&gt; #include &lt;algorithm&gt; #include &lt;vector&gt;  using namespace std; int solution(vector&lt;vector&lt;int&gt;&gt; routes) {     int answer = 1;     sort(routes.begin(), routes.end());     int n = routes.size();      int start = routes[0][0];     int end = routes[0][1];     for(int i=1; i&lt;n; i++){         if(start &lt;= routes[i][0] &amp;&amp; routes[i][0] &lt;= end){             start = max(start, routes[i][0]);             end = min(end, routes[i][1]);         }else{             start = routes[i][0];             end = routes[i][1];             answer++;         }     }     return answer; }       가장 많이 겹치는 범위를 update를 해주면 된다.   범위는 start, end로 결정한다. answer의 초깃값을 1로 설정해준다.   들어온 지점의 순서대로 sorting을 해 준다.   차의 갯수만큼 반복문을 돌면서, 들어온 차가 범위 안에 있으면 범위를 update 해 주고,   아니라면 범위를 해당 차로 초기화 시켜준 후 새로운 차를 기준으로 반복문을 진행한다. (그리고 감시카메라를 +1 한다.)    ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%8B%A8%EC%86%8D%EC%B9%B4%EB%A9%94%EB%9D%BC/",
        "teaser": null
      },{
        "title": "[프로그래머스] 배달",
        "excerpt":"[프로그래머스] 배달  문제 링크   #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;queue&gt; #define INF 987654321 using namespace std;  vector&lt;pair&lt;int, int&gt;&gt; edge[51]; int result[51]; void dijkstra(int start){     result[start] = 0;          //min_heap -&gt; 거리가 가까운 순서대로 정렬됨     priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;     pq.push(make_pair(0, start));      while(!pq.empty()){         int here = pq.top().second;         int cost = pq.top().first;         pq.pop();          //인접 노드들 탐색         for(int i=0; i&lt;edge[here].size(); i++){             int there = edge[here][i].first;             int dist = edge[here][i].second + cost;              //최단 경로가 가능하다면 업데이트             if(dist &lt; result[there]){                 result[there] = dist;                 pq.push({dist, there});             }         }     } }  int solution(int N, vector&lt;vector&lt;int&gt; &gt; road, int K) {     int answer = 0;      for(int i = 1; i &lt;= N; i++){         result[i] = INF;     }      for(int i = 0; i &lt; road.size(); i++){         edge[road[i][0]].push_back(make_pair(road[i][1], road[i][2]));         edge[road[i][1]].push_back(make_pair(road[i][0], road[i][2]));     }      dijkstra(1);      for(int i = 1;  i &lt;= N; i++){         if(result[i] &lt;= K){             answer++;         }     }     return answer; }       다익스트라구나 라고 생각하고 풀었는데 구현을 못해서 답을 봤다..ㅎ   min heap으로 구현 시 first값을 기준으로 정렬로 알고 있는데, 테스트케이스가 모두 거리가 가까운 순서대로 정렬이 돼 있는지 pq.push(make_pair(인덱스, 거리));로 해도 답이 나온다.   데이터 갯수가 더 많거나 시간이 빡빡할 시에는 시간 초과 날 것 같다. 방문 처리로 똑같은 노드를 방문하지 않도록 해야겠다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%B0%B0%EB%8B%AC/",
        "teaser": null
      },{
        "title": "[TIL] 스크롤 시 이미지 로딩",
        "excerpt":"[TIL] 스크롤 시 이미지 로딩          Javascript 30에서 자주 쓸 것 같은 기능이 있길래 따로 포스팅 한다.   JS 코드  function checkSlide(e) {       sliderImages.forEach((img) =&gt; {         //window.scrollY + window.innerHeight =&gt; 현재 화면 제일 밑         const slideInAt = (window.scrollY + window.innerHeight) - img.height / 2;                  // img.offsetTop =&gt; 화면의 맨 위에서 이미지의 최상단까지의 거리         const imageBottom = img.offsetTop + img.height;          const isHalfShown = slideInAt &gt; img.offsetTop;          const isNotScrolledPast = window.scrollY &lt; imageBottom;                  if (isHalfShown &amp;&amp; isNotScrolledPast) {           img.classList.add('active');         } else {           img.classList.remove('active');         }       })     }         스크롤이 이미지 높이의 반을 지났을 때, 이미지를 fade-in 하는 기능이다.   window.scrollY + window.innerHeight는 현재 화면의 최하단이다.   여기에 img.height / 2를 빼주면, 최하단에서 이미지의 반정도 위이다. 즉 slideInAt이 된다.   slideInAt이 img.offsetTop보다 클 때, 즉 현재 화면이 img.offsetTop에서 반 이상 내려갔을 때 이미지에 'active' 클래스를 넣어준다.   function debounce(fn, delay = 20) {     let timer;     return function () {         clearTimeout(timer); //호출 될때마다 타이머 초기화         timer = setTimeout(() =&gt; {           console.log(arguments);           fn.apply(this, arguments); //일정 시간 이후 호출         }, delay);     } }  window.addEventListener('scroll', debounce(checkSlide));      스크롤 이벤트는 호출이 많기 때문에 debounce로 조절 해 주어야 한다.   참고   CSS 코드  .slide-in {     opacity: 0;     transition: all .5s; } .align-left.slide-in {     transform: translateX(-30%) scale(0.95); }  .align-right.slide-in {     transform: translateX(30%) scale(0.95); } .slide-in.active {     opacity: 1;     transform: translateX(0%) scale(1); }      .slide-in에서 opacity 0으로 투명하게 만든다.   .align-right, .align-left로 사진을 왼쪽, 오른쪽으로 30%이동 해 놓고 사이즈를 살짝 줄인다   slide-in.active가 되면 투명도가 1로 변하고, 제자리로 돌아오면서, 사이즈가 1로 다시 돌아오게 된다.   ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-%EC%8A%A4%ED%81%AC%EB%A1%A4-%EC%8B%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A1%9C%EB%94%A9/",
        "teaser": null
      },{
        "title": "[프로그래머스] 멀쩡한 사각형",
        "excerpt":"[프로그래머스] 멀쩡한 사각형  문제 링크   #include &lt;algorithm&gt; using namespace std;  long long GCD(long long a, long long b){     if(a % b == 0) return b;     return GCD(b, a % b); } long long solution(int w, int h) {     long long new_w = w;     long long new_h = h;     long long answer = 1;     long long total = new_w * new_h;      if(new_w == new_h){         answer = new_w;     }else{         answer = (new_w + new_h - GCD(new_w, new_h));     }      return total - answer; }      맨 처음엔 모든 반례를 제거 하려고 했지만, 예외처리가 잘 되지 않았다..   검색 해 보니 사각형을 지나는 대각선의 갯수를 구하는 공식이 있었다.   w+h - gcd(w, h)이다.   기억 해 놓기!!!  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%A9%80%EC%A9%A1%ED%95%9C-%EC%82%AC%EA%B0%81%ED%98%95/",
        "teaser": null
      },{
        "title": "[프로그래머스] 스킬트리",
        "excerpt":"[프로그래머스] 스킬트리  문제 링크   #include \"header.h\" using namespace std; map &lt;char, int&gt; m; int solution(string skill, vector&lt;string&gt; skill_trees) {     int answer = 0;     int idx = 0;      for(int i=0; i&lt;skill.size(); i++) {         skill[i] = toupper(skill[i]);         m[skill[i]]++;     }      for(int i=0; i&lt;skill_trees.size(); i++){         idx = 0;         int flag = 1;         for(int j=0; j&lt;skill_trees[i].size(); j++){             if(m[skill_trees[i][j]]){ //스킬트리에 존재하는 스킬이라면                 if(skill_trees[i][j] != skill[idx]){ //순서가 안맞으면                     flag = 0;                     break;                 }else{                     idx++;                 }             }         }         if(flag) answer++;     }      return answer; }     스킬트리를 대문자로 초기화 해주고, 맵에 저장한다.   맵으로 스킬트리에 존재하는 스킬인지 확인을 하고,   존재한다면 순서가 맞는지 확인한다.   순서가 안맞으면 flag를 false로 변경 후 break 해 준다.   아니라면 스킬트리의 인덱스를 +1 해 준다.   flag가 true 인 경우에만 ans++ 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%8A%A4%ED%82%AC%ED%8A%B8%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[TIL] resolve in programming",
        "excerpt":"[TIL] resolve in programming     resolver, resolve packages 등 resolve라는 단어가 자주 나오는데, 어떤 의미인지 명확하게 몰라서 구글링을 해 봤다.   Transforming     represent something in another format   어떤 것을 다른 형식으로 표현하는 것이다.   ex) 10진수 -&gt; 6진수   정해진 rule에 따라 변환   Resolving     Resolve를 사전에 검색 해 보면, find a answer or a solution to something이라고 나온다.   어떤 것의 답이나 해결책을 찾는 것, 이라는 의미이다.   determine what it is 그것이 어떤 것인지 정의하는 것이다.   ex) google.com을 검색하게 되면 Ip address가 쿼리 되는데, 이것은 매번 똑같은 게 아니라 바뀔 수도 있다.   ex) resolve package dependencies의 의미는 missing 패키지를 설치하는 것이다. 이 때 설치 되지 않은 것들의 이름이 아닌, contents에 접근하여 설치 하는 것이다. 이 때 contents들은 not predictable(예상 불가능)하다.   즉, resolve는 name만으로는 알 수 없는, name에 관련된 repository나 contents에 접근하여 target을 재정의하는 것이라고 말할 수 있다.  ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-resolve-in-programming/",
        "teaser": null
      },{
        "title": "[백준 3184] 양",
        "excerpt":"[백준 3184] 양  문제 링크   #include \"header.h\" using namespace std; int R, C; //'.' 빈 필드 //'#' 울타리 //'o' 양 //'v' 늑대 int ans_wolf, ans_sheep; char fence[251][251]; int visit[251][251]; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; void input(){     cin &gt;&gt; R &gt;&gt; C;      for(int i=0; i&lt;R; i++){         for(int j=0; j&lt;C; j++){             cin &gt;&gt; fence[i][j];         }     } } void bfs(int x, int y){     queue &lt;pair&lt;int, int&gt;&gt; q;     visit[x][y] = 1;     q.push({x, y});      int sheep = 0;     int wolf = 0;      if(fence[x][y] == 'o') sheep++;     if(fence[x][y] == 'v') wolf++;      while(!q.empty()){         int top_x = q.front().first;         int top_y = q.front().second;         q.pop();          for(int i=0; i&lt;4; i++){             int nx = top_x + dx[i];             int ny = top_y + dy[i];              if(visit[nx][ny] || fence[nx][ny] == '#' || nx &lt; 0 || ny &lt; 0 || nx &gt;= R || ny &gt;= C) continue;              if(fence[nx][ny] == 'o') sheep++;             if(fence[nx][ny] == 'v') wolf++;              q.push({nx, ny});             visit[nx][ny] = 1;         }     }      // 영역 안의 양의 수가 늑대의 수보다 많다면 이기게 된다. 그렇지 않다면 늑대가 그 지역 안의 모든 양을 먹는다.     // 살아남은 양과 늑대의 수를 출력하는 프로그램을 작성하라.      if(wolf &gt;= sheep){         ans_wolf += wolf;     }else ans_sheep += sheep;  } void solve(){      for(int i=0; i&lt;R; i++){         for(int j=0; j&lt;C; j++){             if(fence[i][j] != '#' &amp;&amp; !visit[i][j]){                 bfs(i, j);             }         }     } }  int main() {     input();     solve();      cout &lt;&lt; ans_sheep &lt;&lt; ' ' &lt;&lt; ans_wolf &lt;&lt; endl;     return 0; }      1년 전에 못 풀었는데 이젠 풀 수 있다!! :D   전체를 돌면서 방문하지 않았고, 울타리가 아닌 경우에 bfs를 돌아 준다.   bfs 내부에서 양과 늑대의 수를 세고,   큐가 비었을 때 (범위 탐색이 끝났을 때) 비교 해주어 답을 갱신한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-3184-%EC%96%91/",
        "teaser": null
      },{
        "title": "[백준 1726] 로봇",
        "excerpt":"[백준 1726] 로봇  문제 링크   #include \"header.h\" using namespace std; int N, M; int room[101][101]; int visit[101][101][5]; //1동 2서 3남 4북 int dx[5] = {0, 0, 0, 1, -1}; int dy[5] = {0, 1, -1, 0, 0};  typedef struct{     int x;     int y;     int d;     int cnt; }st; st robot; st destination;  void input(){     cin &gt;&gt; N &gt;&gt; M;     for(int i=1; i&lt;=N; i++){         for(int j=1; j&lt;=M; j++){             cin &gt;&gt; room[i][j];         }     }      int x, y, d;     cin &gt;&gt; x &gt;&gt; y &gt;&gt; d;     robot = {x, y, d, 0};      cin &gt;&gt; x &gt;&gt; y &gt;&gt; d;     destination = {x, y, d, 0};  } int check(int x, int y){     if((x == 1 || x == 2) &amp;&amp; (y == 1 || y == 2)) return 1;     if((x == 3 || x == 4) &amp;&amp; (y == 3 || y == 4)) return 1;     return 0; } void solve(){      vector &lt;int&gt; candidate;     queue &lt;st&gt; q;     q.push(robot);     visit[robot.x][robot.y][robot.d] = 1;      while(!q.empty()){         st top = q.front();         q.pop();          if(top.x == destination.x &amp;&amp; top.y == destination.y &amp;&amp; top.d == destination.d){             cout &lt;&lt;  top.cnt &lt;&lt; endl;             return;         }          //top.d 방향으로 최대 3번 움직이기         for(int j=1; j&lt;=3; j++){             int next_x = top.x + (dx[top.d] * j);             int next_y = top.y + (dy[top.d] * j);             if(visit[next_x][next_y][top.d]) continue;             if(room[next_x][next_y] == 1|| next_x &gt; N || next_y &gt; M || next_x &lt;= 0 || next_y &lt;= 0) break;             visit[next_x][next_y][top.d] = 1;             q.push({next_x, next_y, top.d, top.cnt + 1}); //움직일 수 있다면 큐에 넣기         }           for(int i=1; i&lt;=4; i++){             if(i == top.d) continue;             //다른 방향으로 움직이기                         if(visit[top.x][top.y][i] || room[top.x][top.y] == 1 || top.x &gt; N || top.y &gt; M || top.x &lt;= 0 || top.y &lt;= 0) continue;                          if(check(top.d, i)){                 q.push({top.x, top.y, i, top.cnt + 2});             }else{                 q.push({top.x, top.y, i, top.cnt + 1});             }              //해당 방향을 방문 처리 해 준다.             visit[top.x][top.y][i] = 1;          }              }  }  int main(){      input();     solve();     return 0; }      visit을 3차원 배열로 만들어서 x좌표, y좌표, 방향을 저장한다.   bfs를 돌면서 top이 destination이라면 출력 후 종료한다.   아니라면               최대 3칸 앞으로 갈 수 있는지 확인한다 (go)                       동서남북을 확인한다 (dir)           움직이는 go에서 +1씩 해주고,   동서남북을 확인하고 방향이 전환됨에 따라 +1, +2씩 해주면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1726-%EB%A1%9C%EB%B4%87/",
        "teaser": null
      },{
        "title": "[프로그래머스] 종이접기",
        "excerpt":"[프로그래머스] 종이접기  문제 링크   #include &lt;string&gt; #include &lt;vector&gt; using namespace std; vector&lt;int&gt; solution(int n) {     vector&lt;int&gt; answer;     answer.push_back(0); //초기값      for(int i=2; i&lt;=n; i++){         vector &lt;int&gt; save = answer;          answer.push_back(0);          int idx = save.size() / 2;          for(int j=0; j&lt;save.size(); j++){             if(j == idx){                 answer.push_back(!save[j]);                 continue;             }else                 answer.push_back(save[j]);         }     }     return answer; }                  n       색종이                       1번       0                 2번       001                 3번       0010011                 4번       001001100011011                 5번       0010011000110110001001110011011                접다 보면 규칙이 생긴다   일단 n은 처음에 n-1이 그대로 반복된다.   그 후 0이 추가가 된다 (새로 접힌 부분)        그리고 이후도 그대로 반복 되지만   n-1에서 접혔던 곳이 반대로 된다.   이 곳은 늘 중간에 위치하므로 그 인덱스만 반대로 바꿔주면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A2%85%EC%9D%B4%EC%A0%91%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[프로그래머스] 여행경로",
        "excerpt":"[프로그래머스] 여행경로  문제 링크   #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; int visited[1001]; void solve(vector &lt;vector&lt;string&gt;&gt;&amp; candidates, vector&lt;string&gt;&amp; temp, vector&lt;vector&lt;string&gt;&gt;&amp; tickets, string target){          if(temp.size() == tickets.size() + 1){         candidates.push_back(temp);         return;     }      //갈 수 있는 한 깊은 곳 까지 가자     for(int i=0; i&lt;tickets.size(); i++){         if(!visited[i] &amp;&amp; target == tickets[i][0]){             temp.push_back(tickets[i][1]);             visited[i] = 1;             solve(candidates, temp, tickets, tickets[i][1]);             visited[i] = 0;             temp.pop_back();         }     }      } vector&lt;string&gt; solution(vector&lt;vector&lt;string&gt;&gt; tickets) {     vector &lt;vector&lt;string&gt;&gt; candidates;     vector &lt;string&gt; temp;     for(int i=0; i&lt;tickets.size(); i++){         if(tickets[i][0] == \"ICN\"){             temp.push_back(\"ICN\"); // 시작점 저장             temp.push_back(tickets[i][1]);             visited[i] = 1;             solve(candidates, temp, tickets, tickets[i][1]);             visited[i] = 0;         }         temp.clear();     }      sort(candidates.begin(), candidates.end());      return candidates[0]; }      전형적인 백트래킹, dfs 문제이다.   문제 해설이 좀 부족한데, https://programmers.co.kr/learn/questions/7894 이 링크에서 도움을 많이 받았다.   dfs 탐색으로 갈 수 있는 모든 경로를 저장하고, 티켓의 갯수 + 1개가 되면 후보 벡터에 저장한다.   모든 탐색이 끝난 후, 후보 벡터를 sort로 알파벳 순서대로 정렬 후, 제일 앞쪽의 벡터를 리턴한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%97%AC%ED%96%89%EA%B2%BD%EB%A1%9C/",
        "teaser": null
      },{
        "title": "[프로그래머스] 입국심사",
        "excerpt":"[프로그래머스] 입국심사  문제 링크   #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; long long solution(int n, vector&lt;int&gt; times) {      sort(times.begin(), times.end()); // 안해도 됨(입력에서 이미 정렬되어 있는듯)     long long N = n;     long long left = 0;     long long right = times[times.size()-1] * N;     long long answer = 0;      while(left &lt;= right){         long long mid = (left + right) / 2;                  long long total = 0;         for(int i=0; i&lt;times.size(); i++){             total += mid / times[i];         }          if(total &lt; N){             left = mid + 1;         }else{             right = mid - 1;         }     }      return left; }     이분탐색으로 푸는 문제.   8번 테스트케이스에서 계속 오류가 나서 검색 해 보니 인자로 받은 n을 long long으로 타입캐스팅 해주어야 했다 ㅡㅡ.. 애초에 long long으로 주지   left를 0으로, right를 가장 큰 값 (가장 느린 심사대 * N명 처리)로 해 주었다.   mid로 탐색하며, mid분에서 몇명을 처리할 수 있는지 확인한다.   총 처리 인원이 N보다 작으면 left를 늘려주고, 크면 right를 줄여준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9E%85%EA%B5%AD%EC%8B%AC%EC%82%AC/",
        "teaser": null
      },{
        "title": "[TIL] Javascript splice",
        "excerpt":"Javascript splice     기존의 배열 요소를 변경한다.   array.splice(start[, deleteCount[, item1[, item2[, ...]]]])      start : 변경 시작 인덱스   deleteCount : 제거할 요소의 수 (optional)   item... : 추가할 요소   ex)  // 하나도 지우지 않고, 2번째에 drum 추가 var removed = myFish.splice(2, 0, 'drum');  // 3번 인덱스에서 1개 제거 var removed = myFish.splice(3, 1);        js30에서 입력받은 것이 secretcode와 일치하는지 확인하는 기능을 구현했다.   const secretcode = \"wesbos\"; const pushed = [];  window.addEventListener('keyup', (e)=&gt;{ \tpushed.push(e.key); \tpushed.splice(-secretcode.length-1, pushed.length - secretcode.length); \tif(pushed.join('').includes(secretcode)){ \t\tconsole.log(\"Ding Ding!\"); \t} })      -secretcode - 1은 -7이다. 즉 secretcode 이상을 눌렀을 때에, 첫번째 인덱스의 것을 제거한다.   splice의 2번째 인자를 1로 하면 늘 1개를 지우기 때문에 두 인자를 빼주어야 한다.   ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-Javascript-Splice/",
        "teaser": null
      },{
        "title": "[백준 1717] 집합의 표현",
        "excerpt":"[백준 1717] 집합의 표현  문제 링크   #include &lt;stdio.h&gt; #include &lt;iostream&gt; using namespace std; int n, m; int parent[1000001];  int find(int x){     if(parent[x] == x) return x;     return parent[x] = find(parent[x]); }  void merge(int a, int b){     a = find(a);     b = find(b);      if(a == b) return;      parent[b] = a; }  void input(){      scanf(\"%d %d\", &amp;n, &amp;m);      for(int i=1; i&lt;=n; i++){         parent[i] = i;     }      for(int i=1; i&lt;=m; i++){         int order;         scanf(\"%d\", &amp;order);         if(order){             int a, b;             scanf(\"%d %d\", &amp;a, &amp;b);             a = find(a);             b = find(b);             if(a == b) printf(\"YES\\n\");             else printf(\"NO\\n\");         }else{             int a, b;             scanf(\"%d %d\", &amp;a, &amp;b);             merge(a, b);                      }     } } int main() {     ios::sync_with_stdio(false);     cin.tie(0);      input();     // solve();     return 0; }     기본적인 union-find 문제   scanf와 printf, ios::sync_with_stdio(false); cin.tie(0);를 해 주어야 시간 초과가 안 난다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1717-%EC%A7%91%ED%95%A9%EC%9D%98-%ED%91%9C%ED%98%84/",
        "teaser": null
      },{
        "title": "[백준 1753] 최단경로",
        "excerpt":"[백준 1753] 최단경로  문제 링크   #include \"header.h\" #define INF 987654321 using namespace std; int v, e, start; vector &lt;pair&lt;int, int&gt;&gt; vec[20001]; int dist[300001]; void input(){     cin &gt;&gt; v &gt;&gt; e &gt;&gt; start;      for(int i=0; i&lt;e; i++){         int from, to, cost;         cin &gt;&gt; from &gt;&gt; to &gt;&gt; cost;         vec[from].push_back({to, cost});     }      for(int i=0; i&lt;v+1; i++){         dist[i] = INF;     } } void solve(){      priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt; , greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;      pq.push({0, start});     dist[start] = 0;      while (!pq.empty())     {         int top = pq.top().second;         int cost = pq.top().first;         pq.pop();          for(int i=0; i&lt;vec[top].size(); i++){             int next = vec[top][i].first;             int next_cost = vec[top][i].second;              if(next_cost + cost &lt; dist[next]){                 dist[next] = next_cost + cost;                 pq.push({dist[next], next});             }         }     }           for(int i=1; i&lt;=v; i++){         if(dist[i] == INF) cout &lt;&lt; \"INF\" &lt;&lt; endl;         else cout &lt;&lt; dist[i] &lt;&lt; endl;     }   } int main() {     ios::sync_with_stdio(false);     cin.tie(0);      input();     solve();     return 0; }   ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1753-%EC%B5%9C%EB%8B%A8%EA%B2%BD%EB%A1%9C/",
        "teaser": null
      },{
        "title": "[프로그래머스] 자물쇠와 열쇠",
        "excerpt":"[프로그래머스] 자물쇠와 열쇠  문제 링크   #include &lt;string&gt; #include &lt;vector&gt;  using namespace std; int keysize; int locksize;  int boardsize; void turn(vector&lt;vector&lt;int&gt;&gt; &amp;key) {     vector&lt;vector&lt;int&gt;&gt; temp(key.size(), vector&lt;int&gt;(keysize));     for (int i = 0; i &lt; key.size(); i++){         int idx = keysize - 1;         for (int j = 0; j &lt; keysize; j++){             temp[i][idx--] = key[j][i];         }     }     key.assign(temp.begin(), temp.end()); }  bool check(int x, int y, vector&lt;vector&lt;int&gt;&gt;&amp; key, vector&lt;vector&lt;int&gt;&gt;&amp; board){          //키를 더한다     vector &lt;vector&lt;int&gt;&gt; checkBoard;     checkBoard.assign(board.begin(), board.end());     for(int i=x; i &lt;x + key.size(); i++){         for(int j=y; j &lt; y +keysize; j++){             checkBoard[i][j] += key[i - x][j - y];         }     }      for(int i=key.size() - 1; i &lt;= checkBoard.size() - key.size(); i++){         for(int j=keysize - 1; j&lt;=checkBoard.size() - keysize; j++){             if(checkBoard[i][j] != 1) return false;         }     }          return true; } bool initCheck(vector&lt;vector&lt;int&gt;&gt;&amp; lock){     for(int i=0; i&lt;lock.size(); i++){         for(int j=0; j&lt;lock[0].size(); j++){             if(!lock[i][j]) return false;         }     }     return true; } bool solution(vector&lt;vector&lt;int&gt;&gt; key, vector&lt;vector&lt;int&gt;&gt; lock) {     bool answer = false;          //자물쇠의 빈칸이 없는 경우     if(initCheck(lock)) return true;     locksize = lock.size();     keysize = key.size();     boardsize = lock.size() + (keysize -1) * 2;     vector&lt;vector&lt;int&gt;&gt; board(boardsize, vector&lt;int&gt;(boardsize, 0));      //lock을 더해 놓는다.     for (int i = keysize - 1; i &lt;= boardsize - keysize; i++)         for (int j = keysize - 1; j &lt;= boardsize - keysize; j++)             board[i][j] = lock[i - keysize + 1][j - keysize + 1];        for (int r = 0; r &lt; 4; r++){          //상하좌우 돌리기         for(int i=0; i&lt;=boardsize - keysize; i++){             for(int j=0; j&lt;=boardsize - keysize; j++){                 //lock에 하나씩 맞춰보기                 if(check(i, j, key, board)) return true;             }         }         turn(key);      }     return answer; }      N과 M이 최대 20까지 밖에 없으므로 완전탐색으로 풀었다.            키를 돌린다.       모든 칸에 대본다.       맞다면 return true                 키를 갔다 댈 때, 최소 시작점부터 최대 시작점까지 한 번씩 갔다 대면 된다.   (0, 0)부터 시작 해서 boardsize - keysize만큼 갔다 대면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%9E%90%EB%AC%BC%EC%87%A0%EC%99%80-%EC%97%B4%EC%87%A0/",
        "teaser": null
      },{
        "title": "[백준 3109] 빵집",
        "excerpt":"[백준 3109] 빵집  문제 링크   #include \"header.h\" using namespace std; int R, C, answer; // 오른쪽 위 대각선, 오른쪽, 오른쪽 아래 대각선 int dx[3] = { -1, 0, 1 }; int dy[3] = { 1, 1, 1, }; char market[10001][501]; int visit[10001][501]; bool ans; //'.'는 빈 칸이고, 'x'는 건물 void input(){     cin &gt;&gt; R &gt;&gt; C;     for(int i=0; i&lt;R; i++){         for(int j=0; j&lt;C; j++){             cin &gt;&gt; market[i][j];         }     } } void dfs(int x, int y){     visit[x][y] = 1;          //기저 조건     //오른쪽 끝에 도달함     if(y == C-1){         ans = true;         answer++;         return;     }      //아니라면 대각선 탐색     for(int i=0; i&lt;3; i++){         int nx = x + dx[i];         int ny = y + dy[i];          if(visit[nx][ny] || market[nx][ny] == 'x' || nx &lt; 0 || ny &lt; 0 || nx &gt;= R || ny &gt;= C) continue;                  dfs(nx, ny);         if(ans) return;     }  } void solve(){      for(int i=0; i&lt;R; i++){         ans = false;         dfs(i, 0);     }  } int main() {     input();     solve();      cout &lt;&lt; answer &lt;&lt; endl;      return 0; }       처음에는 끝에 도달 했을 시에, 다음 dfs를 바로 돌렸는데, 그렇게 하니 무한 루프가 돌았다.        방문 처리를 해주고, dfs 처리 후, 다시 방문 처리를 없앴는데, 중복으로 방문을 하다 보니 무한 루프가 돈 것 같다.       오른쪽으로 이동 할 시에, 오른쪽 상단, 오른쪽, 오른쪽 아래 순으로 탐색을 하면 경로가 막히지 않는다.   최단 경로가 보장이 되기 때문에 방문처리를 철회할 필요도 없다.   R만큼 돌면서 dfs를 돌린다.   끝에 방문 시에는 더이상 탐색 할 필요가 없으므로 flag를 두어 return을 하고, 다음 인덱스 dfs를 돌린다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-3109-%EB%B9%B5%EC%A7%91/",
        "teaser": null
      },{
        "title": "[프로그래머스] 디스크 컨트롤러",
        "excerpt":"[프로그래머스] 디스크 컨트롤러  문제 링크   #include \"header.h\" using namespace std; int visit[1001]; priority_queue &lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;  bool cmp(vector&lt;int&gt; a, vector&lt;int&gt;b){     if(a[0] &gt;= b[0]){         if(a[0] == b[0]){             if(a[1] &lt; b[1]){                 return true;             }             return false;         }         return false;     }     return true; } int solution(vector&lt;vector&lt;int&gt;&gt; jobs) {     int answer = 0;     int total_time = 0;      sort(jobs.begin(), jobs.end(), cmp);      pq.push({jobs[0][1], jobs[0][0]}); //맨 처음에 넣기     visit[0] = 1;      while(!pq.empty()){         int top_start = pq.top().second;         int top_duration = pq.top().first;          if(top_start &gt; total_time){             total_time += top_start;         }                  total_time += top_duration;         answer += total_time - top_start;                  pq.pop();          for(int i=1; i&lt;jobs.size(); i++){             if(visit[i]) continue;             int start = jobs[i][0];             int duration = jobs[i][1];              if(start &lt;= total_time){ //신청 기간이 지났음                 pq.push({jobs[i][1], jobs[i][0]});                 visit[i] = 1;             }         }     }       for(int i=0; i&lt;jobs.size(); i++){         if(!visit[i])             answer += (jobs[i][0] - total_time) + jobs[i][1];     }       return answer / jobs.size(); }      최대한 빨리 끝낼 수 있는 애를 골라야 함 -&gt; duration이 제일 적은 애 -&gt; priority queue로 작업   대신 대기 시간도 더해주어야 함.   0-3 =&gt; 3   2-6 =&gt; 9에 끝남, (3-2) 1만큼 대기 ==&gt; 9-2 = 7만큼 걸림   1-9 =&gt; 18에 끝남, (9-1) 8만큼 대기 ==&gt; 18-1 = 17만큼 걸림        total_time(걸린 시간) - start(시작 시간)       제일 빠른 순으로 정렬 해 주고, 시작시간이 아직 되지 않았을 경우 (top_start &gt; total_time) 예외 처리후 pop해 더해준다.   우선순위 큐가 빈 후에, 시간이 늦어 아직 작업 큐에 들어가지 않은 애들도 처리 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%94%94%EC%8A%A4%ED%81%AC-%EC%BB%A8%ED%8A%B8%EB%A1%A4%EB%9F%AC/",
        "teaser": null
      },{
        "title": "[백준 9328] 열쇠",
        "excerpt":"[백준 9328] 열쇠  문제 링크   #include \"header\" using namespace std; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; int visit[101][101]; char maze[101][101]; int keys[130];  //97~122 소문자 알파벳 int t, ans, h, w; vector&lt;pair&lt;int, int&gt;&gt; v;  void bfs() {     int j = 0;     for (j = 0; j &lt; v.size(); j++) {         queue&lt;pair&lt;int, int&gt;&gt; q;                  if(isupper(maze[v[j].first][v[j].second])){             int cmp = tolower(maze[v[j].first][v[j].second]);             if(!keys[cmp]) continue;             else maze[v[j].first][v[j].second] = '.';         }          q.push({v[j].first, v[j].second});                  while (!q.empty()) {             int x = q.front().first;             int y = q.front().second;             q.pop();             visit[x][y] = 1;              for (int i = 0; i &lt; 4; i++) {                 int nx = x + dx[i];                 int ny = y + dy[i];                  if (visit[nx][ny] || maze[nx][ny] == '*' || nx &lt; 0 || ny &lt; 0 || nx &gt;= h || ny &gt;= w)                     continue;                  int cmp = tolower(maze[nx][ny]);                 if (isupper(maze[nx][ny])) {  //door                     if (keys[cmp]) maze[nx][ny] = '.'; //열쇠가 있으면                     else continue;                     //열쇠가 없으면                 } else if (islower(maze[nx][ny])) {  //key                     if (keys[cmp]) maze[nx][ny] = '.'; //이미 가진 열쇠라면                     else {                             //새로운 열쇠라면                         keys[cmp] = 1;                         maze[nx][ny] = '.';                         j = -1; //처음부터 탐색                         memset(visit, 0, sizeof(visit));                     }                 } else if (maze[nx][ny] == '$') { //문서라면                     ans++;                     maze[nx][ny] = '.';                 }                  visit[nx][ny] = 1;                 q.push({nx, ny});             }         }     } } void solve() {     //가생이 돌기     for (int i = 0; i &lt; h; i++) {         int cmp = tolower(maze[i][0]);         if (maze[i][0] != '*'){             if (islower(maze[i][0])) {  //key                 if (!keys[cmp]) keys[cmp] = 1;             } else if (maze[i][0] == '$') {                 ans++;                 maze[i][0] = '.';             }             v.push_back({i, 0});         }     }      for (int i = 0; i &lt; w; i++) {         int cmp = tolower(maze[0][i]);         if (maze[0][i] != '*'){             if (islower(maze[0][i])) {  //key                 if (!keys[cmp]) keys[cmp] = 1;             } else if (maze[0][i] == '$') {                 ans++;                 maze[0][i] = '.';             }             v.push_back({0, i});         }     }      int n = w - 1;     for (int i = 0; i &lt; h; i++) {         int cmp = tolower(maze[i][n]);         if (maze[i][n] != '*'){             if (islower(maze[i][n])) {  //key                 if (!keys[cmp]) keys[cmp] = 1;             } else if (maze[i][n] == '$') {                 ans++;                 maze[i][n] = '.';             }             v.push_back({i, n});          }     }      n = h - 1;     for (int i = 0; i &lt; w; i++) {         int cmp = tolower(maze[n][i]);         if (maze[n][i] != '*'){             if (islower(maze[n][i])) {  //key                 if (!keys[cmp]) keys[cmp] = 1;             } else if (maze[n][i] == '$') {                 ans++;                 maze[n][i] = '.';             }             v.push_back({n, i});          }     } } void input() {     vector&lt;int&gt; answer;     cin &gt;&gt; t;      for (int k = 0; k &lt; t; k++) {         cin &gt;&gt; h &gt;&gt; w;         ans = 0;         memset(visit, 0, sizeof(visit));         memset(keys, 0, sizeof(keys));         memset(maze, 0, sizeof(maze));         v.clear();          for (int i = 0; i &lt; h; i++) {             for (int j = 0; j &lt; w; j++) {                 cin &gt;&gt; maze[i][j];             }         }          string key;         cin &gt;&gt; key;         if (key != \"0\") {             for (int j = 0; j &lt; key.length(); j++) {                 int key_ = key[j];                 keys[key_] = 1;             }         }         solve();         bfs();          answer.push_back(ans);     }      for (auto a : answer) {         cout &lt;&lt; a &lt;&lt; endl;     } } int main() {     input();     return 0; }      완전 더럽게 풀었다.               가장자리를 돌면서 들어갈 수 있는 곳을 벡터에 모두 넣는다.                    이 때, 문서라면 답을 +1 해 주고, 빈 칸으로 바꿔놓는다.           열쇠라면 줍고, 배열에 표시 해 준 후, 빈 칸으로 바꿔놓는다.                                       벡터를 돌면서 bfs를 돈다.                    만약 문이라면                            키가 있다면 문을 연다. 문을 빈 칸으로 바꾼다.               키가 없다면 continue                                   만약 문서라면                            답 +1 후 빈 칸으로 바꾼다.                                   만약 열쇠라면                            벡터를 처음부터 돌기 위해 j를 -1로 바꿔준다.               visit 배열을 초기화 시켜준다.                                                  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-9328-%EC%97%B4%EC%87%A0/",
        "teaser": null
      },{
        "title": "[프로그래머스] 베스트앨범",
        "excerpt":"[프로그래머스] 베스트앨범  문제 링크   #include \"header.h\" using namespace std; map &lt;string, vector&lt;pair&lt;int, int&gt;&gt;&gt; songs; map &lt;string, int&gt; total;  int desc(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b){     return a.first &gt; b.first; } int cmp(pair&lt;string, int&gt;a, pair&lt;string, int&gt;b){     return a.second &gt; b.second; } vector&lt;int&gt; solution(vector&lt;string&gt; genres, vector&lt;int&gt; plays) {     vector&lt;int&gt; answer;      for(int i=0; i&lt;genres.size(); i++){         vector &lt;pair&lt;int, int&gt;&gt; temp = songs[genres[i]];         temp.push_back({plays[i], i});         songs[genres[i]] = temp;         total[genres[i]] += plays[i];     }      vector&lt;pair&lt;string, int&gt;&gt; v;      map&lt;string,int&gt;::iterator iter;     for(iter= total.begin(); iter != total.end(); iter++){         v.emplace_back(make_pair(iter-&gt;first, iter-&gt;second));     }      sort(v.begin(), v.end(), cmp);      for(int i=0; i&lt;v.size(); i++){         vector &lt;pair&lt;int, int&gt;&gt; temp_v = songs[v[i].first];         sort(temp_v.begin(), temp_v.end(), desc);         answer.push_back(temp_v[0].second);         if(temp_v.size() &lt;= 1) continue;         answer.push_back(temp_v[1].second);     }      return answer; }       단순 해시 구현 문제.   total 맵은 (장르 이름, 총 재생 수) 이다.   songs 맵은 (장르 이름, (곡 재생 수, 곡 고유 번호)) 이다.   total 맵을 벡터로 바꿔준 후 sort 해줘서 많이 재생된 장르 순으로 정렬한다.   이제 벡터의 사이즈만큼 돌면서 (장르 갯수) songs의 해당 곡들을 sort 해 준다.   첫번째 곡을 넣고, 두번째 곡이 있으면 두번째 곡도 넣는다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EB%B2%A0%EC%8A%A4%ED%8A%B8%EC%95%A8%EB%B2%94/",
        "teaser": null
      },{
        "title": "[프로그래머스] 예산",
        "excerpt":"[프로그래머스] 예산  문제 링크   #include \"header.h\" #define MAX 1000000001 using namespace std; long long check(vector&lt;int&gt; &amp; budgets, int mid){     // mid = 상한선!     long long total = 0;     for(int i=0; i&lt;budgets.size(); i++){         if(mid &gt;= budgets[i]){             total += budgets[i];         }else{             total += mid;         }     }      return total; } int solution(vector&lt;int&gt; budgets, int M) {     int answer = 0;      int left = 0;     long long right = M;      while(left &lt;= right){         int mid = left + (right - left) / 2; //상한액         long long ret = check(budgets, mid);          if(ret &gt; M){ //예산 초과             right = mid - 1;         }else{             left = mid + 1;             answer = max(answer, mid);         }     }          if(answer == M){         long long ret = 0;         for(long long cur : budgets) ret = max(ret, cur);         return ret;     }     return answer; }      간단한 이분탐색 문제. 일단 범위가 1억이 넘으면 이분탐색 접근법을 생각 해 보는게 좋을 것 같다.   mid를 선언 할 때, 오버플로우를 막기 위해 left + (right - left) / 2를 해 주었다.   mid를 상한선으로 잡고, 해당 상한선으로 얼마만큼의 예산이 소비되는지 check함수를 통해 계산한다.   만약 예산이 초과된다면, 상한선을 줄인다.   예산이 초과가 되지 않았으면, 상한선을 올리고, 답을 업데이트 한다.   문제가 조금 불친절한 감이 있는데, 만약 [1, 1, 1, 1], 400 같이 모든 요청이 배정될 수 있다면 1+1+1+1 을 반환해야 한다.   효율성에서 문제가 발생하면 budgets을 더하는 인자를 long long으로 바꿔야 한다. (1억이 넘으므로 int 범위 벗어남)  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%98%88%EC%82%B0/",
        "teaser": null
      },{
        "title": "[백준 3197] 백조의 호수",
        "excerpt":"[백준 3197] 백조의 호수  문제 링크   #include \"header.h\" using namespace std; int R, C, day; char pond[1501][1501]; int visit[1501][1501]; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; vector&lt;pair&lt;int, int&gt;&gt; swan; //백조 위치 저장 queue&lt;pair&lt;int, int&gt;&gt; q; queue&lt;pair&lt;int, int&gt;&gt; water; void input() {     cin &gt;&gt; R &gt;&gt; C;     for (int i = 1; i &lt;= R; i++) {         for (int j = 1; j &lt;= C; j++) {             cin &gt;&gt; pond[i][j];             if (pond[i][j] == 'L') {                 swan.push_back({i, j});                 pond[i][j] = '.';             }             if (pond[i][j] == '.') {                 water.push({i, j});             }         }     } }  void melt() {     queue &lt;pair&lt;int, int&gt;&gt; new_water;      while (!water.empty()) {         int x = water.front().first;         int y = water.front().second;         water.pop();          for (int i = 0; i &lt; 4; i++) {             int nx = x + dx[i];             int ny = y + dy[i];             if (nx &lt;= 0 || ny &lt;= 0 || nx &gt; R || ny &gt; C) continue;             if(pond[nx][ny] == 'X'){                 pond[nx][ny] = '.';                 new_water.push({nx, ny}); //다음에 녹을 애들             }         }     }      water = new_water;  } bool move_swan() {     queue &lt;pair&lt;int, int&gt;&gt; next;     int dest_x = swan[1].first;     int dest_y = swan[1].second;          while (!q.empty()) {         int top_x = q.front().first;         int top_y = q.front().second;         q.pop();          if (top_x == dest_x &amp;&amp; top_y == dest_y) return true;         for (int i = 0; i &lt; 4; i++) {             int nx = top_x + dx[i];             int ny = top_y + dy[i];             if (visit[nx][ny] || nx &lt;= 0 || ny &lt;= 0 || nx &gt; R || ny &gt; C) continue;             if(pond[nx][ny] != 'X'){                 visit[nx][ny] = 1;                 q.push({nx, ny});             }else {                 next.push({nx, ny});                 visit[nx][ny] = 1;             }         }     }      q = next;      return false; }  void solve() {      q.push({swan[0].first, swan[0].second});          while (1) {         if (move_swan()) {             cout &lt;&lt; day &lt;&lt; endl;             return;         }         melt();         day++;     } } int main() {     input();     solve();     return 0; }      bfs 응용 문제.               백조를 bfs로 움직인다.                       만나면 return,                       아니라면 얼음을 녹인다.           맨 처음에는 새로 녹는 얼음들을 2중 반복문으로 pond를 전체 탐색 하여 다시 큐에 넣어주었다. -&gt; 시간초과        그 다음에는 새로운 큐를 만들어서 이전 bfs를 돌 때 마다 다음 탐색 할 것을 넣어 주었다. 하지만 visit 배열을 매번 초기화 해 주었다. -&gt; 시간초과       얼음을 녹일 때에는 다음에 녹을 애들만 새로운 큐에 넣어주기 때문에 방문 처리가 필요 없다.   따라서 visit 배열은 백조가 움직일 때만 사용 해 주었다.   백조가 움직일 때에도 새로운 큐를 만들어서 다음에 방문 할 것들을 저장 해 주었다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-3197-%EB%B0%B1%EC%A1%B0%EC%9D%98-%ED%98%B8%EC%88%98/",
        "teaser": null
      },{
        "title": "[백준 17471] 게리맨더링",
        "excerpt":"[백준 17471] 게리맨더링  문제 링크   using namespace std; int N; int people[21]; int adjacent[21][21]; int check[21]; int ans = 987654321; void input() {     cin &gt;&gt; N;     for (int i = 1; i &lt;= N; i++) {         cin &gt;&gt; people[i];  //인구의 수     }      for (int i = 1; i &lt;= N; i++) {         int n;         cin &gt;&gt; n;         adjacent[i][i] = 1;         for (int j = 1; j &lt;= n; j++) {             int num;             cin &gt;&gt; num;             adjacent[i][num] = 1;             adjacent[num][i] = 1;         }     } }  bool check_connect(vector&lt;int&gt;&amp; nums, bool t){     queue &lt;int&gt; q;     int visit[11] = {0, };     q.push(nums[0]);     visit[nums[0]] =1;     int cnt = 1;      while (!q.empty()){         int front = q.front();         q.pop();         for(int i=1; i&lt;=N; i++){             //해당 선거구이고, 서로 연결 돼 있고, 방문을 하지 않았으면             if(check[i] == t &amp;&amp; adjacent[front][i] &amp;&amp; !visit[i]){                 cnt++;                 visit[i] = 1;                 q.push(i);             }         }     }          if(nums.size() == cnt) return true;     return false; }  void check_valid(){     vector &lt;int&gt; one;     vector &lt;int&gt; two;      for(int i=1; i&lt;=N; i++){         if(check[i]){             one.push_back(i);         }else{             two.push_back(i);         }     }      bool flag1 = check_connect(one, true);     bool flag2 = check_connect(two, false);      int first = 0;     int second = 0;     if(flag1 &amp;&amp; flag2) {         for(int a : one) first += people[a];         for(int b : two) second += people[b];         ans = min(ans, abs(first - second));     }  }   void dfs(int idx, vector&lt;int&gt;&amp;nums) {     if (0 &lt; nums.size() &amp;&amp; nums.size() &lt; N) {         check_valid();     }      for (int i = idx; i &lt;= N; i++) {         if(!check[i]){             check[i] = 1;             nums.push_back(i);             dfs(i+1, nums);             nums.pop_back();             check[i] = 0;         }     } } void solve() {     //1, 2, 3, 4, 5, 6 조합 만들기     vector&lt;int&gt; nums;     dfs(1, nums);      } int main() {     input();     solve();          if(ans == 987654321) cout &lt;&lt; -1 &lt;&lt; endl;     else cout &lt;&lt; ans &lt;&lt; endl;      return 0; }     조합으로 모든 선거구의 경우의 수를 구한다.   조합을 기반으로 A선거구와 B선거구로 나눈다.   각각 선거구마다 bfs를 돌려 서로 연결된 선거구인지 확인한다.   A, B 선거구 모두 서로 연결 돼 있다면 답을 갱신한다.      와.. 머리가 안돌아가서.. 혼났다..   dfs + bfs로 푸는 문제.. ㅎㅜ후후후ㅜ…   조합 만드는 것 까진 생각 해 냈는데, 연결 됐는지 확인하는 부분이 생각이 안났다.. 일일히 다 해주자니 너무 하드코딩이었고..   2차원 배열을 bfs 도는 것은 익숙한데 1차원 배열이라 감을 좀 못잡았었다.   ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-17471-%EA%B2%8C%EB%A6%AC%EB%A7%A8%EB%8D%94%EB%A7%81/",
        "teaser": null
      },{
        "title": "[OS] Chap3. 프로세스 연습문제",
        "excerpt":"1. 단기, 중기, 장기 스케쥴링의 차이점을 설명하시오.        장기 스케쥴링            장기 스케쥴링은 디스크와 메모리 사이의 스케쥴링을 담당한다.       Job Queue에서 프로세스를 가져와 Ready State로 변경한다.       어떤 프로세스가 Ready State로 변경될 것인지를 결정한다.       장기 스케쥴러는 I/O Bound Process (I/O burst가 큰 프로세스)와 CPU Bound Process (CPU burst가 큰 프로세스) 사이의 균형을 맞춰야 한다.       대부분의 프로세스는 I/O Bound Process기 때문에, I/O bound process를 생성하게 되면 CPU가 놀게 된다.       따라서 CPU bound process나, CPU bound와 I/O bound가 반반인 프로세스를 생성하게 되면 시스템의 능률이 오르게 된다.           단기 스케쥴링            단기 스케쥴링은 메모리와 CPU 사이의 스케쥴링을 담당한다.       Ready state의 프로세스들을 Running 상태로 변경한다.       이 때에 스케쥴링 알고리즘들이 사용된다 (RR, FCFS…)       단기 스케쥴러가 시스템의 성능에 영향을 많이 끼친다.           중기 스케쥴링            프로세스를 Running-&gt;Ready 혹은 Running-&gt;Wait 상태로 바꿔야 하는 경우가 있다.       이 때 중기 스케쥴러를 사용한다.       메인 메모리에서 다른 메모리로 프로세스를 스와핑 하거나 그 반대의 스와핑을 담당한다.       이것은 CPU Bound와 I/O Bound의 균형을 맞추는데 큰 도움을 준다.       또한 다중 프로그래밍의 정도를 줄여준다.              2. 프로세스들 사이에 문맥을 교환할 때 커널이 수행하는 작업을 설명하시오.     현재 실행 중인 프로세스의 정보를 PCB에 저장한다.   OS가 다음에 실행 될 프로세스를 정하기 위해 스케쥴러를 호출한다.   실행될 프로세스의 정보를 PCB에서 가져오고, 실행한다.   3. Unix와 Linux 시스템의 Init 프로세스의 역할을 프로세스 종료의 관점에서 설명하시오.     Init은 unix-base 시스템이 부팅 될 때 실행 된다. init은 daemon(백그라운드에서 실행되는 프로그램)이고 시스템이 종료될 때 까지 계속 실행 된다.   Init은 모든 프로세스의 조상이다. (직접적이든 간접적이든) Init은 모든 고아 프로세스들을 입양한다.   exit()을 호출 하였는데도 부모가 wait()을 호출하지 않은 프로세스들을 init()이 입양 한 후, wait()을 호출하여 프로세스의 리소스를 해제하고 반환한다.   4. 일반 파이프를 사용하는 것이 지명 파이프를 사용하는 것보다 더 적절한 상황의 예와, 반대로 지명 파이프를 사용하는 것이 더 적절한 상황의 예를 들어 보시오.     지명 파이프            파일 시스템을 이용해서 파이프를 만드는 방법으로, 다수의 프로세스에서 사용할 때 유용하다.       부모-자식 관계가 아니더라도 사용 가능하다.       다른 컴퓨터에 있는 프로세스와 네트워크 통신도 가능하다.       연결 된 프로세스가 여러개일 수 있다.           일반 파이프            일반 파이프는 프로세스가 실행 중에만 사용 가능하다. 따라서 특정 프로세스만 파이프를 이용할 때 유용하다.       부모-자식 관계에만 사용 가능하다.       로컬에서만 사용 가능하다.           11. 다음에 나오는 기법들의 장점과 단점은 무엇인가? 시스템 관점과 프로그래머의 관점을 모두 고려하시오.     a. 동기적 통신과 비동기적 통신            동기적 통신은 작업이 완료 될 때까지 봉쇄한다. 따라서 연산이 종료 될 때까지 어플리케이션으로 제어권이 넘어가지 않는다.       비동기적 통신은 비봉쇄형이고 연산을 시행만 한다. 따라서 연산이 종료 될 때까지 기다리지 않고 연산이 종료 된 시점에 변수 설정이나 콜백 함수같은걸로 연산의 종료를 알린다.       프로세스가 통신을 할 때 send()와 receieve()를 사용한다. 동기적 통신을 사용해 send()의 종료를 기다림으로서 소비자-생산자 문제를 줄일 수 있다.       하지만 이 기다리는 시간이 너무 길 수 있다. 이 때에는 비동기적 통신을 사용함으로서 여러개의 request를 보내고, 연산이 끝나면 나중에 결과를 받을 수 있다.       하지만 결과가 도착하지 않거나, sender가 기다리지 않고 종료 해버린다면 오류를 야기할 수 있다.           b. 자동과 명시적 버퍼링            프로세스 통신으로 인해 교환된 메시지들은 임시 큐에 저장이 된다.       자동 버퍼링은 무한한 사이즈의 큐를 제공한다. 무한한 사이즈이기 때문에 이 메시지들은 큐 내부에서 무한정 대기할 수 있으므로, 봉쇄형을 사용할 필요가 없다.       하지만 무한한 사이즈 때문에 메모리 낭비로 이어질 수 있다.       명시적 버퍼링은 유한한 사이즈의 큐를 제공한다. 따라서 큐가 꽉 차있을 때에는 봉쇄함으로서 공간이 나기까지 기다려야 한다.       하지만 메모리 낭비는 자동 버퍼링보다는 적다.           c. 복사에 의한 송신과 참조에 의한 송신            복사에 의한 송신에서는 수신자가 복사된 데이터를 받게 된다. 따라서 데이터를 변경하게 된다면, 변화를 다른 사람이 알수 없다. 따라서 수신자는 송신자의 데이터를 변경할 수 없다.       기존 데이터가 변경이 되지 않기 때문에 안전성은 높다.       참조에 의한 송신은 주소값을 수신한다. 값을 변경하면 송신자와 수신자의 데이터 모두의 값이 변경이 된다.       주소값을 송수신함으로서 데이터가 클 경우 효과적이다.       또한 프로그래머가 여러 버젼을 만들 수 있게 한다.           d. 고정 크기와 가변 크기 메시지            프로세스가 보내는 메시지는 고정되거나 가변적인 크기를 가질 수 있다.       고정 크기는 메시지의 크기가 정해진 버퍼 크기보다 작아야 한다. 구현이 간편하다는 장점이 있다.       크기가 정해져 있다는 단점이 있다.       가변 크기 메시지를 사용하려면 공유 메모리 방식을 사용해야 한다.       메모리의 크기만큼 메시지를 전송할 수 있다.       구현이 어렵고 시스템 수준에서 최적화가 힘들다.           When a process creates a new process using the fork() operation, which of the following states is shared between the parent process and the child process?  fork() 연산으로 프로세스가 새로운 프로세스를 생성하면, 자식 프로세스와 부모 프로세스가 공유하는 것은 어떤 것인가?  a. stack  b. heap  c. Shared memory segments      fork()로 자식 프로세스가 생성이 되면, OS에 의해 부모와 다른 메모리 위치에 생성이 된다. 부모 프로세스는 공유 메모리 세그먼트만 공유한다.   stack과 heap은 새로운 프로세스에 복사본으로 생성된다.  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch3.-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[백준 13023] ABCDE",
        "excerpt":"[백준 13023] ABCDE  문제 링크   #include \"header.h\" using namespace std; int N, M; int visit[2001]; int answer; vector &lt;int&gt; v[2001]; void input(){     cin &gt;&gt; N &gt;&gt; M;      for(int i=0; i&lt;M; i++){         int a = 0;         int b = 0;         cin &gt;&gt; a &gt;&gt; b;         //그래프 생성         v[a].push_back(b);         v[b].push_back(a);     } } void dfs(int idx, int cnt){     if(cnt &gt;= 5){         answer = 1;         return;     }      visit[idx] = 1;      for(int there : v[idx]){         if(visit[there]) continue;         dfs(there, cnt+1);     }      visit[idx] = 0;      } void solve(){      for(int i=0; i&lt;N; i++){         if(!visit[i]){             dfs(i, 1);         }         if(answer) break;     }      cout &lt;&lt; answer &lt;&lt; endl;  }  int main() {     input();     solve();      return 0; }       dfs로 푸는 문제.   친구를 타고 들어가면서 총 센 친구 수가 N이 넘으면 break  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-13023-ABCDE/",
        "teaser": null
      },{
        "title": "[백준 14500] 테트로미노",
        "excerpt":"[백준 14500] 테트로미노  문제 링크   #include \"header.h\" using namespace std; int N, M; int paper[504][504];   void solve() {     vector&lt;vector&lt;vector&lt;pair&lt;int, int&gt;&gt;&gt;&gt; poly = {         {{{0, 0}, {0, 1}, {1, 0}, {1, 1}}},  //정사각형         {             {{0, 0}, {0, 1}, {0, 2}, {0, 3}},             {{0, 0}, {1, 0}, {2, 0}, {3, 0}}  //길쭉         },         {             {{0, 0}, {1, 0}, {1, 1}, {2, 1}},             {{0, 0}, {0, 1}, {-1, 1}, {-1, 2}},             {{0, 0}, {0, 1}, {-1, 1}, {1, 0}},             {{0, 0}, {0, 1}, {1, 1}, {1, 2}}  //꽈배기         },         {             {{0, 0}, {1, 0}, {2, 0}, {2, 1}},             {{0, 0}, {0, 1}, {0, 2}, {1, 0}},             {{0, 0}, {0, 1}, {1, 1}, {2, 1}},             {{0, 0}, {0, 1}, {0, 2}, {-1, 2}},  //낫             {{0, 0}, {0, 1}, {-1, 1}, {-2, 1}},             {{0, 0}, {0, 1}, {0, 2}, {1, 2}},             {{0, 0}, {0, 1}, {1, 0}, {2, 0}},             {{0, 0}, {1, 0}, {1, 1}, {1, 2}}         },         {             {{0, 0}, {0, 1}, {0, 2}, {-1, 1}},             {{0, 0}, {1, 0}, {2, 0}, {1, 1}},             {{0, 0}, {0, 1}, {0, 2}, {1, 1}},             {{0, 0}, {0, 1}, {1, 1}, {-1, 1}}  //빠큐         }};     int ans = 0;          for (int i = 0; i &lt; poly.size(); i++) {  //5개의 폴리웅앵         //j : 회전 수         for (int j = 0; j &lt; poly[i].size(); j++) {             //맵 돌면서 맞춰보기             for(int a=0; a&lt;N; a++){                 for(int b=0; b&lt;M; b++){                      int cnt = 0;                     for(int c=0; c&lt;4; c++){                         int nx = a + poly[i][j][c].first;                         int ny = b + poly[i][j][c].second;                          //범위 체크                         if(nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= M) continue;                          cnt += paper[nx][ny];                     }                      ans = max(ans, cnt);                 }             }         }     }      cout &lt;&lt; ans &lt;&lt; endl; } void input() {     cin &gt;&gt; N &gt;&gt; M;     for (int i = 0; i &lt; N; i++) {         for (int j = 0; j &lt; M; j++) {             cin &gt;&gt; paper[i][j];         }     } } int main() {     input();     solve();      return 0; }        그냥 빡구현 했다.   낫모양은 대칭이 있다는 것을 주의해야한다!   dfs로 푸는 방법도 있나보다.. 찾아보자.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-14500-%ED%85%8C%ED%8A%B8%EB%A1%9C%EB%AF%B8%EB%85%B8/",
        "teaser": null
      },{
        "title": "[OS] Ch4. 스레드",
        "excerpt":"Thread     CPU 이용의 기본 단위이다.   스레드 ID, Program Counter, 레지스터, 스택으로 이루어져 있다.   같은 프로세스에 속한 스레드들은 data, code를 공유한다.   스레드 사용의 동기     기존에는 다중 프로세스를 사용했다.   하지만 프로세스 생성 비용, context switching 등 오버헤드가 너무 많이 생성돼 스레드를 사용하게 됐다.   다중 스레드의 장점     응답성 (Responsibility)            연산을 분산함으로서 사용자 인터렉션 향상           자원 공유 (Resource Sharing)            자원을 공유함으로서 여러 스레드를 생성할 수 있다.           경제성 (Economy)            프로세스 관리보다 경제적이다.           규모 적응성 (Scalability)            multi processor에서는 스레드가 병렬로 실행되고       single processor에서는 단일 스레드로 실행된다.           다중코어 프로그래밍     코어가 여러개인 시스템            암달의 법칙  아무리 코어의 수를 늘려도 성능 향상엔 한계가 있다.            다중스레드는 병행성을 올린다.   병행성은 스레드들이 병렬적으로 실행될 수 있다는 것을 의미한다.   병행성은 하나 이상의 태스크를 지원한다는 것이고, 병렬성은 하나 이상의 태스크를 동시에 실행 한다는 것이다.   주의해야 할 점     태스크 인식 (Identifying Tasks)            task 단위로 분리 해야 한다.           균형 (Balance)            균등한 기여도를 가지도록 분배해야 한다.           데이터 분리 (Data Splitting)            데이터 또한 분리되어야 한다.           데이터 종속성 (Data Dependency)            데이터 사용 시 종속성이 있는지 검토해야 한다.           시험 및 디버깅 (Testing and Debugging)   암묵적 스레딩  스레드 풀     스레드 생성에 드는 시간을 줄이기 위해 사용   스레드의 동시 실행 수를 제한할 수 있음.            무한대이면 자원이 고갈 될 수 있음           프로세스를 시작 할 때 일정 수의 스레드를 스레드풀에 만든다.   모든 스레드가 일하고 있으면 free한 스레드가 나올 때까지 대기한다.   장점     새로 스레드를 생성하는 것보다 빠르다.   스레드 갯수에 제한을 둠으로서 많은 스레드의 병렬처리가 힘든 시스템에도 사용 가능하다.   태스크 생성을 분리하면 태스크를 일정 시간 후에 실행하거나 주기적으로 실행시킬 수 있음.   Threading Issues  Fork, Exec     fork() : 모든 스레드를 복제하거나, 하나의 스레드를 복제한다.   exec() : 바로 프로세스 호출 시 하나의 스레드를 복제하고 (어차피 프로세스가 올 때 그 프로세스의 스레드로 덮어 씌워지기 때문에), 아니라면 하나의 스레드만 복제한다.   신호 처리 (Signal Handling)     UNIX기반의 프로세스에는 signal로 사건을 알린다.   동기식 신호와 비동기식 신호로 나뉜다.   동기식 신호는 신호를 발생시킨 프로세스에게 전달 되고,   비동기식 신호는 외부에서 발생된 경우이기 때문에 외부 프로세스에게 전달된다.   스레드 취소     비동기식 취소            한 프로세스가 target을 바로 강제 종료시킨다.       자원 회수가 완전하지 않을 수 있다.           지연 취소            Target 프로세스가 스스로를 계속 점검함으로서 종료 할지 아닌지를 판단한다.       안전 여부를 판단 가능하다.          ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch4.-%EC%8A%A4%EB%A0%88%EB%93%9C/",
        "teaser": null
      },{
        "title": "[TIL] Javascript Prototype",
        "excerpt":"Javascript Prototype   프로토타입이란?     프로토타입은 “원형”이라는 뜻이다.   원형의 사전적 의미는 다음과 같다.            같거나 비슷한 여러가지가 만들어져 나온 본바탕  ex) 불교 문화의 영향을 받은 이 건축물은 후대 건축물의 원형이 됐다.            따라서 어떤 객체의 프로토타입이란, 그 객체의 ‘원형’을 뜻한다.     var object = new Object();  객체는 함수로 생성된다. 함수가 생성 되면 2가지가 생긴다.     생성자   프로토타입 객체   여기서 프로토타입 객체를 살펴보겠다.  프로토타입 객체 내부에는     생성자   프로토타입 링크가 존재한다.   프로토타입 객체 내부의 생성자에는, 어떤 생성자로 인해 객체가 선언 됐는지가 나와있다.  프로토타입 객체는 함수만 가지고 있다.  프로토타입 링크(__proto__)는 모든 함수가 가지고 있다.  프로토타입 링크에는 조상의 프로토타입 객체가 있다.   예시를 들면서 설명 해 보겠다.     function Person(){     this.first = \"Bae\";     this.last = \"Sonia\"; }  Person.prototype = {     getFullName(){         return this.first + this.last;     } }   Person이라는 함수는 성과 이름을 프로퍼티로 가지고 있다.  함수를 선언 하고, 프로토타입에 성과 이름을 합쳐 리턴하는 getFullName() 함수를 선언했다.   Person.prototype을 출력 해 보면 다음과 같이 나온다.     Person의 prototype 객체에는 getFullName이라는 함수와 프로토타입 링크를 가진다.      prototype 객체는 말 그대로 ‘객체’이기 때문에 프로토타입 링크에 객체의 생성자와 그 메소드들을 담고 있다.      getFullName은 함수이다.  따라서 생성자와 프로토타입 링크를 가진다.  함수이기 때문에 함수 생성자를 가질 것이고,   getFullName의 부모 객체인 함수 객체를 프로토타입 링크에 담고 있을 것이다.   함수 프로토타입 객체의 프로토타입 링크는 Object 객체이다.  이 Object도 함수이기 때문에 생성자와 프로토타입 링크를 가진다.  즉, 모든 객체, 함수의 최상위 프로토타입은 \"객체\"이다.     JS는 프로토타입 기반 언어이다.  객체 지향 언어와는 다르지만, 객체 지향에서 쓰이는 생성자, 상속 등을 프로토타입으로 비슷하게 구현할 수 있다.   또한 객체 내부에 함수를 따로 선언 할 필요가 없이, 프로토타입으로 선언을 해 주면, 객체를 생성하기만 하면 함수를 사용할 수 있으므로 메모리의 낭비를 줄일 수 있다.  ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-Javascript-prototype/",
        "teaser": null
      },{
        "title": "[TIL] spread와 rest",
        "excerpt":"spread와 rest     ES6 문법에 추가가 된 spread, rest를 배웠다.    Spread 구문  spread의 사전적 의미는 펼치다이다.  배열, 객체를 펼치는 것을 의미한다.  ...변수명으로 사용한다.    const food = {     vegetable: \"broccoli\" };  const grilledFood = {     ...food,     cook : \"fire\" };  const grilledDeliciousFood = {     ...grilledFood,     add: \"meat\" };  console.log(food); console.log(grilledFood); console.log(grilledDeliciousFood);   output {vegetable: \"broccoli\"} {vegetable: \"broccoli\", cook: \"fire\"} {vegetable: \"broccoli\", cook: \"fire\", add: \"meat\"}   예제에서 볼 수 있다시피 객체에 있는 값을 뿌려주고 있다.  모든 인자 값을 뿌려주는 것이 spread이다.   const numbers = [1, 2, 3]; const array = [...numbers, 4, 5, ...numbers]; console.log(array);   output [1, 2, 3, 4, 5, 1, 2, 3]   배열에서도 사용 가능 하다. spread는 여러 번 쓸 수 있다. 하지만 깊은 복사가 아닌 얕은 복사이기 때문에 다중 배열에서는 주의해야 한다!   Rest 파라미터  Rest의 사전적인 의미는 나머지이다. Rest of ~~ 할때의 그 rest이다.   rest는 객체, 배열, 함수의 파라미터에서 쓸 수 있다. ...변수명으로 사용한다. 변수명은 어떤것이든 될 수 있다.  const food = {     vegetable: \"broccoli\",     cook : \"fire\",     add: \"meat\"  };  const {add, ...rest} = food; console.log(add, rest);  output meat {vegetable: \"broccoli\", cook: \"fire\"}   food 객체에서 고기를 빼려고 할 때, {빼려고 하는 것, ...변수명}을 사용하면 된다.   spread 구문과 rest 구문을 동시에 쓸 수도 있다.   const food = {     vegetable: \"broccoli\",     cook : \"fire\",     add: \"meat\"  };  const {add, ...rest} = food; const newFood = {     ...rest,     add: \"fork\" }  console.log(newFood);  output { vegetable:\"broccoli\", cook:\"fire\" add:\"fork\" }   const {...rest, add} = food; //Uncaught SyntaxError: Rest element must be last element  …rest구문은 꼭 파라미터의 맨 앞에 와선 안된다. 나머지가 없기 때문이다.   함수 파라미터에서 rest  function add(...nums){     return nums.reduce((acc, current) =&gt; acc + current, 0); }  const result = add(1, 2, 3, 4, 5, 6);   이렇게 파라미터로서 모든 배열을 전달 해 줌으로서, 파라미터를 하나하나 선언 해 주지 않아도 된다.   function add(...nums){     return nums.reduce((acc, current) =&gt; acc + current, 0); } const arr = [1, 2, 3]; add(...arr);   spread와 rest를 동시에 쓴 예제이다. 파라미터로 spread 구문을 쓰고, 인자로 rest 파라미터를 받았다.      spread와 rest는 ie에서는 지원하지 않는다!  ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-spread%EC%99%80-rest/",
        "teaser": null
      },{
        "title": "[OS] Ch4. 연습문제",
        "excerpt":"1. 다중 스레드 기법을 사용 했을 때 단일 스레드 기법을 사용했을 때보다 성능이 좋지 않은 프로그래밍 사례 2가지를 제시하시오.     순차적으로 실행하는 프로그램은 다중 스레드 기법에 적합하지 않다.   shell 프로그램은 항상 환경변수, 작업 디렉토리 등의 정보를 감시해야 하기 때문에 다중 스레드 기법이 필요하지 않다. (자기 자신을 감독하는 것이기 때문에 굳이 스레드 필요 없음)   그렇다면 다중 스레드 기법이 더 효율적인 경우는 어떤 경우인가?     리퀘스트를 다른 스레드에서 처리하는 웹 서버   디버거. 한 스레드는 user input을 모니터링하고, 다른 스레드는 디버거 gui를 제공하고, 또 다른 스레드는 디버깅을 모니터링한다.   2. 단일 처리기 시스템에서의 프로그래밍을 고려하자. 다중 커널 스레드를 사용하여 다중 스레드 프로그램을 만들었을 때 이 프로그램의 성능이 단일 스레드만 사용하는 프로그램에 비해 더 나은 성능을 보이는 경우는 언제인가?     단일 처리기이기 때문에 연산 속도는 늘릴 수 없지만, 사용자 인터렉션 면에서는 더 나은 성능을 보일 수 있다. 여러 스레드가 시스템에 적재되어 있고, 각각의 스레드가 사용자의 요청에 반응하도록 구현한다면 사용자의 다양한 반응에 대응할 수 있을 것이다.   한 커널 스레드가 page fault의 문제를 가지고 있을 때, 다른 커널 스레드로 교체됨으로서 효율적인 방식을 구현할 수 있다. 하지만 싱글 스레드에서는 page fault가 발생할 때 멀티스레드처럼 효율적이게 대처할 수 없다. 따라서 page fault가 빈번하게 일어날 때 멀티스레드가 더 효율적이게 작동할 수 있다.   3. 다음 중 다중 스레드 프로세스의 스레드 사이에 공유되는 프로그램 상태는 무엇인가?     b. 힙 메모리, c. 전역 변수들   a. 레지스터 값들, d. 스택 메모리는 스레드 별로 별도로 가지고 있다.   4. 다수의 사용자 수준 스레드를 사용하는 다중 스레드 해결책이 단일 처리기 시스템보다 다중 처리기 시스템에서 더 나은 성능을 보일 수 있는가?     아니다. 커널은 사용자 수준 스레드가 생성이 될 때 알지 못한다. 따라서 사용자 수준 스레드를 다른 프로세스에서 사용할 수 없다.   What are two differences between user-level threads and kernel-level threads? Under what circumstances is one type better than the other?  유저 레벨 스레드와 커널 레벨 스레드의 차이점은 무엇인가? 어떤 상황에서 어떤 스레드가 더 나은 성능을 보이는가?                  유저 레벨 스레드       커널 레벨 스레드                       유저 레벨 스레드는 커널에서 존재를 알 수 없다.       커널 레벨 스레드는 커널에서 존재를 알 수 있다.                 유저 레벨 스레드는 커널의 도움 없이 사용된다.       커널 레벨 스레드는 OS의 관리 하에 사용된다.                 유저 레벨 스레드는 커널 레벨 스레드보다 생성하는게 빠르다.       커널 레벨 스레드는 유저 레벨 스레드보다 생성하는 것이 느리다.                 유저 레벨 스레드는 스레드 라이브러리를 통해 스케쥴링 된다.       커널 레벨 스레드는 커널에 의해 스케쥴링 된다.              유저 레벨 스레드가 더 효율적인 경우            시분할 시스템이라면 문맥 교환이 빈번하게 일어나기 때문에 유저 레벨 스레드가 더 효율적이다.       커널 스레드 레벨에서의 문맥 교환은 오버헤드가 크기 때문이다.           커널 레벨 스레드가 더 효율적인 경우            커널이 싱글코어라면 커널 레벨 스레드가 더 효율적이다.       유저 레벨 시스템이 시스템 콜을 blocking 하게 되면 다른 스레드가 어플리케이션을 실행 할 수 있음에도 프로세스 전체가 블록 당할 수 있다.       예를 들어 P1 프로세스는 2개의 커널 레벨 스레드를 가지고 있고, P2 프로세스는 2개의 유저 레벨 스레드를 가지고 있다고 하자. P1 프로세스는 첫번째 스레드가 블록 당해도, 다른 스레드에 영향을 끼치지 않지만 P2 프로세스는 첫 번째 스레드가 블록 당하면 P2 프로세스 전체가 블록 당하게 된다.       멀티프로세서 환경에서 커널 레벨 스레드가 더 효율적이다. 커널 레벨 스레드는 다른 프로세스에서 동시에 실행 가능하지만 유저 레벨 프로세스는 여러개의 프로세스를 실행 시킬 수 있어도 하나의 프로세스에만 작동한다.           3장에서 Google의 Chrome 브라우저에 대해서 논의할 때 새로운 웹사이트마다 개별 프로세스에서 연다는 것을 알았다. 만일 새로운 웹사이트를 프로세스 대신에 개별 스레드에서 열었다면 같은 이득을 얻을 수 있었을까?     개별 스레드에서 열었다면 한 스레드에서 오류 발생 시 다른 스레드도 영향을 받을 수 있다. 같은 이득을 얻을 수 없다.   6. 병렬성은 아니지만 동시 수행성을 가지는 것이 가능한가?     가능하다.   동시 수행성            여러 개의 서로 다른 프로세스 또는 스레드가 겹치는 기간에 함께 작동하기 시작하는 것을 의미하지만 동일한 순간에 실행되는 것은 아님.           병렬성            둘 이상의 다른 작업이 동시에 실행을 시작. 즉, 두 작업 또는 스레드가 동시에 작동하기 시작.           따라서 문맥 교환을 매우 빠르게 실행하면 동시 실행성을 갖출 수 있다.  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch4.-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[백준 3678] 카탄의 개척자",
        "excerpt":"[백준 3678] 카탄의 개척자  문제 링크   #include \"header.h\" using namespace std; int c; int katan[10004]; int frequency[6]; int possible[6] = {1, 1, 1, 1, 1, 1}; void solve() {      int border = 1;  // 테두리가 몇 겹인지     int cur = 1;  // 커서     int inner = 1; //안쪽 타일      katan[1] = 1;     frequency[1]++;      // 해당 인덱스의 인접 행렬 구하기     for (int i = 2; i &lt;= 10000; i++) {         for(int p = 1; p&lt;= 5; p++){             possible[p] = 1;         }         //1, 7, 19, 37...는 테두리가 새로 생김         if(border * 6 + 1 == cur){             border++;             cur = 1;         }                  // 마지막 타일         if(cur == border * 6){             possible[katan[inner + 1]] = 0;         }                  if(cur % border != 0){ //꼭짓점이 아니라면             inner++;             possible[katan[inner]] = 0;         }          possible[katan[inner]] = 0;         possible[katan[i - 1]] = 0;         cur++;          // 인접 행렬들을 업데이트 했으니         // 그 중에서 가장 적게 사용한 것 고르기         int less = 987654321;         int lessIdx = 0;          for (int c = 1; c &lt;= 5; c++) {             if (possible[c] &amp;&amp; less &gt; frequency[c]) {  //가장 적게 쓴 것                 less = frequency[c];                 lessIdx = c;             }         }         katan[i] = lessIdx;         frequency[lessIdx]++;     } } int main() {     solve();      int c;     cin &gt;&gt; c;     for (int j = 0; j &lt; c; j++) {         int num;         cin &gt;&gt; num;         cout &lt;&lt; katan[num] &lt;&lt; endl;     }      return 0; }        각 타일마다 인접한 타일들을 찾아 0으로 바꿔준다.   새로운 테두리가 생기면 border * 6 + 1 == cur (i = 8, 20, 38… )            2개가 인접한다. i-1, inner       테두리 +1       커서를 1로 초기화           테두리의 마지막 타일은 border * 6 == cur (i = 7, 19, 37…)            3개가 인접한다. i-1, inner, inner + 1           그 외의 경우에서            꼭지점은 border의 크기만큼 간격을 가지기 때문에 border % cur를 해 주었다.                    꼭지점인 경우                       2개 인접한다. i-1, inner                    꼭지점이 아닌 경우                       3개 인접한다. i-1, inner + 1, inner           인접한 타일들을 제외한 것중, 제일 적게 쓴 것을 구한다.   초과 &gt;로 비교하여 만약 같은 숫자가 있을 경우 제일 작은 인덱스를 저장하게 해 주었다.   답을 업데이트 후 커서를 +1 하고 반복한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-3678-%EC%B9%B4%ED%83%84%EC%9D%98-%EA%B0%9C%EC%B2%99%EC%9E%90/",
        "teaser": null
      },{
        "title": "[프로그래머스] 길 찾기 게임",
        "excerpt":"[프로그래머스] 길 찾기 게임  문제 링크   #include &lt;string&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; using namespace std; typedef struct Node {     int num;     int val;     Node *left;     Node *right; } Node; vector &lt;int&gt; pre; vector &lt;int&gt; post;  int cmp(vector&lt;int&gt; a, vector&lt;int&gt; b) {     if (a[1] &gt;= b[1]) {         if (a[1] == b[1]) {             if (a[0] &gt; b[0]) {                 return true;             }             return false;         }         return true;     }     return false; }  void preOrder(Node * head){     if(head == NULL) return;     pre.push_back(head-&gt;num);     preOrder(head-&gt;left);     preOrder(head-&gt;right); } void postOrder(Node * head){     if(head == NULL) return;     postOrder(head-&gt;left);     postOrder(head-&gt;right);     post.push_back(head-&gt;num); } Node * createNode(int val, int num){     Node *newNode = (Node *)malloc(sizeof(Node));     newNode-&gt;val = val;     newNode-&gt;num = num;     newNode-&gt;left = NULL;     newNode-&gt;right = NULL;     return newNode; } vector&lt;vector&lt;int&gt;&gt; solution(vector&lt;vector&lt;int&gt;&gt; nodeinfo) {     vector&lt;vector&lt;int&gt;&gt; answer;      for (int i = 0; i &lt; nodeinfo.size(); i++) nodeinfo[i].push_back(i + 1);     sort(nodeinfo.begin(), nodeinfo.end(), cmp);      Node *head = createNode(nodeinfo[0][0], nodeinfo[0][2]);     int level = nodeinfo[0][1];  // 6          //트리 구현     for (int i = 1; i &lt; nodeinfo.size(); i++) {         Node *cur = head;          int now_val = nodeinfo[i][0];         int now_level = nodeinfo[i][1];         int now_num = nodeinfo[i][2];          //값 비교         while (1) {             if (cur-&gt;val &lt; now_val) {                 if (cur-&gt;right != NULL)                     cur = cur-&gt;right;                 else {                     cur-&gt;right = createNode(now_val, now_num);                     break;                 }             } else {                 if (cur-&gt;left != NULL)                     cur = cur-&gt;left;                 else {                     cur-&gt;left = createNode(now_val, now_num);                     break;                 }             }         }     }      preOrder(head);     postOrder(head);      answer.push_back(pre);     answer.push_back(post);      return answer; }      트리 구현 문제.   nodeinfo에 들어온 순서를 추가 해 준다.   nodeinfo를 y가 큰 순서, x가 큰 순서대로 정렬을 해 준다.   다음은 그냥 트리 구현   전위순회, 후위순회 진행하면 끝  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B8%B8-%EC%B0%BE%EA%B8%B0-%EA%B2%8C%EC%9E%84/",
        "teaser": null
      },{
        "title": "[백준 1522] 문자열 교환",
        "excerpt":"[백준 1522] 문자열 교환  문제 링크   #include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std; string str;  void solve(){     int n = str.length();     int cnt = 0;     for(int i=0; i&lt;n; i++){         if(str[i] == 'a'){             cnt++;         }     }      if(cnt == 0) {         cout &lt;&lt; 0 &lt;&lt; endl;         return;     }      int ans = 987654321;     for(int i=0; i&lt;n; i++){         int temp_cnt = 0;         for(int j=i; j&lt;i + cnt; j++){             if(str[j % n] == 'b'){                 temp_cnt++;             }         }         ans = min(ans, temp_cnt);     }      cout &lt;&lt; ans &lt;&lt; endl; }  int main() {      cin &gt;&gt; str;     solve();      return 0; }      모든 b를 a로 만드는줄 알았는데, 그게 아니라 모든 a를 인접하게 만드는 것이다.   맨 처음, 모든 a의 갯수를 센다.   a의 갯수가 0이라면 모든 a가 인접해있으므로 0을 리턴한다.   문자열의 길이만큼 돌면서, a의 갯수만큼 윈도우를 정하고, b의 갯수를 센다.   한 칸씩 윈도우를 옮긴다. 단, 환형이기 때문에 모듈화 연산을 해줘야 한다.   이 때 b의 갯수의 최솟값이 답이다.   b의 갯수의 최솟값이라는 의미가 교환 해야할 b의 갯수가 제일 적다는 뜻이기 때문이다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1522-%EB%AC%B8%EC%9E%90%EC%97%B4-%EA%B5%90%ED%99%98/",
        "teaser": null
      },{
        "title": "[백준 6087] 레이져 통신",
        "excerpt":"[백준 6087] 레이져 통신  문제 링크   #include \"header.h\" using namespace std; int W, H; int ans = 987654321; char map_[101][101]; int dist[101][101]; int visit[101][101]; vector&lt;pair&lt;int, int&gt;&gt; C; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; void input() {     cin &gt;&gt; W &gt;&gt; H;     for (int i = 0; i &lt; H; i++) {         string s;         cin &gt;&gt; s;         for (int j = 0; j &lt; s.length(); j++) {             map_[i][j] = s[j];             if (map_[i][j] == 'C') {                 C.push_back({i, j});             }         }     } }  void solve() {     int start_x = C[0].first;     int start_y = C[0].second;      int dest_x = C[1].first;     int dest_y = C[1].second;      queue &lt;pair&lt;int, int&gt;&gt; q;     q.push({start_x, start_y}); // 시작점 넣기     visit[start_x][start_y] = 1;     dist[start_x][start_y] = 0;      while(!q.empty()){         int x = q.front().first;         int y = q.front().second;         q.pop();         for(int i=0; i&lt;4; i++){             int nx = x + dx[i];             int ny = y + dy[i];              while(map_[nx][ny] != '*' &amp;&amp; nx &gt;=0 &amp;&amp; ny &gt;=0 &amp;&amp; nx &lt; H &amp;&amp; ny &lt; W){                 if(!visit[nx][ny]){                     visit[nx][ny] = 1;                     dist[nx][ny] = dist[x][y] + 1;                     q.push({nx, ny});                 }                 nx += dx[i];                 ny += dy[i];             }          }     }      //꺾인 수이기 때문에 -1 해주어야 함!     cout &lt;&lt; dist[dest_x][dest_y] -1 &lt;&lt; endl; } int main() {     input();     solve();      return 0; }      bfs 좀만 꽈도 못푸는 나 :)..   처음엔 삼차원 배열로 상, 하, 좌, 우의 경우도 탐색 해주었는데, 잘 안됐다.   그래서 갈 수 있는 직선을 모두 탐색하고, 방향 전환해 주는 식으로 풀었다.   dist에 몇 번 꺾었는지를 표시 해 준다. dist[nx][ny] = dist[x][y] + 1   최종 답은 도착 좌표의 dist값에서 -1을 해 주어야 한다. 꺾인 횟수니까 거울의 갯수는 꺾인 수 - 1이기 때문이다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-6087-%EB%A0%88%EC%9D%B4%EC%A0%B8-%ED%86%B5%EC%8B%A0/",
        "teaser": null
      },{
        "title": "[백준 2933] 미네랄",
        "excerpt":"[백준 2933] 미네랄  문제 링크   #include \"header.h\" using namespace std; int R, C, N; char map_[101][101]; vector&lt;int&gt; order; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; int visit[101][101]; int cluster_visit[101][101]; void input() {     cin &gt;&gt; R &gt;&gt; C;     for (int i = 0; i &lt; R; i++) {         for (int j = 0; j &lt; C; j++) {             cin &gt;&gt; map_[i][j];         }     }      cin &gt;&gt; N;     for (int i = 0; i &lt; N; i++) {         int n;         cin &gt;&gt; n;         order.push_back(n);     } } void print() {     for (int i = 0; i &lt; R; i++) {         for (int j = 0; j &lt; C; j++) {             cout &lt;&lt; map_[i][j];         }         cout &lt;&lt; endl;     } } int throw_sphere(int order, int isLeft) {     if (isLeft) {         for (int i = 0; i &lt; C; i++) {             if (map_[R - order][i] == 'x') {                 map_[R - order][i] = '.';                 return 1;             }         }     } else {         for (int i = C - 1; i &gt;= 0; i--) {             if (map_[R - order][i] == 'x') {                 map_[R - order][i] = '.';                 return 1;             }         }     }      return 0; } void bfs(int x, int y) {     queue&lt;pair&lt;int, int&gt;&gt; q;     q.push({x, y});     visit[x][y] = 1;     while (!q.empty()) {         int top_x = q.front().first;         int top_y = q.front().second;         q.pop();          for (int i = 0; i &lt; 4; i++) {             int nx = top_x + dx[i];             int ny = top_y + dy[i];              if (visit[nx][ny] || map_[nx][ny] == '.' || nx &lt; 0 || ny &lt; 0 || nx &gt;= R || ny &gt;= C) continue;              q.push({nx, ny});             visit[nx][ny] = 1;         }     } }  void check() {     vector&lt;pair&lt;int, int&gt;&gt; cluster;     for (int i = 0; i &lt; C; i++) {         if (!visit[R - 1][i] &amp;&amp; map_[R - 1][i] == 'x') {             bfs(R - 1, i);         }     }      for (int i = 0; i &lt; R; i++) {         for (int a = 0; a &lt; C; a++) {             if (!visit[i][a] &amp;&amp; map_[i][a] == 'x') {                 cluster.push_back({i, a});             }         }     }      //down cluster     if (!cluster.empty()) {         int flag = 1;         int down = 1;         while (flag) {             for (int i = 0; i &lt; cluster.size(); i++) {                 int x = cluster[i].first + down;                 int y = cluster[i].second;                  if (visit[x][y] || x &gt;= R) {                     flag = 0;                     break;                 }             }              if (!flag) break;             down++;         }          for (int i = 0; i &lt; cluster.size(); i++) {             int x = cluster[i].first;             int y = cluster[i].second;              cluster_visit[x + down - 1][y] = 1;             map_[x + down - 1][y] = 'x';             if (!cluster_visit[x][y]) map_[x][y] = '.';         }          memset(cluster_visit, 0, sizeof(cluster_visit));     } }  void solve() {     int left = 1;     for (int i = 0; i &lt; N; i++) {  //창을 던진다         if (left) {             if (throw_sphere(order[i], left)) check();             left = 0;         } else {             if (throw_sphere(order[i], left)) check();             left = 1;         }         memset(visit, 0, sizeof(visit));     } } int main() {     input();     solve();     print();      return 0; }      bfs, 시뮬레이션 문제   창을 던진 후, 미네랄을 부셨다면 check()함수로 떨어진 클러스터가 있는지 확인한다.   땅에서부터 시작해 bfs로 방문 처리를 해 준다.   모든 맵을 돌면서 빙산인데도 방문 처리가 되지 않은 곳이 있다면 -&gt; 그곳이 클러스터이다.   클러스터들을 벡터에 넣어주고, 내려주는 작업을 한다.   카카오 프렌즈 열쇠 부분이 생각 나서 비슷한 방식으로 접근 했다.   클러스터들을 한칸 씩 내려가면서, 만약 다른 빙산이 있다면 (visit[x][y]가 존재하면) 최대한 내려간 것이므로 break를 해 준다.   내려 줄 때, 기존의 빙산과 겹칠 수도 있으니 클러스터 방문 배열로 겹치지 않도록 체크 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-2933-%EB%AF%B8%EB%84%A4%EB%9E%84/",
        "teaser": null
      },{
        "title": "[프로그래머스] 전화번호 목록",
        "excerpt":"[프로그래머스] 전화번호 목록  문제 링크   #include \"header.h\" using namespace std;  bool cmp(string a, string b){     return a.length() &lt; b.length(); } bool solution(vector&lt;string&gt; phone_book) {      sort(phone_book.begin(), phone_book.end(), cmp);      for(int i=0; i&lt;phone_book.size()-1; i++){         string target = phone_book[i];         for(int j=i+1; j&lt;phone_book.size(); j++){             string cmp = phone_book[j];             int flag = 1;             for(int k=0; k&lt;target.length(); k++){                 if(cmp[k] != target[k]){                     flag = 0;                     break;                 }             }             if(flag) return false;         }     }      return true; }     leetcode에서 비슷한 문제를 풀어봐서 그때랑 똑같이 풀었다.   가장 짧은 순서대로 정렬 한 다음에, 하나씩 다음 전화번호랑 비교한다.   하나라도 같지 않으면 flag = 0 해 주고 바로 break   flag가 1이라면 false를 리턴한다. (찾은 경우)  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%A0%84%ED%99%94%EB%B2%88%ED%98%B8-%EB%AA%A9%EB%A1%9D/",
        "teaser": null
      },{
        "title": "[React] 리액트 생명주기",
        "excerpt":"리액트 생명주기        리액트의 생명주기는 크게 마운트, 업데이트, 언마운트로 나뉘어져 있다.   마운트 : 컴포넌트가 페이지에 생성 될 때 실행  업데이트 : 컴포넌트가 리렌더링 될 때 실행  언마운트 : 컴포넌트가 페이지에서 사라질 때 실행   마운트     컴포넌트가 페이지에 생성 될 때 실행된다.            constructor       getDerivedStateFromProps                    props를 state로 변경 할 때 사용                       render       componentDidMount           업데이트     리렌더링 되는 요인은 다음과 같다.            props가 변경       state가 변경       부모 컴포넌트가 리렌더링       this.forceUpdate로 강제 렌더링           컴포넌트가 리렌더링 될 때 실행된다.            getDerivedStateFromProps       shouldComponentUpdate                    boolean 값을 반환 해야한다.           true일 시 render, false일 시 취소한다.           이 과정에서 컴포넌트 렌더링 성능을 개선할 수 있다.                       render       getSnapshotBeforeUpdate                    render의 결과물이 브라우저에 적용되기 전에 실행된다.           componentDidUpdate에서 3번째 인자 값으로 받을 수 있다.           업데이트 직전의 값을 참고할 일이 있을 때 사용한다.           ex) 스크롤바 위치 유지                       componentDidUpdate           언마운트     컴포넌트가 DOM에서 사라질 때 실행된다.            componentWillUnmount           오류 제어     컴포넌트에서 오류 발생 시 실행된다.   componentDidCatch            어떤 에러가 어디에서 생기는지 알 수 있다.          ","categories": ["react"],
        "tags": [],
        "url": "/react/React-%EB%A6%AC%EC%95%A1%ED%8A%B8-%EC%83%9D%EB%AA%85%EC%A3%BC%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[백준 2589] 보물섬",
        "excerpt":"[백준 2589] 보물섬  문제 링크   #include \"header.h\" using namespace std; char map_[51][51]; int visit[51][51]; int L, W; int ans; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0};  void input() {     cin &gt;&gt; L &gt;&gt; W;     for (int i = 0; i &lt; L; i++) {         for (int j = 0; j &lt; W; j++) {             cin &gt;&gt; map_[i][j];         }     } } void check() {     for (int i = 0; i &lt; L; i++) {         for (int j = 0; j &lt; W; j++) {             if(visit[i][j]){                 ans = max(ans, visit[i][j]);             }         }     } } void bfs(int x, int y) {     queue&lt;pair&lt;int, int&gt;&gt; q;      q.push({x, y});     visit[x][y] = 1;     int cnt = 1;      while (!q.empty()) {         int top_x = q.front().first;         int top_y = q.front().second;         q.pop();         for (int i = 0; i &lt; 4; i++) {             int nx = top_x + dx[i];             int ny = top_y + dy[i];              if (visit[nx][ny] || map_[nx][ny] == 'W' || nx &lt; 0 || ny &lt; 0 || nx &gt;= L || ny &gt;= W) continue;              visit[nx][ny] = visit[top_x][top_y] + 1;             q.push({nx, ny});         }     } } void solve() {     for (int i = 0; i &lt; L; i++) {         for (int j = 0; j &lt; W; j++) {             if (map_[i][j] == 'L') {                 bfs(i, j);                 check();                 memset(visit, 0, sizeof(visit));             }         }     } } int main() {     input();     solve();     cout &lt;&lt; ans - 1 &lt;&lt; endl;     return 0; }      모든 L에서 bfs를 돌린 후, 거리를 업데이트 해준다. visit[nx][ny] = visit[top_x][top_y] + 1   bfs 종료 후, 가장 먼 거리를 구하고 -1을 해준 것이 답이다. (1부터 시작했기 때문에)  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-2589-%EB%B3%B4%EB%AC%BC%EC%84%AC/",
        "teaser": null
      },{
        "title": "[백준 1062] 가르침",
        "excerpt":"[백준 1062] 가르침  문제 링크   using namespace std; int N, K, n; int answer; map&lt;char, int&gt; m; vector&lt;string&gt; learn; set&lt;char&gt; s; vector&lt;char&gt; v; void init() {      for(char i='a'; i&lt;='z'; i++){         m[i] = 0;     }     m['a'] = 1;     m['n'] = 1;     m['t'] = 1;     m['i'] = 1;     m['c'] = 1; } void input() {     init();     cin &gt;&gt; N &gt;&gt; K;     for (int i = 0; i &lt; N; i++) {         string str;         cin &gt;&gt; str;         string target = str.substr(4);         target = target.replace(target.find(\"tica\"), 4, \"\");         learn.push_back(target);         for (int j = 0; j &lt; target.size(); j++) {             if (m[target[j]])                 continue;             else {                 s.insert(target[j]);             }         }     } }  void check() {     int cnt = 0;      for (int i = 0; i &lt; learn.size(); i++) {         string cmp = learn[i];         int flag = 1;         for (int j = 0; j &lt; cmp.length(); j++) {             if (!m[cmp[j]]) {                 flag = 0;                 break;             }         }         if (flag) cnt++;     }      answer = max(answer, cnt); } void dfs(vector&lt;char&gt;&amp; v, int idx, int cnt) {     if(cnt &gt; n) return;     if(K-5 &lt; 0) return;     if(cnt == n){         check();     }      for (int i = idx; i &lt; v.size(); i++) {         if (!m[v[i]]) {             m[v[i]] = 1;             cnt++;             dfs(v, i + 1, cnt);             cnt--;             m[v[i]] = 0;         }     } } void solve() {     n = K - 5;  //배울 수 있는 갯수     int answer = 0;      v.assign(s.begin(), s.end());  // 가르쳐야 할 단어들     if(v.size() &lt; n) n = v.size();      dfs(v, 0, 0); } int main() {     input();     solve();     cout &lt;&lt; answer &lt;&lt; endl;      return 0; }      백트래킹으로 푸는 문제이다.   anta, tica를 제외한 문장들을 벡터에 넣는다.   이 과정에서 set에 배워야하는 문자들을 넣는다.   그리고 a, n, t, i, c 는 이미 배운 문자이므로 1로 처리 해 준다.   K-5가 배울 수 있는 문자의 갯수이다.   배울 수 있는 문자의 갯수만큼 센 뒤, check()함수를 통해 answer를 업데이트 시켜준다.   이렇게 하면, 배워야 하는 문자들의 모든 경우의 수를 탐색할 수 있다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1062-%EA%B0%80%EB%A5%B4%EC%B9%A8/",
        "teaser": null
      },{
        "title": "[프로그래머스] 쇠막대기",
        "excerpt":"[프로그래머스] 쇠막대기  문제 링크   #include &lt;string&gt; #include &lt;vector&gt; #include &lt;stack&gt; using namespace std;  int solution(string str) {     int answer = 0;     stack &lt;char&gt; st;      int flag = 0;     for(int i=0; i&lt;str.length(); i++){         if(str[i] == '('){             st.push('(');             flag = 1;         }else{             st.pop();             if(flag){                 //laser                 answer += st.size();             }else{                 answer += 1;             }             flag = 0;         }     }               return answer; }        (이면 stack에 넣어주고, 레이저 판별을 위해 flag를 1로 바꿔준다.   )이면 stack에서 pop을 해주고, 레이저라면 stack의 사이즈만큼 답을 더해준다.   레이저가 아니라면 한 개의 쇠막대기가 끝났기 때문에 +1을 해 준다.   flag를 초기화 시켜준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%87%A0%EB%A7%89%EB%8C%80%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[백준 4179] 불",
        "excerpt":"[백준 4179] 불  문제 링크   #include \"header.h\" using namespace std; int R, C; char map_[1001][1001]; int visit[1001][1001]; int fire_map[1001][1001];  int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; pair &lt;int, int&gt; jihoon; queue &lt;pair&lt;int, int&gt;&gt; fire;  void input(){     cin &gt;&gt; R &gt;&gt; C;      for(int i=0; i&lt;R; i++){         for(int j=0; j&lt;C; j++){             cin &gt;&gt; map_[i][j];             if(map_[i][j] == 'J'){                 jihoon = {i, j};                 map_[i][j] = '.';             }             if(map_[i][j] == 'F'){                 fire.push({i, j});                 fire_map[i][j] = 1;             }         }     } } void spread_fire(){      while (!fire.empty()){         int top_x = fire.front().first;         int top_y = fire.front().second;         fire.pop();          for(int i=0; i&lt;4; i++){             int nx = top_x + dx[i];             int ny = top_y + dy[i];             if(fire_map[nx][ny] || map_[nx][ny] == '#' || nx &lt; 0 || ny &lt; 0 || nx &gt;= R || ny &gt;= C) continue;              fire_map[nx][ny] = fire_map[top_x][top_y] + 1;             fire.push({nx, ny});         }     } } void solve(){      spread_fire();      queue &lt;pair&lt;int, int&gt;&gt; q;     visit[jihoon.first][jihoon.second] = 1;     q.push({jihoon.first, jihoon.second});     int flag = 0;     int ans = 0;     while (!q.empty()){         int top_x = q.front().first;         int top_y = q.front().second;         q.pop();          for(int i=0; i&lt;4; i++){             int nx = top_x + dx[i];             int ny = top_y + dy[i];             if(map_[nx][ny] == '#' || visit[nx][ny]) continue;              if(nx &lt; 0 || ny &lt; 0 || nx &gt;= R || ny &gt;= C){ //탈출 한 경우                 flag = 1;                 ans = visit[top_x][top_y];                 break;             }                          if(fire_map[nx][ny] &amp;&amp; fire_map[nx][ny] &lt;= visit[top_x][top_y] + 1) {                 flag = 0;                 continue;             }              q.push({nx, ny});             visit[nx][ny] = visit[top_x][top_y] + 1;         }         if(flag) break;     }      if(!flag) cout &lt;&lt; \"IMPOSSIBLE\" &lt;&lt; endl;     else cout &lt;&lt; ans &lt;&lt; endl; } int main() {     input();     solve();     return 0; }      bfs로 풀었다.   일단 불을 bfs돌려서 퍼지는 날짜를 update 해 준다.   그 다음 지훈이를 움직이는데, 이 때 이미 불이 퍼진 날짜는 피해서 움직여준다.   불이 없는 경우를 판별하기 위해서, 가장자리 체크 할 때 fire_map[nx][ny]가 있는지 체크 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-4179-%EB%B6%88/",
        "teaser": null
      },{
        "title": "[백준 1339] 단어 수학",
        "excerpt":"[백준 1339] 단어 수학  문제 링크   #include &lt;header.h&gt; using namespace std; int N; int ans = 0; map&lt;char, int&gt; m; vector&lt;string&gt; words; int visit[11]; set&lt;char&gt; s; vector&lt;char&gt; v; void input() {     cin &gt;&gt; N;     for (int i = 0; i &lt; N; i++) {         string str;         cin &gt;&gt; str;         words.push_back(str);         for (int j = 0; j &lt; str.length(); j++) {             s.insert(str[j]);         }     }      v.assign(s.begin(), s.end()); }  void calc() {      int cnt = 0;     for(int i=0; i&lt;words.size(); i++){         int n = 0;         for(int j=0; j&lt;words[i].length(); j++){             n *= 10;             n += m[words[i][j]];         }         cnt += n;     }     ans = max(ans, cnt); }  void dfs(int cnt) {     if(cnt &gt; v.size()) return;     if (cnt == v.size()) {         calc();     }     for (int j = 9; j &gt;= 0; j--) {         if (!visit[j] &amp;&amp; !m[v[cnt]]) {             visit[j] = 1;             m[v[cnt]] = j;             dfs(cnt + 1);             m[v[cnt]] = 0;             visit[j] = 0;         }     } } int main() {     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);     input();     dfs(0);      cout &lt;&lt; ans &lt;&lt; endl;     return 0; }      백트래킹 문제   set으로 조합을 만들어야 하는 알파벳들만 구한다.   dfs를 돌면서 알파벳마다 하나씩 숫자를 조합 해 본다.   모든 알파벳에 숫자를 할당했다면, calc를 통해 값을 구하고, 최댓값을 업데이트 해 준다.   pow때문에 시간초과가 났다. pow 사용은 지양하도록 하자.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1339-%EB%8B%A8%EC%96%B4-%EC%88%98%ED%95%99/",
        "teaser": null
      },{
        "title": "[백준 14225] 부분수열의 합",
        "excerpt":"[백준 14225] 부분수열의 합  문제 링크   #include \"header.h\" using namespace std; #define MAX 2000005 int N; vector &lt;int&gt; numbers; int visit[24]; int can[MAX]; void input(){     cin &gt;&gt; N;     for(int i=0; i&lt;N; i++){         int n;         cin &gt;&gt; n;         numbers.push_back(n);     } }  void dfs(int now, int idx){          can[now] = 1;      for(int i=idx; i&lt;numbers.size(); i++){         if(!visit[i]){             visit[i] = 1;             dfs(now + numbers[i], i+1);             visit[i] = 0;         }     }  }  int main() {     ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);     input();     dfs(0, 0);      for(int i=0; i&lt;MAX; i++){         if(!can[i]){             cout &lt;&lt; i &lt;&lt; endl;             break;         }     }       return 0; }      dfs로 만들 수 있는 부분수열을 모두 구한다.   can 배열에 구한 부분수열을 체크 해 준다.   dfs 종료 이후, can이 0인 제일 작은 숫자를 구한다.   범위를 조심해야 한다. 100000 * 20 으로 2백만으로 해 주었다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-14225-%EB%B6%80%EB%B6%84%EC%88%98%EC%97%B4%EC%9D%98-%ED%95%A9/",
        "teaser": null
      },{
        "title": "[백준 1941] 소문난 칠공주",
        "excerpt":"[백준 1941] 소문난 칠공주  문제 링크   #include \"header.h\" using namespace std; char classroom[10][10]; int visit[30]; int ans; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; void input() {     for (int i = 0; i &lt; 5; i++) {         for (int j = 0; j &lt; 5; j++) {             cin &gt;&gt; classroom[i][j];         }     } }  bool bfs(int x, int y) {      int q_visit[10][10];     memset(q_visit, 0, sizeof(q_visit));      queue&lt;pair&lt;int, int&gt;&gt; q;     q.push({x, y});     q_visit[x][y] = 1;     int cnt = 1;      while (!q.empty()) {         int topx = q.front().first;         int topy = q.front().second;         q.pop();          for (int i = 0; i &lt; 4; i++) {             int nx = topx + dx[i];             int ny = topy + dy[i];             if (nx &lt; 0 || ny &lt; 0 || nx &gt;= 5 || ny &gt;= 5 || q_visit[nx][ny]) continue;              if (visit[nx * 5 + ny]) {                 cnt++;                 q.push({nx, ny});                 q_visit[nx][ny] = 1;             }         }     }      if (cnt == 7) return true;     else return false; }  void check_adj() {     for (int i = 0; i &lt; 25; i++) {         if (visit[i]) {                             if (bfs(i / 5, i % 5)) {                 ans++;             }             return;         }     } } void dfs(int idx, int cnt, int S) {     if (cnt == 7 &amp;&amp; S &gt;= 4) {         check_adj();         return;     }      for (int i = idx; i &lt; 25; i++) {         if (!visit[i]) {             visit[i] = 1;             if (classroom[i / 5][i % 5] == 'S')                 dfs(i + 1, cnt + 1, S + 1);             else                 dfs(i + 1, cnt + 1, S);             visit[i] = 0;         }     } } int main() {     input();     dfs(0, 0, 0);     cout &lt;&lt; ans &lt;&lt; endl;     return 0; }      dfs + bfs 문제   처음엔 백트래킹으로 접근해서 인접하는 7개 -&gt; count 하는 식으로 했는데, 중복을 처리할 수가 없어서 실패했다.   중복 처리를 위해 5*5가 아닌 일차원 배열인 25로 접근했다.   7명을 만들 수 있는 모든 경우의 수를 구하고, S가 4개 이상인 경우, 인접한지 확인한다.   bfs로 인접여부를 확인하고, 모두 인접 했다면 (cnt가 7개라면) 답을 +1 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1941-%EC%86%8C%EB%AC%B8%EB%82%9C-%EC%B9%A0%EA%B3%B5%EC%A3%BC/",
        "teaser": null
      },{
        "title": "[백준 1939] 중량제한",
        "excerpt":"[백준 1939] 중량제한  문제 링크   #include \"header.h\" #define MAX 1000000000 using namespace std; int N, M; int x, y; int visit[10001]; vector&lt;pair&lt;int, int&gt;&gt; graph[100001]; void input() {     cin &gt;&gt; N &gt;&gt; M;      int a, b, c;      for (int i = 0; i &lt; M; i++) {         cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;         graph[a].push_back({b, c});         graph[b].push_back({a, c});     }      //공장이 위치한 곳     cin &gt;&gt; x &gt;&gt; y; } bool bfs(int mid) {      memset(visit, 0, sizeof(visit));     queue&lt;int&gt; q;     q.push(x);     visit[x] = 1;      while (!q.empty()) {         int top = q.front();         q.pop();          //도착 했을 경우         if (top == y) {             return true;         }          for (int i = 0; i &lt; graph[top].size(); i++) {             int next = graph[top][i].first;             int cost = graph[top][i].second;              //top 연결된 것들 중             if (!visit[next] &amp;&amp; mid &lt;= cost) {                 visit[next] = 1;                 q.push(next);             }         }     }      return false;  //불가능 }  void solve() {     int left = 0;     int right = MAX;     int mid = 0;     while (left &lt;= right) {         mid = (left + right) / 2;  //옮길 수 잇는 무게         bool ret = bfs(mid);          if (ret) {  // 가능             left = mid + 1;         } else {             right = mid - 1;         }      }      cout &lt;&lt; right &lt;&lt; endl; } int main() {     ios::sync_with_stdio(false);     cin.tie(NULL);     cout.tie(NULL);      input();     solve();      return 0; }      bfs + 이분 탐색으로 풀었다.   메모리 초과 때문에 고생.. cost[][]로 따로 가중치를 저장 해 뒀는데 여기서 메모리 초과가 나서 vector&lt;pair&lt;int, int&gt;&gt;[]로 바꿔줬다.   이분탐색으로 건너갈 수 있는 무게의 최솟값을 구한다.   시작점부터 연결 된 곳 까지 반복문을 돌면서, 무게를 넘지 않고, 방문하지 않은 곳을 큐에 넣어주며 반복한다.   도착점에 도착 했을 경우 true리턴, 아니라면 false 리턴한다.   true가 리턴 되면 좀 더 큰 것을 옮겨보고, 아니라면 좀 더 작은 것을 옮겨본다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1939-%EC%A4%91%EB%9F%89%EC%A0%9C%ED%95%9C/",
        "teaser": null
      },{
        "title": "[TIL] javascript split()",
        "excerpt":"String.prototype.split()  문자열을 배열로 변환시킨다.   str.split([seperator[, limit]]);     seperator : 문자열을 쪼개는 단위. string이나 regex        limit : 리턴되는 배열의 갯수 제한.       단, 유니코드에선 제대로 동작하지 않을 수 있다.   const ret = '𝟘𝟙𝟚𝟛'.split('');  console.log(ret); //[\"�\", \"�\", \"�\", \"�\", \"�\", \"�\", \"�\", \"�\"]    Suggestions!   1. spread syntax  2. Array.from()  3. /u    const str = \"hello, 𝟘𝟙𝟚𝟛!\";  // 1. spread syntax const spread = [...str]; console.log(spread);  // 2. Array.from() const from = Array.from(str); console.log(from);  // 3. /u const regex = str.split(/(?=[\\s\\S])/u); console.log(regex);  // all output &gt; Array [\"h\", \"e\", \"l\", \"l\", \"o\", \" \", \"𝟘\", \"𝟙\", \"𝟚\", \"𝟛\", \"!\"]     split을 사용하여 문자열을 뒤집을 수 있다.  const str = \"거꾸로\"; const reversed = str.split('').reverse().join('');  console.log(reversed); //로꾸거  ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-javascript-split()/",
        "teaser": null
      },{
        "title": "[백준 2931] 가스관",
        "excerpt":"[백준 2931] 가스관  문제 링크   #include \"header.h\" using namespace std; int R, C; char board[30][30]; int dir;  //상 하 좌 우 int dx[4] = {-1, 1, 0, 0}; int dy[4] = {0, 0, -1, 1}; pair&lt;int, int&gt; start; void input() {     cin &gt;&gt; R &gt;&gt; C;     for (int i = 0; i &lt; R; i++) {         for (int j = 0; j &lt; C; j++) {             cin &gt;&gt; board[i][j];              if (board[i][j] == 'M') {                 start = {i, j};             }          }     } } void addPipe(int x, int y){          int dir_check[4] = {0, };     vector&lt;char&gt; pipe = {'|', '-', '+', '1', '2', '3', '4'};      for(int i=0; i&lt;4; i++){         int nx = x + dx[i];         int ny = y + dy[i];          if(board[nx][ny] == '.' || nx &lt; 0 || ny &lt; 0 || nx &gt;= R || ny &gt;= C) continue;          if((i == 0) &amp;&amp; (board[nx][ny] == '|' || board[nx][ny] == '+'                         || board[nx][ny] == '1' || board[nx][ny] == '4')){             dir_check[i] = 1;         }else if((i == 1) &amp;&amp; (board[nx][ny] == '|' || board[nx][ny] == '+'                         || board[nx][ny] == '2' || board[nx][ny] == '3')){             dir_check[i] = 1;         }else if((i == 2) &amp;&amp; (board[nx][ny] == '-' || board[nx][ny] == '+'                         || board[nx][ny] == '1' || board[nx][ny] == '2')){             dir_check[i] = 1;         }else if((i == 3) &amp;&amp; (board[nx][ny] == '-' || board[nx][ny] == '+'                         || board[nx][ny] == '3' || board[nx][ny] == '4')){             dir_check[i] = 1;         }     }      char ret;      if(dir_check[0] &amp;&amp; dir_check[1] &amp;&amp; dir_check[2] &amp;&amp; dir_check[3]) ret = '+';     else if(dir_check[0] &amp;&amp; dir_check[1]) ret = '|';     else if(dir_check[1] &amp;&amp; dir_check[2]) ret = '4';     else if(dir_check[2] &amp;&amp; dir_check[3]) ret = '-';     else if(dir_check[0] &amp;&amp; dir_check[3]) ret = '2';     else if(dir_check[1] &amp;&amp; dir_check[3]) ret = '1';     else if(dir_check[0] &amp;&amp; dir_check[2]) ret = '3';      cout &lt;&lt; x + 1 &lt;&lt; ' ' &lt;&lt; y + 1 &lt;&lt; ' ' &lt;&lt; ret &lt;&lt; endl; }  void findDot(int x, int y, int dir){      if(board[x][y] == '.'){         // found         addPipe(x, y);         return;     }      int nx = x + dx[dir];     int ny = y + dy[dir];  \tif (dir == 0) { \t\tif (board[nx][ny] == '1') dir = 3; \t\telse if (board[nx][ny] == '4') dir = 2; \t} \telse if (dir == 1) { \t\tif (board[nx][ny] == '2') dir = 3; \t\telse if (board[nx][ny] == '3') dir = 2; \t} \telse if (dir == 2) { \t\tif (board[nx][ny] == '1') dir = 1; \t\telse if (board[nx][ny] == '2') dir = 0; \t} \telse if (dir == 3) { \t\tif (board[nx][ny] == '3') dir = 0; \t\telse if (board[nx][ny] == '4') dir = 1; \t}  \tfindDot(nx, ny, dir);     return; } void solve() {      for (int i = 0; i &lt; 4; i++) {         //상하좌우 넣기         int nx = dx[i] + start.first;         int ny = dy[i] + start.second;          if(nx == start.first &amp;&amp; ny == start.second) continue;         if (nx &lt; 0 || ny &lt; 0 || nx &gt;= R || ny &gt;= C) continue;         if (board[nx][ny] != '.') {             dir = i;         }     }      findDot(start.first, start.second, dir);  } int main() {     input();     solve();     return 0; }      dfs로 푸는 문제   처음에 접근했던 방식은 점을 bfs로 찾기 -&gt; 찾은 점에 모든 파이프 대입 -&gt; 다시 bfs 돌려서 Z에 도달하면 정답        이런식으로 접근 했는데 너무 코드가 길어지고 방향을 체크하는데에 문제가 생겨서 다른 분의 코드를 참고하였다.       M과 Z는 단 한개의 블록만 붙어있으므로, 4방향을 탐색 하여 붙은 방향이 어디인지 확인한다.   dfs로 파이프를 판별하면서 파이프를 따라 이동한다.   이 때 .을 만나게 되면, 파이프를 연결한다.   파이프를 연결하는 과정은 해당 .의 4방향의 파이프에 의해서 결정 된다.   dir_check라는 크기 4의 배열로 어떤 방향이랑 파이프가 연결 돼야 하는지 확인한다.   check가 된 부분으로 빠진 파이프를 판별한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-2931-%EA%B0%80%EC%8A%A4%EA%B4%80/",
        "teaser": null
      },{
        "title": "[프로그래머스] 가장 먼 노드",
        "excerpt":"[프로그래머스] 가장 먼 노드  문제 링크   #include &lt;string&gt; #include &lt;vector&gt; #include &lt;queue&gt; using namespace std;  vector &lt;int&gt; v[20001]; queue &lt;pair&lt;int, int&gt;&gt; q; int visit[20001]; int solution(int n, vector&lt;vector&lt;int&gt;&gt; edge) {     int answer = 0;          for(int i=0; i&lt;edge.size(); i++){         int from = edge[i][0];         int to = edge[i][1];                  v[from].push_back(to);         v[to].push_back(from);     }          q.push({1, 0});     visit[1] = 1;     int max_distance = 0;          while(!q.empty()){         int vertex = q.front().first;         int distance = q.front().second;         q.pop();                  for(int i=0; i&lt;v[vertex].size(); i++){             if(!visit[v[vertex][i]]){                 visit[v[vertex][i]] = distance + 1;                 q.push({v[vertex][i], distance + 1});             \t            max_distance = max(max_distance, distance + 1);             }            }     }               for(int i=1; i&lt;=n; i++){     \tif(visit[i] == max_distance) answer++;     }          return answer; }      그래프 구현 문제   연결 리스트 형식으로 그래프 구현 후, 노드의 갯수만큼 돌면서 방문 처리를 해 준다.   가장 먼 거리를 업데이트 해가면서 노드를 전부 방문한다.   visit 배열이 가장 먼 거리와 일치하는 것의 갯수를 센다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EA%B0%80%EC%9E%A5-%EB%A8%BC-%EB%85%B8%EB%93%9C/",
        "teaser": null
      },{
        "title": "[백준 1194] 달이 차오른다, 가자.",
        "excerpt":"[백준 1194] 달이 차오른다, 가자.  문제 링크   #include \"header.h\" using namespace std; int N, M; char board[51][51]; int visit[51][51][1 &lt;&lt; 7]; pair &lt;int, int&gt; minsik; typedef struct node {     int x;     int y;     int dis;     int key; }node; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; void input(){     cin &gt;&gt; N &gt;&gt; M;     for(int i=0; i&lt;N; i++){         for(int j=0; j&lt;M; j++){             cin &gt;&gt; board[i][j];             if(board[i][j] == '0'){                 minsik = {i, j};                 board[i][j] = '.';             }         }     } }  void solve(){      queue &lt;node&gt; q;      q.push({minsik.first, minsik.second,0,0});     visit[minsik.first][minsik.second][0] = 1;      while (!q.empty()){         int top_x = q.front().x;         int top_y = q.front().y;         int dis = q.front().dis;         int key = q.front().key;         q.pop();          if(board[top_x][top_y] == '1'){             cout &lt;&lt; dis &lt;&lt; endl;             return;         }          for(int i=0; i&lt;4; i++){             int nx = top_x + dx[i];             int ny = top_y + dy[i];             if(visit[nx][ny][key] || board[nx][ny] == '#' || nx &lt; 0 || ny &lt; 0 || nx &gt;= N || ny &gt;= M) continue;              if(isupper(board[nx][ny])){                 if (key &amp; 1 &lt;&lt; (board[nx][ny] - 'A')){                     visit[nx][ny][key] = 1;                     q.push({nx, ny, dis+1, key});                     continue;                 }             }else if(islower(board[nx][ny])){                 int check_key = key | (1 &lt;&lt; (board[nx][ny] - 'a'));                 if(!visit[nx][ny][check_key]){                     visit[nx][ny][check_key] = 1;                     visit[nx][ny][key] = 1;                     q.push({nx, ny, dis+1, check_key});                     continue;                 }             }else{                 q.push({nx, ny, dis+1, key});                 visit[nx][ny][key] = 1;              }         }     }      cout &lt;&lt; -1 &lt;&lt; endl;      } int main() {     input();     solve();          return 0; }      bfs + 비트마스킹 문제   원래는 key랑 door를 map으로 둬서, 비트마스킹 대신 사용해 보려고 했는데, 상태 보존이 힘들어서 비트마스킹을 참고하여 사용했다.   visit 배열의 세 번째 부분이 열쇠이다. 열쇠를 획득 할 때마다 다시 탐색하기 위해 사용해준다.   key를 가지고 있는지 없는지를 판별하며 bfs를 돌다가, 1을 만나면 거리를 출력 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1194-%EB%8B%AC%EC%9D%B4-%EC%B0%A8%EC%98%A4%EB%A5%B8%EB%8B%A4,-%EA%B0%80%EC%9E%90/",
        "teaser": null
      },{
        "title": "[TIL] React, Vue, Angular 비교",
        "excerpt":"[TIL] React, Vue, Angular 비교   Angular     TS 기반 → 대규모 팀과 협업에 적합   단, 양방향 바인딩 모두 지원   컴포넌트 기반   React     JSX 사용   가상 DOM 사용   단방향 데이터 바인딩   컴포넌트 기반   Vue     Virtual DOM 사용   Template 사용   단, 양방향 바인딩 모두 지원   컴포넌트 기반   Conclusion                  -       React       Vue       Angular                       언어       JSX       JS       TS                 바인딩       단방향       단&amp;양방향       단&amp;양방향                 가상 DOM       O       O       X                 템플릿       X       O       O                 공통점               컴포넌트 기반                   Component란?     재사용이 가능한 최소 단위   단방향 &amp; 양방향    단방향은 템플릿과 모델을 동기화 시킬 때에 뷰에 적용이 된다.  양방향은 뷰와 모델이 바뀔 때마다 서로 갱신이 된다.      리액트는 단방향 바인딩이다.  parent &#8594; child 방향으로 바인딩이 되고, 이 때 전달되는 props는 immutable 하다.  컴포넌트는 state를 가지고 있는데, state는 mutable하다.  값 변경 시에는 setState()를 호출함으로서 동기화를 해 주어야 한다.  child에서 parent로 전달 하고 싶을 때에는 event로 전달 해 주어야 한다.   ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-React,-Vue,-Angular-%EB%B9%84%EA%B5%90/",
        "teaser": null
      },{
        "title": "Priority Queue",
        "excerpt":"파라미터  priority_queue&lt;T, Container, Compare&gt;     T : 우선순위 큐에 들어가는 원소들의 타입 명시   Container : T에 선언 된 타입을 담는 형식을 명시, 이 때 순회가 가능 해야 하고, O(1) 시간복잡도로 원소에 접근 가능 해야 한다. ex) vector, deque   Compare : 비교 함수   가장 큰 원소가 top인 max heap이 기본값이다.       기본 사용법  // max heap priority_queue &lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; pq; priority_queue &lt;int&gt; pq; // 둘 다 똑같이 max heap   //min heap priority_queue &lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;   priority_queue &lt;int&gt; pq;  pq.push(6); // 삽입 pq.push(2);  pq.top(); // 6   응용   compare 함수 사용  // second 비교하기  // 비교 함수 struct cmp {   bool operator()(const pair&lt;int, int&gt; &amp;a, const pair&lt;int, int&gt; &amp;b) {     return a.second &lt; b.second;   } };  priority_queue &lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, cmp&gt; pq;  pq.push({0, 3}); pq.push({0, 5});  cout &lt;&lt; pq.top().first &lt;&lt; ', ' &lt;&lt; pq.top().second &lt;&lt; endl; // 0, 5    struct 사용  struct Custom {   int x;   int y;   int val;   Custom(int value): x(0), y(0), val(value) {} }  struct cmp {     bool operator()(const Custom &amp;u, const Custom &amp;v) {         return u.val &gt; v.val;     } };  priority_queue &lt;Custom, vector&lt;Custom&gt;, less&lt;int&gt;&gt; pq;  priority_queue&lt;Custom, vector&lt;Custom&gt;, cmp&gt; pq;  pq.push(Custom(1)); pq.push(Custom(3));  cout &lt;&lt; pq.top().val &lt;&lt; endl; // 1   ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/Priority-Queue/",
        "teaser": null
      },{
        "title": "[백준 1158] 요세푸스 문제",
        "excerpt":"[백준 1158] 요세푸스 문제  문제 링크   #include \"header.h\" using namespace std; int N, K; queue &lt;int&gt; q; vector&lt;int&gt; answer;  void print() {   cout &lt;&lt; '&lt;';   for(int i=0; i&lt;answer.size()-1; i++){     cout &lt;&lt; answer[i] &lt;&lt; \", \";   }   cout &lt;&lt; answer[answer.size()-1] &lt;&lt; '&gt;'; } int main() {   cin &gt;&gt; N &gt;&gt; K;    for(int i=1; i&lt;=N; i++) q.push(i);    int cnt = 0;   while (!q.empty()){     int top = q.front();     q.pop();     cnt++;     if(cnt == K) {       answer.push_back(top);       cnt = 0;     }else q.push(top);   }    print();    return 0; }      다시 알고리즘 시작.. 몸풀기로 쉬운거 하나 풀었다.   큐로 원형을 만들면서 구현 하면 되는 문제.   cnt 변수를 두어 하나씩 더해가면서, K 번째가 될 때 answer에 넣어준다.   큐가 빌 때 까지 반복한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1158-%EC%9A%94%EC%84%B8%ED%91%B8%EC%8A%A4-%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[백준 2615] 오목",
        "excerpt":"[백준 2615] 오목  문제 링크   #include \"header.h\" using namespace std; int board[24][24]; int visit[24][24][10]; int dx[4] = {1, 0, 1, 1}; int dy[4] = {0, 1, -1, 1}; queue &lt;pair&lt;int, int&gt;&gt; q; void input() {   for(int i=0; i&lt;19; i++){     for(int j=0; j&lt;19; j++) {       cin &gt;&gt; board[i][j];       if(board[i][j]) q.push({i, j});     }   } } bool cmp(pair&lt;int, int&gt;&amp;a, pair&lt;int, int&gt;&amp;b) {   return a.second &lt; b.second; } void solve() {    while (!q.empty()){     vector &lt;pair&lt;int, int&gt;&gt; candidate;     int target_x = q.front().first;     int target_y = q.front().second;     int target = board[target_x][target_y];     q.pop();     candidate.push_back({target_x, target_y});      // 방향     for(int i=0; i&lt;4; i++) {       visit[target_x][target_y][i] = 1;       int nx = target_x + dx[i];       int ny = target_y + dy[i];           if(visit[nx][ny][i] || board[nx][ny] != target || nx &lt; 0 || ny &lt; 0 || nx &gt;= 19 || ny &gt;= 19) continue;       int cnt = 0;              while (1){         nx += dx[i];         ny += dy[i];         if(visit[nx][ny][i] || board[nx][ny] != target || nx &lt; 0 || ny &lt; 0 || nx &gt;= 19 || ny &gt;= 19) break;         candidate.push_back({nx, ny});         visit[nx][ny][i] = 1;         cnt++;       }        if(cnt == 3) {         sort(candidate.begin(), candidate.end(), cmp);         cout &lt;&lt; target &lt;&lt; endl;         cout &lt;&lt; candidate[0].first + 1 &lt;&lt; ' ' &lt;&lt; candidate[0].second + 1&lt;&lt; endl;         return;       }            }   }   cout &lt;&lt; 0 &lt;&lt; endl;  } int main() {   input();   solve();   return 0; }      시뮬레이션 문제, 오목을 판별하는 문제이다.   대신, 6목이 되면 안된다!   반복문을 돌면서, 0이 아닌 것들을 다 큐에 넣고 하나씩 빼면서 오목인지 판별 해 주면 된다.   8방향을 모두 탐색 할 필요가 없기 때문에 (가장 빠른 돌부터 탐색 하기 때문에) 오른쪽, 오른쪽 아래, 아래, 왼쪽 아래만 탐색 해 준다.   방향이 같다면, 해당 방향으로 쭉 탐색을 해 준다.   cnt가 3(총 돌의 갯수가 5개)이라면 6목인지 확인 해 준다.   candidate라는 벡터 안에, 해당 오목의 돌들을 넣어주었기 때문에, y좌표가 제일 빠른 좌표를 출력 해 준다.   ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-2615-%EC%98%A4%EB%AA%A9/",
        "teaser": null
      },{
        "title": "[TIL] Async, Await, Promise",
        "excerpt":"   Async, Await, Promise의 차이점을 알 수 있다. Async, Await, Promise의 차이점을 알기 전에, 비동기와 동기, 콜백에 대해서 알아 보겠다.    동기, 비동기  동기 (Synchrounous)     함수의 실행과 동시에 값이 반환된다.   하나의 함수 실행이 끝나기 전 까지는 다른 함수가 실행 될 수 없다.   비동기 (Asynchrounous)     함수의 실행과 값이 반환되는 시간이 다르다. (즉시 반환도 된다.)   함수의 실행이 끝나지 않더라도 다른 함수를 실행한다.   자바스크립트는 비동기적으로 동작된다. 해당 함수가 끝나지 않았는데도 다른 함수가 실행 되는 구조이기 때문에, 비동기를 처리 할 함수가 필요하다.   콜 백과 콜 백 지옥  콜 백 (Call back)     하나의 이벤트 발생 이후 실행 될 함수.   혹은 어떤 함수에 매개 변수로 전달 될 함수.   function sum(a, b, callback) {   let result = a + b;   callback(result); }  sum(10, 20, function(result){   console.log(result); // 30 });  해당 예제를 보면 sum이라는 함수가 있다. sum의 매개 변수로는 a, b, 그리고 callback이 있다.   sum은 인자로 받은 a + b를 result 변수에 저장하고, 해당 변수를 callback함수에 인자로 보낸다.   sum을 호출 할 때, 10, 20과 함수를 넣어주었다. 이 함수가 (매개 변수로 전달 되는) 콜백 함수이다.   callback 함수를 이용하면 비동기를 처리할 수 있다. 콜백 함수의 내부에는 인자로 받은 result를 콘솔로 찍어주는데, 이는 반드시 sum 호출 이후에 실행되게 된다.   sum(10, 20, function(result){   console.log(result); // 30 });  function sum(a, b, callback) {   let result = a + b;   callback(result); }  순서를 바꾸어도 똑같이 30이 나오는 것을 확인할 수 있다. 이렇게 callback 함수를 이용하여 비동기를 핸들링 할 수 있다.   콜 백 지옥  하지만 콜백을 무분별하게 사용하다 보면, 구조가 중첩(nesting)될 수 있다. 웹 개발을 진행 할 때, 페이지 로딩 후, 인증을 작업하고, 캐싱을 하고… 이런 연쇄적인 기능을 개발하다 보면 자연히 콜백이 깊어지기 마련이다. 이는 프로그램의 복잡도를 높이고, 디버깅도 힘들 뿐더러, 가독성도 좋지 않게 된다.   Promise  이 콜 백 지옥을 해결하기 위해 나온 것이 Promise이다. Promise는 콜백 함수를 예측 가능하도록 만들어주고, 후처리를 성공, 실패 분기를 나누어 간단하게 만들어 주었다.   프로미스 객체는 다음의 상태값을 가진다.     pending : new 연산자로 생성 후 resolve, reject가 호출 되기 전까지의 상태   fulfilled : 성공   rejected : 실패   settled : 완료 (성공 혹은 실패가 fix 된 후)   여기서 프로미스가 실행 완료 됐을 때, resolve 함수가 호출 된다. 이후 resolve에 연결 된 .then()메서드가 실행 된다.   let promise = new Promise((resolve, reject) =&gt; {   setTimeout(function() {     resolve(\"Success!\");   }, 1000); })  promise.then((result) =&gt; {   console.log(result); // Success! }).catch((reason) =&gt; {   console.log('failed : ', reason); })  해당 함수를 실행하게 되면, 1초 이후에 ‘Success!’라는 문구가 출력이 된다. new 연산자를 사용 해 Promise를 생성 한 후, resolve를 선언 해 준다. 해당 Promise가 성공적으로 실행 완료 시, .then()이 실행 된다. .then()은 resolve에서 받은 인자를 출력 해 준다. 또한, catch를 사용하여 reject시의 예외 처리도 가능하다.   Promise 패턴도 단점이 있다. 역시 연쇄적으로 일어나는 기능을 구현 할 시에, .then()을 중첩적으로 사용 해 깊어지는 경우가 있다.   Async, Await  앞선 두 가지의 비동기 처리 방식의 단점을 개선하기 위해 나온 방식이다. ES2017에 등장하였다.   let promise = new Promise((resolve, reject) =&gt; {   setTimeout(function() {     resolve(\"Success!\");   }, 1000); })  async function start() {   try {     let result = await promise;     console.log(result); // Success!   } catch(error) {     console.log(error);   } }  start();  비동기 처리를 해야 하는 함수 앞에 async 키워드를 붙이고, 내부의 Promise에 await 함수를 붙여주면 된다. async가 붙은 함수는 언제나 Promise를 반환 한다. await이 붙은 Promise의 실행이 끝날 때까지 기다리게 된다. 실행이 끝나면, 결과가 리턴되고 실행이 재개 된다.   좀 더 가독성이 좋게 만들어 주고, try/catch문으로 예외처리도 할 수 있다.  ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-Async,-Await,-Promise/",
        "teaser": null
      },{
        "title": "[leetcode] Combination Sum III",
        "excerpt":"class Solution { public:     void dfs(vector &lt;vector&lt;int&gt;&gt;&amp;ans, vector &lt;int&gt;&amp; chosen, vector &lt;int&gt;&amp;nums, int idx, int target, int k) {         if(target &lt; 0) return;         if(target == 0 &amp;&amp; k == chosen.size()) {           ans.push_back(chosen);           return;         }                  for(int i=idx; i&lt;nums.size(); i++) {           chosen.push_back(nums[i]);           dfs(ans, chosen, nums, i+1, target - nums[i], k);           chosen.pop_back();         }     }          vector&lt;vector&lt;int&gt;&gt; combinationSum3(int k, int n) {       vector &lt;vector&lt;int&gt;&gt; ans;       vector &lt;int&gt; chosen;       vector &lt;int&gt; nums;       for(int i=1; i&lt;=9; i++) nums.push_back(i);       dfs(ans, chosen, nums, 0, n, k);       return ans;     } };     조합 공부하면서 푼 문제   1-9까지의 숫자를 벡터에 넣어 주고, 백트래킹 하면서 target을 하나 하나 빼 주면 된다.   k만큼 고르고, 구하려는 숫자가 됐을 때 정답 벡터에 넣어주면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Combination-Sum-III/",
        "teaser": null
      },{
        "title": "순열과 조합",
        "excerpt":"Key Point     중복 허용 X : 방문 처리 필요 (visit 배열 사용)     순서 상관 X : 인덱스 필요       순서 상관 X 라면 AB = BA이다. 따라서 [1, 2], [2, 1]은 같기 때문에 제거 해 주어야 하기 때문에 인덱스가 필요하다.   순서 상관 O 라면 AB ≠ BA이다. 따라서 [1, 2], [2, 1]은 2개로 카운트 되기 때문에 인덱스가 필요 없이 모든 경우의 수를 세 주면 된다.   조합 (Combintaion)     순서에 상관 없이 n개중 r개를 뽑는다.   중복 허용 X, 순서 상관 X     void combination(vector&lt;int&gt;&amp;candidates, vector &lt;int&gt;&amp;num, int idx, int cnt) { if(candidates.size() == cnt) {   print(candidates);   return; }  for(int i=idx; i&lt;num.size(); i++) {   if(!visit[i]) {     visit[i] = 1;     candidates.push_back(num[i]);     combination(candidates, num, i+1, cnt);     candidates.pop_back();     visit[i] = 0;   } } }          // result 1 2 3  1 2 4  1 3 4  2 3 4            순열 (Permutation)     순서에 상관 있이 n개중 r개를 뽑는다.   중복 허용 X, 순서 상관 O     void permutation(vector&lt;int&gt;&amp;candidates, vector &lt;int&gt;&amp;num, int cnt) { // 조합 if(candidates.size() == cnt) {   print(candidates);   return; }  for(int i=0; i&lt;num.size(); i++) {   if(!visit[i]) {     visit[i] = 1;     candidates.push_back(num[i]);     permutation(candidates, num, cnt);     candidates.pop_back();     visit[i] = 0;   } } }          //result 1 2 3  1 2 4  1 3 2  1 3 4  1 4 2  1 4 3  2 1 3  2 1 4  2 3 1  2 3 4  2 4 1  2 4 3  3 1 2  3 1 4  3 2 1  3 2 4  3 4 1  3 4 2  4 1 2  4 1 3  4 2 1  4 2 3  4 3 1  4 3 2            중복 조합     조합에서 중복을 허용한다.   중복 허용 O, 순서 상관 X     void duplicate_combination(vector&lt;int&gt;&amp;candidates, vector &lt;int&gt;&amp;num, int idx, int cnt) {    if(candidates.size() == cnt) {   print(candidates);   return; }  for(int i=idx; i&lt;num.size(); i++) {   candidates.push_back(num[i]);   duplicate_combination(candidates, num, i, cnt);   candidates.pop_back(); } }          //result 1 1 1  1 1 2  1 1 3  1 1 4  1 2 2  1 2 3  1 2 4  1 3 3  1 3 4  1 4 4  2 2 2  2 2 3  2 2 4  2 3 3  2 3 4  2 4 4  3 3 3  3 3 4  3 4 4  4 4 4           중복 순열     순열에서 중복을 허용한다.   중복 허용 O, 순서 상관 O     void duplicate_permutation(vector&lt;int&gt;&amp;candidates, vector &lt;int&gt;&amp;num, int cnt) {    if(candidates.size() == cnt) {   print(candidates);   return; }  for(int i=0; i&lt;num.size(); i++) {   candidates.push_back(num[i]);   duplicate_permutation(candidates, num, cnt);   candidates.pop_back(); } }          //result 1 1 1  1 1 2  1 1 3  1 1 4  1 2 1  1 2 2  1 2 3  1 2 4  1 3 1  1 3 2  1 3 3  1 3 4  1 4 1  1 4 2  1 4 3  1 4 4  2 1 1  2 1 2  2 1 3  2 1 4  2 2 1  2 2 2  2 2 3  2 2 4  2 3 1  2 3 2  2 3 3  2 3 4  2 4 1  2 4 2  2 4 3  2 4 4  3 1 1  3 1 2  3 1 3  3 1 4  3 2 1  3 2 2  3 2 3  3 2 4  3 3 1  3 3 2  3 3 3  3 3 4  3 4 1  3 4 2  3 4 3  3 4 4  4 1 1  4 1 2  4 1 3  4 1 4  4 2 1  4 2 2  4 2 3  4 2 4  4 3 1  4 3 2  4 3 3  4 3 4  4 4 1  4 4 2  4 4 3            전체 소스 코드  #include \"header.h\" using namespace std; int visit[5]; void print(vector&lt;int&gt;&amp;candidates) {   for(auto a : candidates) cout &lt;&lt; a &lt;&lt; ' ';   cout &lt;&lt; endl; }  void init(vector &lt;int&gt; &amp;ans) {   ans.clear();   memset(visit, 0, sizeof(visit)); }  void combination(vector&lt;int&gt;&amp;candidates, vector &lt;int&gt;&amp;num, int idx, int cnt) {   if(candidates.size() == cnt) {     print(candidates);     return;   }    for(int i=idx; i&lt;num.size(); i++) {     if(!visit[i]) {       visit[i] = 1;       candidates.push_back(num[i]);       combination(candidates, num, i+1, cnt);       candidates.pop_back();       visit[i] = 0;     }   } }  void permutation(vector&lt;int&gt;&amp;candidates, vector &lt;int&gt;&amp;num, int cnt) { // 조합   if(candidates.size() == cnt) {     print(candidates);     return;   }    for(int i=0; i&lt;num.size(); i++) {     if(!visit[i]) {       visit[i] = 1;       candidates.push_back(num[i]);       permutation(candidates, num, cnt);       candidates.pop_back();       visit[i] = 0;     }   } }  void duplicate_combination(vector&lt;int&gt;&amp;candidates, vector &lt;int&gt;&amp;num, int idx, int cnt) {      if(candidates.size() == cnt) {     print(candidates);     return;   }    for(int i=idx; i&lt;num.size(); i++) {     candidates.push_back(num[i]);     duplicate_combination(candidates, num, i, cnt);     candidates.pop_back();   } }  void duplicate_permutation(vector&lt;int&gt;&amp;candidates, vector &lt;int&gt;&amp;num, int cnt) {      if(candidates.size() == cnt) {     print(candidates);     return;   }    for(int i=0; i&lt;num.size(); i++) {     candidates.push_back(num[i]);     duplicate_permutation(candidates, num, cnt);     candidates.pop_back();   } } int main() {   vector &lt;int&gt; num = {1, 2, 3, 4};   vector &lt;int&gt; ans;    cout &lt;&lt; \"조합 구현\" &lt;&lt; endl; // 중복 X, 순서 X   combination(ans, num, 0, 3); // 답을 저장할 벡터, 숫자들, 인덱스, 얼마나 뽑을 것인지   init(ans);      cout &lt;&lt; \"\\n순열 구현\" &lt;&lt; endl; // 중복 X, 순서 O≠   permutation(ans, num, 3); // 답을 저장할 벡터, 숫자들, 얼마나 뽑을 것인지   init(ans);    cout &lt;&lt; \"\\n중복 조합\" &lt;&lt; endl; // 중복 O, 순서 X   duplicate_combination(ans, num, 0, 3); // 답을 저장할 벡터, 숫자들, 얼마나 뽑을 것인지   init(ans);    cout &lt;&lt; \"\\n중복 순열\" &lt;&lt; endl; // 중복 O, 순서 O   duplicate_permutation(ans, num, 3); // 답을 저장할 벡터, 숫자들, 얼마나 뽑을 것인지    return 0; }   관련 문제   조합  Combination Sum   Letter Combinations of a Phone Number    순열  Letter Case Permutation   Permutations  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EC%88%9C%EC%97%B4%EA%B3%BC-%EC%A1%B0%ED%95%A9/",
        "teaser": null
      },{
        "title": "[leetcode] Word Search",
        "excerpt":"[leetcode] Word Search  문제 링크   class Solution { public:     int flag;     int visit[201][201];     int dx[4] = {0, 0, -1, 1};     int dy[4] = {-1, 1, 0, 0};          void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; board, int x, int y, string word, int idx) {         if(flag) return;         if(idx == word.length()) {             flag = 1;             return;         }                         for(int i=0; i&lt;4; i++) {             int nx = x + dx[i];             int ny = y + dy[i];             char target = word[idx];             if(nx &lt; 0 || ny &lt; 0 || nx &gt;=board.size() || ny &gt;= board[0].size()) continue;             if(visit[nx][ny] || board[nx][ny] != target) continue;             visit[nx][ny] = 1;             dfs(board, nx, ny, word, idx + 1);             visit[nx][ny] = 0;         }              }     bool exist(vector&lt;vector&lt;char&gt;&gt;&amp; board, string word) {         int n = board.size();         int m = board[0].size();                  for(int i=0; i&lt;n; i++) {             for(int j=0; j&lt;m; j++) {                 if(board[i][j] == word[0]) {                     visit[i][j] = 1;                     dfs(board, i, j, word, 1);                     if(flag) return true;                     visit[i][j] = 0;                 }             }         }         return false;     } };      백트래킹 + dfs 문제.   방문 처리를 주의해야 한다. 이전에 탐색 했던 문자도 탐색 할 수 있되, 해당 dfs 스코프에서는 다시 방문 할 수 없도록 해야 한다.   word의 첫번째 글자와 똑같은 경우에만 dfs를 탐색 하면 된다.   글자를 찾을 때마다 인덱스를 늘려가면서, 마지막 글자를 찾은 경우에는 flag로 리턴 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Word-Search/",
        "teaser": null
      },{
        "title": "[백준 2636] 치즈",
        "excerpt":"[백준 2636] 치즈  문제 링크   using namespace std; int n, m, day, cheeze; int box[101][101]; int check[101][101]; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; void input(){   cin &gt;&gt; n &gt;&gt; m;   for(int i=0; i&lt;n; i++) {     for(int j=0; j&lt;m; j++) {       cin &gt;&gt; box[i][j];     }   } } int range(int x, int y) {   return x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; n &amp;&amp; y &lt; m &amp;&amp; !check[x][y]; } void print() {   for(int i=0; i&lt;n; i++) {     for(int j=0; j&lt;m; j++) {       cout &lt;&lt; box[i][j] &lt;&lt; ' ';     }     cout &lt;&lt; endl;   }    } int melt() {   queue &lt;pair&lt;int, int&gt;&gt; q;   memset(check, 0, sizeof(check));   q.push({0, 0});   check[0][0] = 1;    // 외곽선 체크   while (!q.empty()){     int top_x = q.front().first;     int top_y = q.front().second;     q.pop();      for(int i=0; i&lt;4; i++){       int nx = top_x + dx[i];       int ny = top_y + dy[i];        if(!range(nx, ny) || box[nx][ny]) continue;        check[nx][ny] = 1;       q.push({nx, ny});     }   }    int cnt = 0;   for(int i=0; i&lt;n; i++) {     for(int j=0; j&lt;m; j++) {       if(box[i][j]) {         cnt++;         for(int k=0; k&lt;4; k++) {           int nx = i + dx[k];           int ny = j + dy[k]; //상하좌우 탐색           if(check[nx][ny]) { // 외곽선 인접이라면             box[i][j] = 0;             break;           }         }       }     }   }    if(cnt == 0) return true;   else {     cheeze = cnt;     return false;   } } void solve(){    while(true) {     if(melt()) break;     day++;   }    cout &lt;&lt; day &lt;&lt; endl &lt;&lt; cheeze &lt;&lt; endl;  } int main() {   input();   solve();   return 0; }      전형적인 bfs 문제   bfs를 0, 0 부터 돌면서 외곽선을 체크 해 준다.   다시 한 번 bfs를 돌면서 주변에 외곽선이 있는 경우에만 녹여준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-2636-%EC%B9%98%EC%A6%88/",
        "teaser": null
      },{
        "title": "[백준 9251] LCS",
        "excerpt":"[백준 9251] LCS  문제 링크   using namespace std; string text1, text2; int dp[1004][1004]; void solve() {    for(int i=1; i&lt;=text1.length(); i++) {     for(int j=1; j&lt;=text2.length(); j++) {       if(text1[i-1] == text2[j-1]) {         dp[i][j] = dp[i-1][j-1] + 1;       } else {         dp[i][j] = max(dp[i-1][j], dp[i][j-1]);       }     }   }    cout &lt;&lt; dp[text1.length()][text2.length()]; }  int main() {    cin &gt;&gt; text1 &gt;&gt; text2;    solve();    return 0; }        해당 그림에서 볼 수 있다시피 인덱스를 1부터 시작한다 (i-1, j-1 처리를 위해)   만약 text1[i]와 text2[j]가 같다면, 하나가 더 길어진 것이기 때문에 +1을 해 준다.   같지 않다면, 이전의 값에서의 최댓값으로 업데이트 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-9251-LCS/",
        "teaser": null
      },{
        "title": "[백준 5212] 지구 온난화",
        "excerpt":"[백준 5212] 지구 온난화  문제 링크   #include \"header.h\" using namespace std; int R, C; char ocean[14][14]; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; queue &lt;pair&lt;int, int&gt;&gt; q; vector &lt;pair&lt;int, int&gt;&gt; v; bool cmp(pair&lt;int, int&gt;&amp;a, pair&lt;int, int&gt;&amp;b) {   return a.second &lt; b.second; } void input() {   cin &gt;&gt; R &gt;&gt; C;    for(int i=0; i&lt;R; i++) {     for(int j=0; j&lt;C; j++) {       cin &gt;&gt; ocean[i][j];       if(ocean[i][j] == 'X') {         q.push({i, j});       }     }   } } void solve() {   vector &lt;pair&lt;int, int&gt;&gt; del;   while (!q.empty()){     int top_x = q.front().first;     int top_y = q.front().second;     q.pop();      int cnt = 0;     for(int i=0; i&lt;4; i++) {       int nx = top_x + dx[i];       int ny = top_y + dy[i];       if(ocean[nx][ny] == 'X') continue;       if(nx &lt; 0 || ny &lt; 0 || nx &gt;= R || ny &gt;= C) {         cnt++; continue;       }       else cnt++;     }      if(cnt &gt;= 3) del.push_back({top_x, top_y});     else v.push_back({top_x, top_y});   }    for(int i=0; i&lt;del.size(); i++) ocean[del[i].first][del[i].second] = '.';    print(); } void print() {   sort(v.begin(), v.end());   int i_begin = v.front().first;   int i_end = v.back().first;    sort(v.begin(), v.end(), cmp);   int j_begin = v.front().second;   int j_end = v.back().second;    for(int i=i_begin; i&lt;=i_end; i++) {     for(int j=j_begin; j&lt;=j_end; j++) {       cout &lt;&lt; ocean[i][j];     }     cout &lt;&lt; endl;   } } int main() {    input();   solve();    return 0; }      bfs 돌면서 4면을 탐색한다.   cnt가 3 이상이면 바다가 될 곳이므로 del에 저장 해 준다. 이때 바로 삭제 하게 되면 다른 섬에도 영향을 끼치게 되므로 일단 벡터에 따로 저장 해 놓는다.   바다가 되지 않을 곳들도 따로 벡터에 저장 해 놓는다.   del 벡터를 돌면서 바다로 바꿔준다.   벡터를 정렬 해 범위를 찾는다. 이후 출력.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-5212-%EC%A7%80%EA%B5%AC-%EC%98%A8%EB%82%9C%ED%99%94/",
        "teaser": null
      },{
        "title": "[leetcode] Palindromic Substrings",
        "excerpt":"[leetcode] Palindromic Substrings  문제 링크   class Solution { public:     int dp[1004][1004];     int countSubstrings(string s) {         int answer = s.length();                  for(int i=0; i&lt;s.length(); i++) {             dp[i][i] = 1;         }                  for(int i=0; i&lt;s.length() - 1; i++) {             if(s[i] == s[i+1]) {                 dp[i][i+1] = 1;                 answer++;             }         }                          for(int i=2; i&lt;s.length(); i++) {             for(int j=0; j&lt;i; j++) {                 if(s[i] == s[j] &amp;&amp; dp[j+1][i-1]) {                     dp[j][i] = 1;                     answer++;                 }             }         }                  return answer;     } };      palindrome인 경우는 3가지 경우가 있다.            문자의 길이가 1개인 경우       문자의 길이가 2개 이고, 둘이 같은 경우       문자의 길이가 3개 이상이고, 양 끝의 문자가 같으며, 양 끝 문자 사이의 문자열도 palindrome이어야 한다.           dp[i][j]는 i~j의 palindrome 여부이다.            dp[0][2]라면 s[0~2]가 palindrome인지 아닌지를 표시한다.           문자의 길이가 1개, 2개인 경우는 단순 반복문으로 처리를 해 준다.   문자의 길이가 3개 이상일 경우에만 주의 해 주면 된다.            i, j를 palindrome을 판별 할 처음과 끝의 인덱스로 지정 해 준다.       s[i] == s[j], 즉 양 끝의 문자가 같고,       dp[i+1][j-1], 그 사이의 substring도 palindrome이면,       답을 더해주고, palindrome이라고 표시를 해 준다.           이 때, i를 0부터 검사하게 되면 i+1를 갱신 하지 않은 상태에서 i+1에 접근해 답을 체크할 수 없기 때문에,   top down 방식으로 풀어야 한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Palindromic-Substrings/",
        "teaser": null
      },{
        "title": "[백준 1938] 통나무 옮기기",
        "excerpt":"[백준 1938] 통나무 옮기기  문제 링크    #include \"header.h\" using namespace std; int N, dir, ans_dir; char land[54][54]; int visit[54][54][2]; vector &lt;pair&lt;int, int&gt;&gt; b; vector &lt;pair&lt;int, int&gt;&gt; e; queue &lt;vector&lt;int&gt;&gt; q; int dx[4] = {0, 0, -1, 1}; int dy[4] = {-1, 1, 0, 0}; // 범위 벡터 vector &lt;pair&lt;int, int&gt;&gt; ran[2] = {{{-1, 0}, {1, 0}}, {{0, -1}, {0, 1}}}; // 0 : 세로, 1 : 가로 //회전 벡터 vector &lt;pair&lt;int, int&gt;&gt; rot[2] = {{{-1, -1}, {0, -1}, {1, -1}, {-1, 1}, {0, 1}, {1, 1}}, {{-1, -1}, {-1, 0}, {-1, 1}, {1, -1}, {1, 0}, {1, 1}}};  bool range(int x, int y) {   return (x &gt;= 0 &amp;&amp; y &gt;= 0 &amp;&amp; x &lt; N &amp;&amp; y &lt; N); } void input() {   cin &gt;&gt; N;   for(int i=0; i&lt;N; i++) {     for(int j=0; j&lt;N; j++) {       cin &gt;&gt; land[i][j];       if(land[i][j] == 'B') {         b.push_back({i, j});       } else if(land[i][j] == 'E') {         e.push_back({i, j});       }     }   }    if(b[0].first == b[1].first) dir = 1; // 가로   if(e[0].first == e[1].first) ans_dir = 1; }  void solve() {    q.push({b[1].first, b[1].second, dir, 0}); //중심 넣기   visit[b[1].first][b[1].second][dir] = 1;    while (!q.empty()){     int top_x = q.front()[0];     int top_y = q.front()[1];     int top_dir = q.front()[2];     int cnt = q.front()[3];     q.pop();      // 도착 했는지 확인     if(top_x == e[1].first &amp;&amp; top_y == e[1].second &amp;&amp; ans_dir == top_dir) {       cout &lt;&lt; cnt &lt;&lt; endl;       return;     }      // 중심을 움직이기     for(int i=0; i&lt;4; i++) {       int nx = top_x + dx[i];       int ny = top_y + dy[i];              if(visit[nx][ny][top_dir] || land[nx][ny] == '1' || !range(nx, ny)) continue;        // 범위 체크       int flag = 1;       for(int j=0; j&lt;2; j++) {         int rx = nx + ran[top_dir][j].first;         int ry = ny + ran[top_dir][j].second;         if(land[rx][ry] == '1' || !range(rx, ry)) {           flag = 0;           break;         }       }       if(!flag) continue;       q.push({nx, ny, top_dir, cnt + 1});       visit[nx][ny][top_dir] = 1;        // 회전 시켜보기       // 범위 체크       flag = 1;       for(int j=0; j&lt;6; j++) {         int rx = top_x + rot[top_dir][j].first;         int ry = top_y + rot[top_dir][j].second;         if(land[rx][ry] == '1' || !range(rx, ry)) {           flag = 0;           break;         }       }       if(!flag) continue;       q.push({top_x, top_y, !top_dir, cnt + 1});       visit[top_x][top_y][!top_dir] = 1;     }   }      cout &lt;&lt; 0 &lt;&lt; endl; } int main() {    input();   solve();    return 0; }       bfs문제   중심을 옮겨 가면서 진행 했다.   큐에 cnt도 함께 넣어주어서 얼마나 움직였는지 세어 준다.   중심을 bfs로 움직인다.            움직일 때 마다 통나무의 범위 체크도 해 준다.           움직인 이후, 회전도 체크를 해 준다.            이 때 6방향을 체크 해 주어야 한다.           만약 통나무의 중심이 E의 중심을 만나면, 방향이 같은지도 체크 해 준다.   방향이 같다면 답을 출력 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1938-%ED%86%B5%EB%82%98%EB%AC%B4-%EC%98%AE%EA%B8%B0%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[leetcode] Longest Increasing Subsequence",
        "excerpt":"[leetcode] Longest Increasing Subsequence  문제 링크   class Solution { public:     int lengthOfLIS(vector&lt;int&gt;&amp; nums) {                          int ans = 0;         int n = nums.size();         int dp[n+1]; memset(dp, 0, sizeof(dp));          for(int i=0; i&lt;n; i++) {             dp[i] = 1;             for(int j=0; j&lt;i; j++) {                 if(nums[i] &gt; nums[j] &amp;&amp; dp[i] &lt; dp[j] + 1) {                     dp[i] = dp[j] + 1;                 }             }             ans = max(ans, dp[i]);         }                  return ans;     } };      Longest Increasing Subsequence는 기본 dp 문제이다. 숙지 해 놓자!   dp[i]는 해당 위치에서의 증가 수열의 최대 길이이다.   j=0에서부터 i까지의 최장 증가 수열을 계산 해 주면 된다.   1개는 무조건 1 길이의 lis를 가지기 때문에 dp[i] = 1로 초기화 시켜준다.   i인덱스 숫자가 j인덱스보다 크고, dp[j]+1가 dp[i]보다 클 경우에 업데이트를 해 준다.            dp[j]+1을 비교 해 주는 이유는, 최장 길이를 업데이트 해야 하는데 dp[i]가 최대가 아닌 경우가 있기 때문이다.       ex) 10 20 10 30 일 때, 30을 업데이트 시 크기 비교만 해 줄 경우 3이 아닌 2로 갱신된다. (dp[2]가 1이기 때문)          ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Longest-Increasing-Subsequence/",
        "teaser": null
      },{
        "title": "[백준 11055] 가장 큰 증가 부분 수열",
        "excerpt":"[백준 11055] 가장 큰 증가 부분 수열  문제 링크   int N; int dp[1004]; int numbers[1004]; void input() {   cin &gt;&gt; N;   for(int i=0; i&lt;N; i++) {     cin &gt;&gt; numbers[i];   } } void solve() {   int answer = 0;   for(int i=0; i&lt;N; i++) {     dp[i] = numbers[i];     for(int j=0; j&lt;i; j++) {       if(numbers[i] &gt; numbers[j] &amp;&amp; dp[i] &lt; dp[j] + numbers[i]) { //         dp[i] = numbers[i] + dp[j];       }     }     answer = max(answer, dp[i]);   }      cout &lt;&lt; answer &lt;&lt; endl; } int main() {    input();   solve();    return 0; }  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-11055-%EA%B0%80%EC%9E%A5-%ED%81%B0-%EC%A6%9D%EA%B0%80-%EB%B6%80%EB%B6%84-%EC%88%98%EC%97%B4/",
        "teaser": null
      },{
        "title": "[백준 9252] LCS 2",
        "excerpt":"[백준 9252] LCS 2  문제 링크   using namespace std; string s1, s2; int dp[1004][1004]; string lcs[1004][1004]; void input() {   cin &gt;&gt; s1 &gt;&gt; s2; } void solve() {   int n = s1.length();   int m = s2.length();   string answer = \"\";    for(int i=1; i&lt;=n; i++) {     for(int j=1; j&lt;=m; j++) {       if(s1[i-1] == s2[j-1]) {         dp[i][j] = dp[i-1][j-1] + 1;         lcs[i][j] += lcs[i-1][j-1] + s2[j-1];       } else {         dp[i][j] = max(dp[i-1][j], dp[i][j-1]);         if(lcs[i-1][j].length() &gt; lcs[i][j-1].length()) {           lcs[i][j] = lcs[i-1][j];         } else lcs[i][j] = lcs[i][j-1];       }     }   }    cout &lt;&lt; dp[n][m] &lt;&lt; endl;   if(dp[n][m]) cout &lt;&lt; lcs[n][m] &lt;&lt; endl; } int main() {    input();   solve();    return 0; }     LCS와 거의 똑같은 문제지만, 어떤 문자열이 LCS인지 출력 해야 한다.   LCS의 길이를 구한 것과 동일하게, string배열을 생성 해서 똑같이 업데이트 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-9252-LCS-2/",
        "teaser": null
      },{
        "title": "[백준 17281] ⚾",
        "excerpt":"[백준 17281] ⚾  문제 링크   using namespace std; int N, max_score; int players[51][10]; vector&lt;int&gt; candidates; int visit[9]; int field[4]; void input() {     cin &gt;&gt; N;     for (int i = 0; i &lt; N; i++) {         for (int j = 0; j &lt; 9; j++) {             cin &gt;&gt; players[i][j];         }     } } void move(int cmp, int &amp;score) {      for(int i=3; i&gt;=1; i--) {         if(field[i]) {             if(i + cmp &gt;= 4) { // home in                 score++;             } else {                 field[i + cmp] = 1;             }             field[i] = 0;         }     }      if(cmp == 4) {         score++;     } else {         field[cmp] = 1;     }      } void play() {      int out = 0;     int idx = 0;     int score = 0;          for(int inning = 0; inning &lt; N; inning++) {         out = 0;         memset(field, 0, sizeof(field));         while (true){             if(idx == 9) idx = 0;             int cmp = players[inning][candidates[idx]];              if(cmp == 0) {                 out++;                 if(out == 3) { idx++; break; }             } else {                 // move                 move(cmp, score);             }             idx++;         }     }     max_score = max(max_score, score);     }  void dfs() {     if (candidates.size() == 8) {         candidates.insert(candidates.begin() + 3, 0);         play();         candidates.erase(candidates.begin() + 3);         return;     }      for (int i = 1; i &lt; 9; i++) {         if (!visit[i]) {             visit[i] = 1;             candidates.push_back(i);             dfs();             candidates.pop_back();             visit[i] = 0;         }     } } void solve() {     dfs();     cout &lt;&lt; max_score &lt;&lt; endl; } int main() {     input();     solve();     return 0; }      조합(dfs) + 시뮬레이션 문제   0번째를 제외하고 1~8까지의 경우의 수를 모두 구한다. -&gt; 선수들의 순서의 모든 경우의 수가 된다.   조합이 완성 될 때마다 4번째에 0번을 넣어 주고 시뮬레이션을 한다.   선수의 점수에 따라 주자들을 움직여야 하는데, 이 때 1부터가 아닌 3부터 진행 해야 덮어씌워지지 않는다.   모든 이닝을 돈 후 최대 값을 갱신 해 주면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-17281/",
        "teaser": null
      },{
        "title": "[백준 17135] 캐슬 디펜스",
        "excerpt":"[백준 17135] 캐슬 디펜스  문제 링크   using namespace std; int N, M, D, answer; int board[20][20]; int new_board[20][20]; int dx[] = { -1,0,0 }; int dy[] = { 0,-1,1 }; vector&lt;pair&lt;int, int&gt;&gt; able; vector&lt;pair&lt;int, int&gt;&gt; candidates; int visit[20][20]; void input() {     cin &gt;&gt; N &gt;&gt; M &gt;&gt; D;  // 세로, 가로     for (int i = 0; i &lt; N; i++) {         for (int j = 0; j &lt; M; j++) {             cin &gt;&gt; board[i][j];         }     }      for (int i = 0; i &lt; M; i++) {         able.push_back({N, i});     } } int check() {     for (int i = 0; i &lt; N; i++) {         for (int j = 0; j &lt; M; j++) {             if (new_board[i][j]) return false;         }     }     return true; } void copy_board() {     for (int i = 0; i &lt; N; i++) {         for (int j = 0; j &lt; M; j++) {             new_board[i][j] = board[i][j];         }     } } void play() {    int score = 0;   copy_board();            // map 초기화    while (1) {              // 게임이 끝날 때 까지     if (check()) break;  // 모든 적을 죽이면 끝     int will_killed[20][20];     int chk[20][20];     memset(will_killed, 0, sizeof(will_killed));      for (int archer = 0; archer &lt; 3; archer++) {       // kill enemies -&gt; 거리, 제일 왼쪽       // bfs       queue&lt;vector&lt;int&gt;&gt; q;       pair&lt;int, int&gt; kill = {99, 99};       memset(chk, 0, sizeof(chk));       q.push({candidates[archer].first, candidates[archer].second});       chk[candidates[archer].first][candidates[archer].second] = 1;       int dist = 0;        while (!q.empty()) {         dist++;         if (dist &gt; D) break;         int qsize = q.size();          while (qsize--){             int top_x = q.front()[0];             int top_y = q.front()[1];             q.pop();              for (int k = 0; k &lt; 3; k++) {                 int nx = top_x + dx[k];                 int ny = top_y + dy[k];                 if (nx &lt; 0 || ny &lt; 0 || ny &gt;= M || nx &gt;= N || chk[nx][ny]) continue;                 q.push({nx, ny});                 chk[nx][ny] = 1;                  if (new_board[nx][ny] &amp;&amp; kill.second &gt; ny) {                     kill = {nx, ny};                 }             }         }          if(kill.first != 99) {           will_killed[kill.first][kill.second] = 1;           break;         }                }     }     // 제일 왼쪽의, 거리가 제일 적은 애 찾았음.     for (int i = 0; i &lt; N; i++) {         for (int j = 0; j &lt; M; j++) {             if (will_killed[i][j]) {                 new_board[i][j] = 0;                 score++;             }         }     }      // 한 칸 씩 내리기     for (int i = N - 1; i &gt;= 0; i--) {         for (int j = 0; j &lt; M; j++) {             new_board[i][j] = new_board[i - 1][j];         }     }      for (int i = 0; i &lt; M; i++) {         new_board[0][i] = 0;     }   }    answer = max(answer, score); } void dfs(int idx) {     // 궁수 세 명 배치 완료     if (candidates.size() == 3) {          play();         return;     }      for (int i = idx; i &lt; able.size(); i++) {         int x = able[i].first;         int y = able[i].second;         if (!visit[x][y]) {             candidates.push_back({x, y});             visit[x][y] = 1;             dfs(i + 1);             candidates.pop_back();             visit[x][y] = 0;         }     } } void solve() {     dfs(0);     cout &lt;&lt; answer &lt;&lt; endl; }  int main() {     input();     solve();     return 0; }      dfs + bfs, 시뮬레이션 문제   하루종일 했다,,,, 이ㅓㅏㅁㄹㄴ;만ㅇ 너무.. 스트레스받앗던문제 ㅜ 못하겠어서 걍 답보고ㅅ함   처음에는 우선순위 큐로 제일 가까운 적들을 업데이트 하면서 진행하려고 했는데 정렬이 좀 복잡해서 그냥 dfs + bfs로 풀었다   조합으로 M중 3가지의 경우의 수를 모두 구하고,   궁수의 위치가 결정이 됐으면 가장 가까운 적들을 해치우고, 한 줄씩 내려주면 된다.   이 때, 바로 없애면 안된다. 중복된 적을 허용 해 주어야 한다.   qsize만큼 돌아야지만 답이 통과가 되는데, dist를 bfs돌릴 때 하나씩 업데이트 해 주고, pop할때 dist가 D를 넘는지 확인하는 방식으로 하니까 통과가 안된다. 웨죠   ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-17135-%EC%BA%90%EC%8A%AC-%EB%94%94%ED%8E%9C%EC%8A%A4/",
        "teaser": null
      },{
        "title": "[leetcode] Rotate List",
        "excerpt":"[leetcode] Rotate List  문제 링크   class Solution { public:     ListNode* rotateRight(ListNode* head, int k) {         if(head == NULL || k == 0) return head;                  int cnt = 1;         ListNode* temp = head;         while(temp-&gt;next) cnt++, temp = temp-&gt;next;         k %= cnt;                  ListNode *cur1 = head;         ListNode *cur2 = head;         ListNode *new_head;                  while(k-- &amp;&amp; cur1) cur1 = cur1-&gt;next;                  while(cur1-&gt;next &amp;&amp; cur2) {             cur1 = cur1-&gt;next;             cur2 = cur2-&gt;next;         }                  cur1-&gt;next = head;         new_head = cur2-&gt;next;         cur2-&gt;next = NULL;           return new_head;     } };      투 포인터로 푸는 문제.   리스트의 길이를 구한 후, K에 나머지 연산을 하면 새로운 헤드의 위치를 구할 수 있다. (뒤에서 몇 번째인지)   cur1, cur2를 만들고 cur1을 k만큼 움직여준다.   이제 cur1가 끝에 도달 할 때까지 cur1, cur2를 함께 움직여준다.   끝에 도달하게 되면 cur1-&gt;next를 맨 처음과 이어준다. (head)   새로운 헤드를 cur2-&gt;next로 해 주고, null처리를 해주면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Roatate-List/",
        "teaser": null
      },{
        "title": "[leetcode] Symmetric Tree",
        "excerpt":"[leetcode] Symmetric Tree  문제 링크   class Solution { public:          bool isMirror(TreeNode *t1, TreeNode * t2) {         if(t1 == NULL &amp;&amp; t2 == NULL) return true;         if(t1 == NULL || t2 == NULL) return false;                  return (t1-&gt;val == t2-&gt;val) &amp;&amp; isMirror(t1-&gt;right, t2-&gt;left)             &amp;&amp; isMirror(t1-&gt;left, t2-&gt;right);     }          bool isSymmetric(TreeNode* root) {         return isMirror(root, root);     } };  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Symmetric-Tree/",
        "teaser": null
      },{
        "title": "[leetcode] Wiggle Sort II",
        "excerpt":"[leetcode] Wiggle Sort II  문제 링크   class Solution { public:     void wiggleSort(vector&lt;int&gt;&amp; nums) {         vector &lt;int&gt; temp = nums;         sort(temp.begin(), temp.end());                  int left = (temp.size()-1) / 2;         int right = temp.size()-1;                  for(int i=0; i&lt;nums.size(); i++) {             if(i % 2 == 0) {                 nums[i] = temp[left--];             } else {                 nums[i] = temp[right--];             }         }     } };      작은수, 큰수를 번갈아가면서 정렬 하는 문제이다.   처음에는 정렬 후에 바텀 업 방식으로 하려고 했는데, 잘 되지 않아서 탑다운 방식으로 풀었다.   주어지는 예제는 무조건 맞기 때문에, 번갈아가면서 정렬 하기 위해서는 작은 숫자의 갯수가 반 이상이 되면 안된다.   따라서 left를 절반부터 0까지 감소 시키고, right는 끝에서부터 감소시키면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Wiggle-Sort-II/",
        "teaser": null
      },{
        "title": "[백준 4195] 친구 네트워크",
        "excerpt":"[백준 4195] 친구 네트워크  문제 링크   using namespace std; int T, F; int parent[2000001]; int num[2000001]; int find(int x) {     if(parent[x] == x) return x;     return parent[x] = find(parent[x]); } int merge(int x, int y) {     x = find(x);     y = find(y);      if(x != y) {         parent[y] = x;         num[x] += num[y];         num[y] = 1;     }      return num[x]; } void input() {     cin &gt;&gt; T;     for(int t=0; t&lt;T; t++) {         cin &gt;&gt; F;         map&lt;string, int&gt; m; // 친구 네트워크 번호         int cnt = 1;          for(int i=1; i&lt;=F; i++) {             parent[i] = i;             num[i] = 1;         }          for(int i=0; i&lt;F; i++) {             string s1, s2;             cin &gt;&gt; s1 &gt;&gt; s2;             if(!find(m[s1])) {                 m[s1] = cnt++;             }              if(!find(m[s2])) {                 m[s2] = cnt++;             }              int first = m[s1];             int second = m[s2];             cout &lt;&lt; merge(first, second) &lt;&lt; '\\n';         }     } } int main() {     ios_base::sync_with_stdio(false);     cin.tie(NULL);     input();     return 0; }      union find로 푸는 문제. 시간 초과때문에 애좀 먹었다.   맨 처음에는 union find가 아니라 그냥 맵으로 구현 했는데, 시간 초과가 나서 union find로 풀었다.   맵에는 친구 네트워크의 번호를 저장 해 놓는다.   해당 친구 네트워크의 번호를 merge로 판별 해 같다면 그냥 리턴하고, 같지 않다면 합쳐준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-4195-%EC%B9%9C%EA%B5%AC-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/",
        "teaser": null
      },{
        "title": "[leetcode] Find the Duplicate Number",
        "excerpt":"[leetcode] Find the Duplicate Number  문제 링크   class Solution { public:     int findDuplicate(vector&lt;int&gt;&amp; nums) {                  int turtle = nums[0];         int rabbit = nums[0];                  do {             turtle = nums[turtle];             rabbit = nums[nums[rabbit]];         } while(turtle != rabbit);          turtle = nums[0];                  while(turtle != rabbit) {             turtle = nums[turtle];             rabbit = nums[rabbit];         }                  return turtle;        } };     처음엔 정렬, 해시맵으로 접근 했는데, 문제의 조건이 배열 수정 불가, O(1)의 메모리, O(n^2) 시간복잡도라서 조건을 만족하지 못했다.   검색 해 보니 플로이드의 토끼와 거북이 알고리즘을 사용하면 된다.   이 알고리즘은 사이클을 감지할 수 있다. 중복된 숫자가 있다면 사이클이 있다는 것이므로 이 알고리즘을 사용하면 된다.   거북이는 한 칸씩 이동하고, 토끼는 거북이보다 두 배 빨리 (두 칸씩) 이동하면 된다.   만약 만나게 된다면 하나의 포인터를 배열의 처음으로 돌아가게 한 다음, 두 포인터 모두 한 칸씩 이동하게 한다.   이 때 만나는 곳이 사이클의 시작 부분이기 때문에 중복된 숫자를 찾을 수 있다.   https://www.youtube.com/watch?v=9YTjXqqJEFE&amp;ab_channel=JomaClass 여기에 증명이 잘 나와있으므로 참고!  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Find-the-Duplicate-Number/",
        "teaser": null
      },{
        "title": "[leetcode] Valid Parenthesis String",
        "excerpt":"[leetcode] Valid Parenthesis String  문제 링크   class Solution { public:     stack &lt;char&gt; open;     stack &lt;char&gt; star;     bool checkValidString(string s) {         if(!s.length()) return true;                  for(int i=0; i&lt;s.length(); i++) {             if(s[i] == '*') {                 star.push(i);             } else if(s[i] == '('){                 open.push(i);             } else {                 if(!open.empty()) open.pop();                 else if(!star.empty()) star.pop();                 else if(open.empty()) return false;             }         }                  while(!open.empty() &amp;&amp; !star.empty()) {             if(open.top() &gt; star.top()) return false;             open.pop();             star.pop();         }                  return open.empty();              } };     stack 2개로 접근 한 문제   처음에는 인덱스가 아닌 char자체를 넣었는데 오답이었다. 인덱스를 넣게 되면 언제 들어갔는지 확인 할 수 있어서 답을 도출 해 낼 수 있다.   열리는 브라켓과 별모양은 바로 push 해 주고, 닫히는 브라켓일 경우에            열리는 브라켓에서 팝 -&gt; 스타에서 팝 -&gt; 비어있다면 false       순으로 체크 해 줘야 한다.           반복문이 끝난 후에는 둘 중 하나가 빌 때까지 pop 해주는데, 이 때 open의 인덱스가 star의 인덱스보다 크다면, 그 브라켓은 닫을 수 없기 때문에 false이다.   dp로 푸는 방법도 있던데 따로 인강이 없어서 패스 &gt;&lt;~  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Valid-Parenthesis-String/",
        "teaser": null
      },{
        "title": "[leetcode] Wiggle Subsequence",
        "excerpt":"[leetcode] Wiggle Subsequence  문제 링크   class Solution { public:     int wiggleMaxLength(vector&lt;int&gt;&amp; nums) {         int n = nums.size();         if(n == 0) return 0;         int down[n];         int up[n];         memset(down, 0, sizeof(down));         memset(up, 0, sizeof(up));                  up[0] = down[0] = 1;         for(int i=1; i&lt;nums.size(); i++) {             if(nums[i-1] &lt; nums[i]) {                 up[i] = down[i-1] + 1;                 down[i] = down[i-1];             } else if(nums[i-1] &gt; nums[i]) {                 down[i] = up[i-1] + 1;                 up[i] = up[i-1];             } else {                 down[i] = down[i-1];                 up[i] = up[i-1];             }         }                  return max(up[n-1], down[n-1]);     } };     dp 문제   down, up, down을 반복하는 배열의 최대 길이를 구하는 문제이다.   나올 수 있는 경우의 수는 3가지이다.            올라가는 경우       내려가는 경우       같을 경우           down 배열과 up 배열을 만들어 최대 길이를 저장 해 준다.   올라가는 경우엔 up은 down의 하나 전보다 +1 된 길이이고, down의 길이는 그대로 유지된다.   내려가는 경우엔 down은 하나 늘어나고, up은 유지된다.   같은 경우에는 둘 다 유지된다.   둘 중 더 긴 것을 리턴하면 답이다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Wiggle-Subsequence/",
        "teaser": null
      },{
        "title": "[백준 2631] 줄세우기",
        "excerpt":"[백준 2631] 줄세우기  문제 링크   using namespace std; int N; int numbers[1000004]; int dp[1000004]; int main() {      cin &gt;&gt; N;      for(int i=0; i&lt;N; i++) cin &gt;&gt; numbers[i];      int ret = 0;     for(int i=0; i&lt;N; i++) {         dp[i] = 1;         for(int j=0; j&lt;i; j++) {             if(numbers[i] &gt; numbers[j] &amp;&amp; dp[j] + 1 &gt; dp[i]) {                 dp[i] = max(dp[i], dp[j] + 1);             }         }         ret = max(ret, dp[i]);     }     cout &lt;&lt; N - ret &lt;&lt; endl;      return 0; }      LIS 응용 문제이다.   아이들을 오름차순으로 순서대로 정렬하기 위한 최소 움직임을 구하는 문제이다.   움직이는 데에 제약은 없기 때문에, 이미 자리를 찾은 아이는 두고, 잘못 있는 애들만 옮겨주면 된다.   그렇다면 오름차순으로 정렬 되어 있는 가장 긴 배열의 길이를 찾으면 된다. -&gt; LIS   전체 길이에서 LIS의 길이를 빼면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-2631-%EC%A4%84%EC%84%B8%EC%9A%B0%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[백준 7570] 줄세우기",
        "excerpt":"[백준 7570] 줄세우기  문제 링크   int N; int numbers[1000004]; int dp[1000004]; int main() {     ios_base::sync_with_stdio(false);     cin.tie(NULL);cout.tie(NULL);     cin &gt;&gt; N;      int ret = 0;     int num;     for(int i=1; i&lt;=N; i++) {         cin &gt;&gt; num;         dp[num] = dp[num - 1] + 1;         ret = max(dp[num], ret);     }      cout &lt;&lt; N - ret &lt;&lt; endl;      return 0; }     LIS 응용 문제이다.   2631의 줄 세우기와 비슷하지만, 아이들을 정렬 할 때에 앞이나 뒤로만 보낼 수 있다는 것이 차이점이다.   그렇기 때문에 오름차순이면서, 크기가 1 차이만 나는 애들을 고정시키면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-7570-%EC%A4%84%EC%84%B8%EC%9A%B0%EA%B8%B0/",
        "teaser": null
      },{
        "title": "[leetcode] House Robber II",
        "excerpt":"[leetcode] House Robber II  문제 링크   class Solution { public:     int rob(vector&lt;int&gt;&amp; nums) {         int n = nums.size();         if(n &lt; 1) return 0;         if(n &lt; 2) return nums[0];         if(n &lt; 3) return max(nums[0], nums[1]);                  int dp[n+1];         memset(dp, 0, sizeof(dp));         dp[0] = nums[0];         dp[1] = max(nums[0], nums[1]);                  for(int i=2; i&lt;n; i++) {             dp[i] = max(dp[i-2] + nums[i], dp[i-1]);         }         int temp = dp[n-2];                  dp[1] = nums[1];         dp[2] = max(nums[1], nums[2]);                  for(int i=3; i&lt;n; i++) {             dp[i] = max(dp[i-2] + nums[i], dp[i-1]);         }                  return max(temp, dp[n-1]);              } };      dp문제.   끝 집과 처음 집이 이어져 있기 때문에 0부터 시작하는 것 한 번, 1부터 시작 하는 것 한 번씩 dp를 진행 해 준 후, 둘 중에 더 큰 값을 리턴 해 주면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-House-Robber-II/",
        "teaser": null
      },{
        "title": "[leetcode] Best Time to Buy and Sell Stock with Cooldown",
        "excerpt":"[leetcode] Best Time to Buy and Sell Stock with Cooldown  문제 링크   class Solution { public:     int maxProfit(vector&lt;int&gt;&amp; prices) {         int n = prices.size();         if(n &lt; 1) return 0;                  int sold = 0, hold = INT_MIN, rest = 0;                  for(int i=0; i&lt;n; i++) {             int prevSold = sold;             sold = hold + prices[i];             hold = max(hold, rest - prices[i]);             rest = max(rest, prevSold);         }                  return max(sold, rest);     } };      dp + State Machine   총 세 가지의 경우의 수가 있다. 팔았거나 (sold), 휴식하거나 (rest), 유지하거나 (held).      sold state는 주식을 판 상태이다. 해당 값을 기존의 값에 더해준다.   held state는 대기 상태이다. 휴식 상태 이후에 구매하거나, 대기 상태를 유지하는 경우의 수가 있다.   rest state는 휴식 상태이다. 구매 이후에 휴식하거나, 휴식을 유지하는 경우의 수가 있다.   해당 state들을 갱신 해 주면서, 최종적인 상태는 판매를 했거나 판매 이후를 비교 해 주면 된다. (더이상의 구매는 불가능하기 때문)  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown/",
        "teaser": null
      },{
        "title": "[leetcode] Sort List",
        "excerpt":"[leetcode] Sort List  문제 링크   class Solution { public:     ListNode* sortList(ListNode* head) {         if(!head || !head-&gt;next) return head;                  ListNode* slow = head;         ListNode* fast = head-&gt;next;                  while(fast &amp;&amp; fast-&gt;next) {             slow = slow-&gt;next;             fast = fast-&gt;next-&gt;next;         }                  fast = slow-&gt;next;         slow-&gt;next = NULL;                  return merge(sortList(head), sortList(fast));     }          ListNode *merge(ListNode *l1, ListNode *l2) {         ListNode *dummy = new ListNode(0);         ListNode *cur = dummy;                  while(l1 &amp;&amp; l2) {             if(l1-&gt;val &lt; l2-&gt;val) {                 cur-&gt;next = l1;                 l1 = l1-&gt;next;             } else {                 cur-&gt;next = l2;                 l2 = l2-&gt;next;             }             cur = cur-&gt;next;         }                  if(l1) cur-&gt;next = l1;         if(l2) cur-&gt;next = l2;                  return dummy-&gt;next;     } };      O(nlogn)의 시간, O(1)의 공간복잡도 내로 해결 해야 하므로 합병정렬을 사용하였다.   slow, fast 포인터로 가운데를 찾는다.   리스트가 1개나 2개일 때 까지 재귀로 가운데를 쪼개준다.   다 쪼개면 merge함수로 합친다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Sort-List/",
        "teaser": null
      },{
        "title": "[백준 1969] DNA",
        "excerpt":"[백준 1969] DNA  문제 링크   #include \"header.h\" using namespace std; int N, M; vector &lt;string&gt; str; void input() {     cin &gt;&gt; N &gt;&gt; M;     for(int i=0; i&lt;N; i++) {         string s;         cin &gt;&gt; s;         str.push_back(s);     } } void solve() {          int distance = 0;     string hamming;      for(int i=0; i&lt;M; i++) {         map &lt;char, int&gt; m;         int cnt = 0;         char c = 'Z';         for(int j=0; j&lt;N; j++) {             m[str[j][i]]++;                          if(cnt &lt; m[str[j][i]]) {                 cnt = m[str[j][i]];                 c = str[j][i];             } else if(cnt == m[str[j][i]]) {                 if((int)c &gt; (int)str[j][i]) c = str[j][i];             }         }          distance += (N - cnt);         hamming += c;     }     cout &lt;&lt; hamming &lt;&lt; endl &lt;&lt; distance &lt;&lt; endl; } int main () {     input();     solve();     return 0; }     브루트포스로 푸는 문제.   문제가 좀 헷갈리게 나왔는데, 세로로 탐색하면서 제일 많이 나온 글자가 해밍턴뭐시깽이가 된다.   세로를 모두 탐색 하면 제일 많이 나온 글자들로 문자열이 생성되는데,   (세로로 탐색하면서) 그 글자와 다른 글자의 갯수의 누적합이 답이다.   이 때, 다른 글자의 갯수가 같다면 사전순으로 정렬 해야 한다.   정렬 하기 위해서 c를 Z로 초기화 시켜두고, 아스키 코드 번호를 비교했다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EB%B0%B1%EC%A4%80-1969-DNA/",
        "teaser": null
      },{
        "title": "[leetcode] Battleships in a Board",
        "excerpt":"[leetcode] Battleships in a Board  문제 링크   class Solution { public:     int dx[4] = {-1, 1, 0, 0};     int dy[4] = {0, 0, -1, 1};     int answer;          void dfs(int x, int y, vector&lt;vector&lt;char&gt;&gt;&amp; board) {                  for(int i=0; i&lt;4; i++) {             int nx = x + dx[i];             int ny = y + dy[i];                          if(nx &lt; 0 || ny &lt; 0 || nx &gt;= board.size() || ny &gt;= board[0].size() || board[nx][ny] != 'X') continue;             board[nx][ny] = '.';             dfs(nx, ny, board);         }     }          int countBattleships(vector&lt;vector&lt;char&gt;&gt;&amp; board) {                  int n = board.size();         int m = board[0].size();         for(int i=0; i&lt;n; i++) {             for(int j=0; j&lt;m; j++) {                 if(board[i][j] == 'X') {                     answer++;                     dfs(i, j, board);                 }             }         }                  return answer;     } };     단순한 dfs 문제.   지금 생각 해 보니 board를 수정하면 안되므로… 방문 처리를 다르게 해줘야 할 것 같다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Battleships-in-a-Board/",
        "teaser": null
      },{
        "title": "[leetcode] Minimum Domino Rotations For Equal Row",
        "excerpt":"[leetcode] Minimum Domino Rotations For Equal Row  문제 링크   class Solution { public:     int minDominoRotations(vector&lt;int&gt;&amp; A, vector&lt;int&gt;&amp; B) {         int n = A.size();         int m = B.size();                  for(int i=1; i&lt;=6; i++) {             int flag = 1;             int a_cnt = 0, b_cnt = 0;             for(int j=0; j&lt;A.size(); j++) {                 if(A[j] != i &amp;&amp; B[j] != i) { flag = 0; break; }                 else if(A[j] == i &amp;&amp; B[j] == i) continue;                 else if(A[j] == i) a_cnt++;                 else if(B[j] == i) b_cnt++;             }                          if(flag) return min(a_cnt, b_cnt);         }                  return -1;     } };      if문의 순서만 조심하면 된다.   medium 까지는 아닌듯..?  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Minimum-Domino-Rotations-For-Equal-Row/",
        "teaser": null
      },{
        "title": "[leetcode] Reverse Linked List",
        "excerpt":"[leetcode] Reverse Linked List  문제 링크   Iterative  class Solution { public:     ListNode* reverseList(ListNode* head) {         ListNode *prev = NULL;         ListNode *cur = head;                  while(cur) {             ListNode *temp = cur-&gt;next;             cur-&gt;next = prev;             prev = cur;             cur = temp;         }                  return prev;     } };   Recursive  class Solution { public:     ListNode* reverseList(ListNode* head) {         if(!head || !head-&gt;next) return head;                  ListNode *p = reverseList(head-&gt;next);         head-&gt;next-&gt;next = head;         head-&gt;next = NULL;         return p;     } };  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Reverse-Linked-List/",
        "teaser": null
      },{
        "title": "[leetcode] Coin Change",
        "excerpt":"[leetcode] Coin Change  문제 링크       int coinChange(vector&lt;int&gt;&amp; coins, int amount) {         int n = coins.size();         if(!amount) return 0;         if(!n) return -1;         int dp[amount + 1];                  for(int i=0; i&lt;=amount; i++) dp[i] = INT_MAX - 1;                  dp[0] = 0;         for(int i=1; i&lt;=amount; i++) {             for(int j=0; j&lt;n; j++) {                 if(i &gt;= coins[j]) {                     dp[i] = min(dp[i], dp[i - coins[j]] + 1);                 }             }         }                  return dp[amount] &gt; amount ? -1 : dp[amount];              } };     dp 문제.   memset은 0, -1 이외에는 초기화 되지 않는다! 이것땜에 계속 에러남   반복문을 amount까지 진행 해 준다. dp[i]는 i원을 만들 수 있는 동전의 최소 갯수이다.   동전의 갯수만큼 반복 하면서, 돈 - 동전이 가능하다면 dp를 업데이트 해 준다.   만약 dp의 값이 INT_MAX-1(최댓값) 이라면 -1을 출력, 아니라면 dp의 값을 출력해준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Coin-Change/",
        "teaser": null
      },{
        "title": "[leetcode] Reorder List",
        "excerpt":"[leetcode] Reorder List  문제 링크   class Solution { public:     void reorderList(ListNode* head) {         if(!head || !head-&gt;next) return;                  // find the middle         ListNode *cur1 = head;         ListNode *cur2 = head-&gt;next;         while(cur2 &amp;&amp; cur2-&gt;next) {             cur1 = cur1-&gt;next;             cur2 = cur2-&gt;next-&gt;next;         }                  cur2 = cur1-&gt;next;         cur1-&gt;next = NULL;                  // reverse second list         ListNode *prev = NULL;         while(cur2) {             ListNode *temp = cur2-&gt;next;             cur2-&gt;next = prev;             prev = cur2;             cur2 = temp;         }                  cur1 = head;         cur2 = prev;         ListNode *temp = NULL;         while(cur1 &amp;&amp; cur2) {             temp = cur1;             cur1 = cur1-&gt;next;             temp-&gt;next = cur2;                          temp = cur2;             cur2 = cur2-&gt;next;             temp-&gt;next = cur1;         }              } };      리스트를 둘로 쪼갠다.   두 번째 리스트를 반대로 정렬한다. (4-5-6 =&gt; 6-5-4)   첫 번째 리스트와 두 번째 리스트를 번갈아가면서 이어준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Reorder-List/",
        "teaser": null
      },{
        "title": "[OS] Ch5. CPU 스케쥴링",
        "excerpt":"기본 개념     단일 처리기에서는 오직 하나의 프로세스만이 실행 가능하다.   다중 프로그래밍의 목적은 CPU 사용률 최대화이다. =&gt; 스케쥴링 알고리즘이 중요해짐   CPU 입출력 버스트 사이클 (CPU I/O Burst Cycle)     프로세스 실행은 CPU버스트, I/O 버스트가 번갈아가면서 사이클을 이룬다.   CPU 스케쥴러     단기 스케쥴러라고도 한다.   메모리 내의 프로세스를 CPU에 할당한다.   선점 스케쥴링 (Preemptive Scheduling)     중간에 교체 가능 한 스케쥴링   Race condition이 발생 할 수 있다   디스패처 (Dispatcher)     CPU의 제어를 실행되는 프로세스에게 주는 모듈이다.            문맥 교환, 사용자 모드 전환, 사용자 프로그램의 적절한 위치로 이동(jump)의 기능이 있다.           모든 프로세스의 문맥 교환 시 실행된다.            이 때의 지연을 dispatch latency라고 한다.           스케쥴링 기준     CPU 이용률 ↑   처리량 ↑            단위 시간 당 처리한 프로세스의 갯수           총 처리 시간 ↓   대기 시간 ↓            준비 완료 큐에서의 총 대기시간           응답 시간 ↓   스케쥴링 알고리즘  FCFS (First Come First Served)     가장 빨리 온 프로세스가 가장 먼저 처리됨   convoy effect 발생 가능            가장 많은 시간이 소요되는 프로세스가 맨 먼저 오게 돼 대기 시간이 많아진다.           비선점형   SJF (Shortest Job First)     가장 짧은 프로세스가 먼저 수행된다.   장기 스케쥴링 시 주로 사용된다. (시간을 파악해야 하므로)   비선점   SRJF (Shortest Remaining Job First)     SJF의 선점형   우선 순위     우선 순위를 부여 해 높은 우선순위부터 실행한다.   기아 상태, 무한 봉쇄의 가능성이 있다.            시간이 지날 수록 우선순위를 높이는 Aging으로 해결 할 수 있다.           선점형과 비선점형 둘 다 가능하다.   Round Robin     동일한 시간만큼 프로세스를 번갈아가면서 실행한다.   선점형   Time Slice가 너무 크면 FCFS와 다를 바가 없고, 너무 작으면 오버헤드가 커진다.   다단계 큐     Ready 큐를 여러 개 생성한다.   ex) foreground 큐, background 큐를 생성 해 foreground를 우선적으로 처리한다.   RR 사용 해 slice한다.   비선점   다단계 피드백 큐     프로세스가 CPU사이를 이동할 수 있다.     멀티 프로세서 스케쥴링          load sharing(부하 공유)가 중요하다.       비대칭 다중처리            주 서버와 보조서버를 둔다.       주 서버는 시스템적인 처리를 한다. (스케쥴링 결정, I/O)       보조 서버는 사용자 코드 처리를 한다.           대칭 다중처리 (SMP, Symmetric Multiprocessing)            각 처리기가 독자적으로 처리한다.           처리기 친화성 (Processor Affinity)     한 처리기에서 다른 처리기로의 이주를 피한다.   Soft Affinity : 이주 가능   Hard Affinity : 이주 불가능   Load Balancing     SMP 시스템에서는 부하 분배가 균등해야 한다.   push 이주, pull 이주   다중코어 프로세서     하나의 칩에 처리기가 여러 개 존재   스케쥴링이 복잡해짐   캐시 미스로 메모리 멈춤(stall) 발생 시 처리기 내부의 스레드를 통해 전환한다.   거친(coarse-grained) 다중스레딩            긴 지연 시간일 시 다중스레드 실행           세밀한(fine-grained) 다중스레딩   실시간 CPU 스케쥴링     Soft 실시간 시스템            데드라인이 X           Hard 실시간 시스템            데드라인 O           지연시간 최소화            인터럽트 지연       디스패치 지연           승인 제어(admission-control) 알고리즘     마감 시간 이내에 완수 가능하다면 승인, 아니라면 거절   Rate Monotonic 알고리즘     주기에 따라 우선순위 결정   주기가 짧은게 우선   CPU 자원 최대화 불가능   Earliset Deadline First     우선 순위 동적 부여   마감 시간이 빠른게 우선  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch5.-CPU-%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81/",
        "teaser": null
      },{
        "title": "[leetcode] As Far from Land as Possible",
        "excerpt":"[leetcode] As Far from Land as Possible  문제 링크   class Solution { public:     int answer = -1;     int m, n;     void bfs(vector&lt;vector&lt;int&gt;&gt;&amp; grid, queue &lt;pair&lt;int, int&gt;&gt;&amp; q) {         int dx[4] = {0, 0, -1, 1};         int dy[4] = {-1, 1, 0, 0};          while(!q.empty()) {             int sz = q.size();             answer++;                          while(sz--) {                 int topx = q.front().first;                 int topy = q.front().second;                 q.pop();                                  for(int i=0; i&lt;4; i++) {                     int nx = topx + dx[i];                     int ny = topy + dy[i];                                          if(nx &lt; 0 || ny &lt; 0 || nx &gt;= m || ny &gt;= n || grid[nx][ny]) continue;                     q.push({nx, ny});                     grid[nx][ny] = grid[topx][topy] + 1;                 }             }         }              }     int maxDistance(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {                  m = grid.size();         n = grid[0].size();         queue &lt;pair&lt;int, int&gt;&gt; q;          for(int i=0; i&lt;m; i++) {             for(int j=0; j&lt;n; j++) {                 if(grid[i][j]) q.push({i, j});             }         }                  if(q.size() == m * n || !q.size()) return -1;                  bfs(grid, q);                  return answer;     } };     bfs로 푸는 문제이다.   맵을 돌면서 땅인 경우 큐에 삽입한다. -&gt; 이 경우를 제외하기 위해 answer를 -1로 초기화시켜준다.   모든 맵이 땅이거나, 물일 경우는 -1을 리턴하고 아니라면 bfs를 돈다.   땅의 갯수만큼만 돌면서 물인 경우에 넣어준다.   bfs를 돌 때마다 answer를 1씩 올려준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-As-Far-from-Land-as-Possible/",
        "teaser": null
      },{
        "title": "[leetcode] Remove Linked List Elements",
        "excerpt":"[leetcode] Remove Linked List Elements  문제 링크   class Solution { public:     ListNode* removeElements(ListNode* head, int val) {         ListNode *cur = head;         if(!head) return head;                  while(cur-&gt;next) {             if(cur-&gt;next-&gt;val == val) cur-&gt;next = cur-&gt;next-&gt;next;             else cur = cur-&gt;next;         }                  if(head-&gt;val == val) head = head-&gt;next;                  return head;     } };  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Remove-Linked-List-Elements/",
        "teaser": null
      },{
        "title": "[OS] Ch5. 연습문제",
        "excerpt":"1. 스케쥴러가 입출력 중심 프로그램과 CPU 중심 프로그램을 구분하는 것이 중요한 이유는 무엇인가?     입출력 중심 프로그램은 짧은 CPU 버스트를 많이 가지고, CPU 중심 프로그램은 다수의 긴 CPU 버스트를 갖는다. 다중 프로그래밍 환경에서 프로세스의 실행은 입출력과 CPU실행의 사이클을 반복하므로, CPU 스케줄링 결정에 매우 중요할 수 있다.   2. 다음과 같은 두 스케쥴링 기준들은 어떤 상황에서 서로 충돌하는 지 논의하시오.     a. CPU 이용률과 응답 시간            문맥 교환이 자주 일어나면 오버헤드가 발생하고, CPU 이용률이 증가 된다. 오버헤드를 줄이기 위해선 문맥교환의 빈도를 줄이면 되는데, 이는 응답 시간 증가를 초래할 수 있다.           b. 평균 총처리 시간과 최대 대기 시간            짧은 프로세스를 먼저 처리하면 평균 총 처리 시간이 줄어들지만, 긴 프로세스의 대기 시간이 늘어나 기아 현생이 발생할 수 있다. 이는 최대 대기시간의 증가로 이어진다.           c. 입출력 장치 이용률과 CPU 이용률            CPU 이용률은 CPU-bound 프로세스를 실행 할 때 늘어나고, 입출력 장치 이용률은 I/O-bound 프로세스를 실행 할 때 늘어난다. I/O-bound 프로그램들은 보통 짧은 CPU-burst를 가지고 있고, 이는 많은 문맥교환으로 이어지고 CPU 이용률을 줄이게 된다.           4. 5장에서 다양한 커널 자료구조에서 발생할 수 있는 경쟁조건에 대해 논의하였다. 거의 모든 스케줄링 알고리즘은 실행 큐를 유지하여 스케줄 할 프로세스들을 관리한다. 다중코어 시스템에서는 다음 두 가지 선택이 존재한다. (1) 각 처리기 코어마다 각자의 실행 큐를 유지하거나 (2) 하나의 실행 큐를 모든 처리기 코어가 공유한다. 각 선택의 장단점은 무엇인지 설명하시오.     각 처리기 코어마다 큐가 있을 경우에는 독립 되어 있기 때문에 충돌이 일어나지 않고, 프로세스를 병렬적으로 실행 할 수 있다. 스케쥴링을 결정 할 때, 가지고 있는 큐만 점검하면 된다.   싱글 큐라면 race condition을 주의 해야 한다. 하지만, 로드밸런싱을 고려하지 않아도 된다.   6. 라운드로빈 스케줄러의 한 가지 변형은 퇴행 라운드 로빈(Regressive Round Robin) 스케줄러이다. 이 스케줄러는 각 프로세스에게 시간 할당량과 우선순위를 부여한다. 시간 할당량의 초기값은 50ms이지만 프로세스에 CPU가 할당되고(입출력 때문에 봉쇄되지 않고) 시간 할댱량을 소진할 때마다 10ms씩 시간 할당량이 증가되고 우선순위가 상승된다(시간 할당량은 최대 100 ms까지 증가된다). 시간 할당량을 소진하기 전에 프로세스가 봉쇄되면 시간 할당량이 5ms씩 감소되지만 우선순위는 변하지 않는다. 이 퇴행 라운드 로빈 스케줄러는 CPU 중심 프로세스와 입출력 중심 프로세스 중에 어느 프로세스를 우대하는지 설명하시오.     CPU 중심 프로세스를 우대한다. 프로세스를 많이 실행 할 수록 우선순위가 높아지고, 적게 실행 할 수록 우선순위가 낮아진다. CPU를 blocking 하면 시간 할당량이 감소하기 때문에 선호되지 않는다. I/O 중심 프로세스는 blocking 하기 때문에 선호되지 않는다.   10. 다음 알고리즘 중 기아 현상을 일으킬 수 있는 알고리즘은 무엇인가?  a. 선입 선처리 b. 최소 작업 우선 c. 라운드 로빈 d. 우선순위   d, Aging으로 해결 할 수 있다.   13. 다단계 큐 스케줄링을 구현한 시스템을 고려하자. 자신의 프로세스에게 할당된 CPU 시간이 최대가 되게 하기 위해서 사용자는 어떤 전략을 세울 수 있는가?     모든 시간 할당량을 사용하지 않음으로서 CPU 시간을 최대화 할 수 있다. 시간 할당량이 끝나기 전에 CPU를 포기 하여 프로세스와 관련된 우선 순위를 높인다.   15. 다음의 알고리즘들이 짧은 프로세스를 우대하는 정도의 차이에 대해 설명하시오.     a. FCFS            우대 하지 않는다.           b. RR            모든 프로세스에게 동일한 시간을 부여하기 때문에, 가장 짧은 프로세스가 제일 먼저 완수된다.           c. 다단계 피드백 큐            짧은 프로세스에게 최고 우선순위를 부여한다.           20. 실시간 시스템에서 우선순위 역전 문제를 해결할 수 있는 방안에 대해 논의하시오. 또한 그러한 해결 방안을 일정 비율의 몫 스케줄러 안에 구현할 수 있는지에 대해서도 논의하시오.     관련된 프로세스들의 우선 순위를 잠시 바꿈으로서 해결 할 수 있다. 자원에 접근하는 프로세스들은 동작이 끝날 때 까지 높은 우선순위를 가지게 하고, 끝나면 원래 우선 순위로 돌려놓는다.   23. 경성 실시간 시스템에서 인터럽트와 디스패치 지연 시간이 일정 시간 내로 한정되는 것이 보장되어야 하는 이유를 설명하시오.     디스패치 지연 시간은 하나의 프로세스를 중단 하고 다른 것을 시작 할 때의 지연이다. 인터럽트와 디스패치 지연 시간은 둘 다 실시간 시스템에서 빠른 응답을 위해 최소화 되어야 한다.   What advantage is there in having different time-quantum sizes at different levels of a multilevel queueing system?  다단계 피드백 큐에서 시간 퀀텀의 크기를 레벨마다 다르게 하게 되면 어떤 이득을 얻을 수 있는가?     즉각적인 변경이 필요한 것들은(ex. 텍스트 편집기) time-quantum의 크기를 작게 하는 것이 좋고, 그게 아니라면 문맥 교환을 최소화 하기 위해 크기를 크게 하는 것이 좋다.  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch5.-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[leetcode] Add Two Numbers II",
        "excerpt":"[leetcode] Add Two Numbers II  문제 링크   class Solution { public:     ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {         stack &lt;ListNode*&gt; st1;         stack &lt;ListNode*&gt; st2;                  ListNode *cur = l1;         while(cur) {             st1.push(cur);             cur = cur-&gt;next;         }                  cur = l2;         while(cur) {             st2.push(cur);             cur = cur-&gt;next;         }                  stack &lt;ListNode *&gt; ret;         int flag = 0;         while(!st1.empty() &amp;&amp; !st2.empty()) {             int val = st1.top()-&gt;val + st2.top()-&gt;val + flag;             if(val &gt;= 10) {                 val -= 10;                 flag = 1;             } else flag = 0;                          ret.push(new ListNode(val));             st1.pop();             st2.pop();         }                           while(!st1.empty()) {             int val = st1.top()-&gt;val + flag;             if(val &gt;= 10) {                 val -= 10;                 flag = 1;             } else flag = 0;                          ret.push(new ListNode(val));             st1.pop();         }                  while(!st2.empty()) {             int val = st2.top()-&gt;val + flag;             if(val &gt;= 10) {                 val -= 10;                 flag = 1;             } else flag = 0;              ret.push(new ListNode(val));             st2.pop();         }                  if(flag) ret.push(new ListNode(1));          ListNode *head = new ListNode(0);         cur = head;         while(!ret.empty()) {             cur-&gt;next = ret.top();             cur = cur-&gt;next;             ret.pop();         }                  return head-&gt;next;     } };     맨 처음에는 똑같은 방식인데 노드를 반대 방향으로 정렬 후에 진행 하였다.   조건에 반대로 정렬 하면 안된다는 것을 뒤늦게 봐서.. 스택으로 풀었다.   더한 값이 10 이상이 되는 경우를 주의해서 풀면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Add-Two-Numbers-II/",
        "teaser": null
      },{
        "title": "[leetcode] Minimum Depth of Binary Tree, Maximum Depth of Binary Tree",
        "excerpt":"[leetcode] Minimum Depth of Binary Tree  문제 링크   class Solution { public:     int minDepth(TreeNode* root) {         if(!root) return 0;                  if(!root-&gt;left) return minDepth(root-&gt;right) + 1;         if(!root-&gt;right) return minDepth(root-&gt;left) + 1;                  return min(minDepth(root-&gt;left), minDepth(root-&gt;right)) + 1;     } };   [leetcode] Maximum Depth of Binary Tree  문제 링크  class Solution { public:     int maxDepth(TreeNode* root) {         if(!root) return 0;         return max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + 1;     } };  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Minimum-Depth-of-Binary-Tree,-Maximum-Depth-of-Binary-Tree/",
        "teaser": null
      },{
        "title": "[OS] Ch6. 연습문제",
        "excerpt":"4. 동기화 프리미티브가 사용자 수준 프로그램에서 사용되는 경우, 단일 처리기 시스템에서 인터럽트 불능을 이용하여 동기화 프리미티브를 구현하는 것이 왜 부적당한지 설명하시오.     만약 사용자 수준에서 인터럽트 불능을 할 수 있다면 문맥 교환을 막거나 타이머 인터럽트를 불능 시킬 수 있기 때문에 다른 프로세스가 실행 되지 않을 수 있다.   5. 다중 처리기 시스템을 위한 동기화 프리미티브를 구현할 때 인터럽트를 사용하는 것이 부적합한 이유를 설명하시오.     다중 처리기 시스템에서 인터럽트를 사용하는 것은 효율적이지 않다. 인터럽트가 하나의 코어에서만 작동한다면 다른 프로세스들이 공유 자원에 접근하게 되기 때문에 동기화가 되지 않을 것이다. 모든 코어에서 작동하게 된다면 모든 프로세스들에서 I/O 작업, task dispatching 등도 같이 멈추기 때문에 CPU 사용률이 현저히 떨어지게 될 것이다.   6. Linux 커널은 정책적으로 세마포를 획득하려고 시도 중인 프로세스는 스핀락을 가질 수 없게끔 제한한다. 이 정책이 사용되는 이유는 무엇인가?     스핀락은 다른 프로세스가 짧은 시간 동안 점유 할 경우에 주로 사용된다. 세마포는 문맥 교환을 2번 하는게 더 나은 경우에 쓰이기 때문에, 그만큼 오랜 시간동안 임계 구역을 점거한다는 의미이다. 따라서 세마포를 획득하려고 시도 중이라면, 그만큼 많은 시간을 필요로 하는 프로세스이기 때문에 스핀락은 효율적이지 못한 정책이다.   7. 경쟁 조건이 발생할 가능성이 있는 커널 자료구조 2개를 기술하시오. 경쟁 조건이 어떤 경우에 발생할 수 있는지에 대한 설명이 반드시 포함되어야 한다.     메모리 할당을 관리하는 자료구조            같은 주소 번지에 할당하려고 할 때 경쟁 조건이 발생할 수 있다.           프로세스 리스트를 유지하는 자료구조            프로세스가 동시에 생성되는 경우 pid를 부여 할 때 경쟁 조건이 발생할 수 있다.           11. 시스템이 다중 처리 코어를 가지고 있다고 가정하자. 다음 각 시나리오에 대해 스핀락과 mutex락 중 어떤 것이 더 좋은 락킹 기법인지 설명하시오. mutex락은 기다리는 프로세스가 락의 사용이 가능해질 때까지 기다리는 동안 수면상태에 들어가게 된다.     락은 짧은 동안만 사용된다.            스핀락           락은 긴 시간 동안 사용된다.            뮤텍스           스레드가 락을 가진 채로 수면 상태로 들어갈 수 있다.            뮤텍스           19. 동일한 유형의 동기화 문제를 푸는 데 사용될 수 있다는 측면에서 모니터와 세마포가 동등함을 보이시오.     모니터 내부의 프로세스들 중 하나만이 활성화 되고 나머지는 대기한다는 측면에서 세마포도 signal과 wait을 사용하여 프로세스의 실행 순서를 정할 수 있다. 프로세스간 실행 순서를 정해 두면 하나의 프로세스가 끝나기 전까지는 다른 프로세스가 끝나지 않으므로 동기화 문제를 해결할 수 있다.   둘 다 counter와 waiting queue를 사용한다. 모니터는 resource를 캡슐화 할 수 있으므로 좀 더 나은 방안이다.   23. 모니터의 signal() 연산과 세마포에서 정의한 signal() 연산이 어떻게 다른지 설명하시오.     모니터의 signal()은 하나의 보류된 프로세스를 재개 시킨다. 보류된 프로세스가 없다면 아무런 동작을 하지 않는것과 같다.   세마포의 signal()은 락을 방출하는 행위이다. 기다리는 프로세스가 없더라도 semaphore의 값이 하나 올라간다.   What is the meaning of busy waiting? What are the other kinds of waiting in operating system? Can busy waiting be avoided altogether? Explain.     바쁜 대기란 프로세서를 포기하지 않고 계속 루프 문을 돌면서 조건을 만족하기를 기다리는 것이다.   프로세서가 해당 프로세스를 포기 하고 적합한 때에 다시 깨우는 대기 방법도 있다.   바쁜 대기를 피할 순 있지만, 프로세스를 재우고 깨우는 데에 오버헤드가 발생할 수 있기 때문에 짧은 시간을 가지는 프로세스에서는 바쁜 대기를 사용하는 것이 좋다.   Explain why spinlocks are not appropriate for single processor systems yet are often used in multiprocessor environments.     싱글코어에서는 하나의 프로세스만이 실행 될 수 있다. 따라서 스핀락을 종료하려면 문맥 교환을 통해 다른 프로세스를 실행하는 방법 밖에 없다. 스핀락은 의미 없는 행위이다.   ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch6.-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[OS] Ch6. 프로세스 동기화",
        "excerpt":"임계구역 문제 (The Critical-Section Problem)     각 프로세스는 임계구역이라고 부르는 코드 부분을 포함하고 있고, 그 안에서 다른 프로세스와 공유하는 변수를 변경하거나, 테이블 갱신 등의 작업을 진행한다.   이 시스템의 중요한 특징은 한 프로세스가 자신의 임계 구역에서 수행하는 동안 다른 프로세스들은 그 임계구역에 들어갈 수 없다는 사실이다.   각 프로세스는 임계구역에 진입하려면 진입 허가를 요청해야 한다.   요청을 하는 부분을 진입 구역(entry section), 그 뒤는 퇴출 구역(exit session)이라고 한다.   임계 구역이 아닌 구역은 나머지 구역(remainder section) 이라고 한다.   임계 구역 문제 해결안은 다음의 3가지를 충족해야 한다.            상호 배제 (mutual exclusion)                    프로세스가 자기의 임계 구역에서 실행된다면 다른 프로세스들은 자신의 임계 구역에서 실행될 수 없다.                       진행 (progress)                    자기의 임계 구역에서 실행되는 프로세스가 없고 자신의 임계 구역으로 진입하려는 프로세스가 있다면, 나머지 구역이 아닌 프로세스들만 그 다음에 누가 진입할지를 결정하는 데 참여할 수 있다. 이 선택은 무한정 연기될 수 없다.                       한정된 대기 (bounded waiting)                    프로세스가 자기의 임계 구역에 진입하려는 요청을 한 후 부터 허용 될 때 까지 다른 프로세스들이 그들 자신의 임계구역에 진입하는 횟수에 제한이 있어야 한다.                           피터슨의 해결안     flag를 두어 두 개의 프로세스가 번갈아 가면서 실행된다.   Mutex Locks     프로세스는 임계 구역에 들어가기 전에 반드시 lock을 획득 해야 하고, 빠져 나올 때 반납 해야 한다.   acquire() 락을 획득, busy waiting 사용 (spin lock) -&gt; CPU 사이클 낭비, but 문맥 교환을 필요로 하지 않는다. 짧은 시간 동안만 락을 소유할 경우 유용하다.   release() 락을 반환   세마포 (Semaphore)     세마포는 wait()과 signal()로만 접근 가능하다.   카운팅 세마포 값은 제한이 없고, 이진 세마포 값은 0, 1 사이의 값만 가능하다.   따라서 이진 세마포는 mutex락과 유사하게 동작한다.   카운팅 세마포는 가용한 자원의 갯수로 초기화 된다. 자원을 사용하려는 프로세스는 wait() 연산을 수행하며, 세마포의 값이 감소가 된다. 값을 방출 하면 signal()연산을 수행하고, 세마포 값은 증가한다. 세마포의 값이 0이 되면 모든 자원이 사용중이고, 0 이상이 될 때까지 봉쇄된다.   교착 상태와 기아     세마포에서 프로세스들이 하나에 의해서만 야기될 수 있는 상황 (signal 연산)을 무한정 기다리는 상황이 발생할 수 있다. 이를 교착 상태(deadlock) 이라고 한다.   무한 봉쇄, 또는 기아는 세마포에서 무한정 대기하는 것이다. 이는 큐에서 LIFO 순서로 제거할 경우 발생 할 수 있다.   우선순위 역전     셋 이상의 우선 순위를 가진 시스템에서만 발생한다. 상대적으로 낮은 우선 순위를 가진 프로세스가 높은 프로세스에게 영향을 끼치는 상황이다.   두 가지 우선순위만 가지게 하면 해결 할 수 있다.   우선순위 상속 프로토콜을 구현함으로서 해결할 수 있다.            우선순위가 높은 프로세스가 필요로 하는 자원을 사용하는 프로세스들은 끝날 때 까지 더 높은 우선순위를 상속받는다.           고전적인 동기화 문제들  유한 버퍼 문제 (The Bounded-Buffer Problem)     유한한 크기를 가지는 버퍼에 여러 프로세스들이 접근할 때 발생하는 문제.   이진 세마포어를 통해 해결할 수 있다.   Readers-Writers 문제     writer와 reader이 동시에 접근 할 때 발생할 수 있는 문제.   reader/reader 접근은 허용, writer은 한 개만 접근할 수 있도록 함.   식사하는 철학자들 문제 (The Dining-Philosophers Problem)     자신의 바로 좌우의 젓가락만 집을 수 있다.   두 젓가락을 모두 집어야 식사를 할 수 있다.   식사를 하고 난 다음에 두 젓가락을 모두 내려놓는다.   모두 오른쪽의 젓가락을 집게 된다면 아무도 먹을 수 없을 것이다. (교착상태와 기아)   이는 모니터로 해결 할 수 있다.   모니터     세마포를 사용할 때 다음과 같은 문제점이 발생할 수 있다.            코딩하는 것이 힘들다.       타이밍 오류가 발생할 수 있다.       정확성(correctness) 입증이 어렵다.       자발적 협력(voluntary cooperation)이 필요하다.       한 번의 실수가 시스템 전체에 치명적으로 영향을 미친다.           모니터 구조물은 모니터 안에 항상 하나의 프로세스만이 활성화된다. -&gt; 동기화 제약 조건을 구현할 필요 없다.   동기화는 condition이라는 구조물로 제공된다.   condition은 signal()과 wait()을 가지고 있다.   x.wait(), x.signal()과 같이 사용한다.   함수형 프로그래밍 언어     C++, Java와 같은 절차형 언어들은 변수들이 다른 값을 배정받을 수 있기 때문에 변경이 가능하다.   함수형 프로그래밍은 상태를 유지하지 않는다. 변수가 정의 되어 값을 배정받으면 값이 변경 될 수 없기 때문에 경쟁 조건이나 교착 상태의 쟁점에서 자유롭다.  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch6.-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EB%8F%99%EA%B8%B0%ED%99%94/",
        "teaser": null
      },{
        "title": "[leetcode] Remove Duplicate Letters",
        "excerpt":"[leetcode] Remove Duplicate Letters  문제 링크   class Solution { public:     string removeDuplicateLetters(string s) {         map &lt;char, int&gt; count;         for(char c : s) count[c]++;                  map &lt;char, int&gt; used;         string ans = \"\";         for(char c : s) {             count[c]--;             if(used[c]) continue;                          while (count[ans.back()] &amp;&amp; ans.back() &gt; c) {                 used[ans.back()] = 0;                 ans.pop_back();             }             used[c] = 1;             ans.push_back(c);         }                  return ans;     } };     stack을 이용한 문제.   글자가 몇 개 있는지 count에 저장 해 준다.   string의 길이만큼 돌면서 글자들을 더해준다.   들어갈 글자가 이미 사용 된 글자라면 다음으로 넘어간다.   글자의 마지막이 (ans.back()) 현재 들어갈 글자보다 알파벳 순으로 더 늦고, 이후에 더 나올 글자라면 (count[ans.back()]) 글자를 없애준다.   들어갈 글자를 넣어주고, 방문 처리 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Remove-Duplicate-Letters/",
        "teaser": null
      },{
        "title": "[leetcode] Bag of Tokens",
        "excerpt":"[leetcode] Remove Duplicate Letters  문제 링크   class Solution { public:     int bagOfTokensScore(vector&lt;int&gt;&amp; tokens, int P) {         sort(tokens.begin(), tokens.end());         int score = 0;         int answer = 0;                 int left = 0;         int right = tokens.size() - 1;                  while(left &lt;= right) {             if (P &gt;= tokens[left]) {                 score++;                 P -= tokens[left++];                 answer = max(answer, score);             } else if(score) {                 score--;                 P += tokens[right--];              } else break;         }          return answer;     } };     greedy + 투 포인터로 푸는 문제이다.   문제가 영어라 조금 헷갈렸는데, 해석 해 보자면 다음과 같다.            Power가 Tokens[i]보다 크다면 Power를 Tokens[i]만큼 차감 하고 score를 하나 더할 수 있다.       score가 1 이상이라면, score를 하나 차감하고 Tokens[i]만큼 Power에 더할 수 있다.       모든 토큰을 다 사용할 필요가 없다.       최대로 가질 수 있는 점수를 구하면 된다.           토큰을 크기 순서대로 정렬 한 후, left, right 포인터를 두어 최소 최대값을 가리킨다.   토큰을 구입할 수 있다면, 가장 작은 토큰부터 구입 해 나간다.   더 이상 구매할 수 없다면, score를 하나 차감하고 가장 큰 토큰을 구입한다.   left가 right를 넘어갈 때까지 반복한다. (두 포인터가 만날 때 까지)   score가 올라갈 때마다 answer를 갱신 해 주면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Bag-Of-Tokens/",
        "teaser": null
      },{
        "title": "[leetcode] Stone Game IV",
        "excerpt":"[leetcode] Stone Game IV  문제 링크   class Solution { public:     int dp[100001];     bool winnerSquareGame(int n) {                  for(int i=1; i&lt;=n; i++) {             for(int j=1; j * j &lt;= i; j++) {                 if(dp[i-j*j] == 0) {                   dp[i] = 1;                   break;                 }             }         }                  return dp[n];     } };     dp… GGㅎㅎ   Alice, Bob이 게임을 하는데, 돌을 전부 가져가면 이기는 게임이다. 돌은 한 번에 제곱의 수만(1, 4, 9…) 가져갈 수 있다.   돌의 갯수 n이 주어질 때, Alice가 이기는지를 구하면 된다.        플레이어들은 언제나 최선의 선택을 한다.             번갈아 가면서 게임을 하기 때문에, Bob이 돌을 다 없앨 수 없을 때 Alice가 이긴다.   dp[i - j * j]가 false라면 bob이 돌을 다 없애지 못했다는 의미이기 때문에 dp[i]는 true가 된다.   해당 그림을 보면서 생각 해 보자.   i가 5이다.   Alice는 1, 4를 가져갈 수 있다. dp[4], dp[1]은 True이므로, Bob이 이기게 된다. 따라서 dp[5]는 false가 된다. (이길 수 없음)   i는 8이다.   Alice의 차례에 가져갈 수 있는 돌들은 1, 4가 된다.   dp[7], dp[4]는 각각 False, True이다. 늘 최선의 선택을 하기 때문에 Alice는 이길 수 있다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Stone-Game-IV/",
        "teaser": null
      },{
        "title": "[leetcode] Trapping Rain Water",
        "excerpt":"[leetcode] Trapping Rain Water  문제 링크   class Solution { public:     int trap(vector&lt;int&gt;&amp; height) {         int n = height.size();         if(!n) return 0;                  int left = 0;         int right = n-1;         int max_left = height[left];         int max_right = height[right];         int ans = 0;         while(left &lt; right) {             if(height[left] &gt; height[right]) {                 max_right = max(max_right, height[right]);                 ans += max_right - height[right];                 right--;                } else {                 max_left = max(max_left, height[left]);                 ans += max_left - height[left];                 left++;             }         }         return ans;     } };      투 포인터로 푸는 문제.   문제 접근 방식이 조금 헷갈렸다.             이렇게 된 그림을 보자마자 아!! 함.. ㅋㅋㅅㅋㅅㅋㅅ       가운데 있는 공간에 물을 얼마만큼 채울 수 있을까?       left와 right중 작은 막대와의 차이만큼 채울 수 있다.           따라서 left의 값과 right의 값을 비교 해 나가면서 진행한다.   max_left, max_right를 지속적으로 갱신 해 주면서 가장 높은 막대를 저장한다.   left의 값과 right의 값을 비교 해, 더 작은 막대의 차이가 담을 수 있는 물의 양이다.   left, right가 만날 때까지 반복하면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Trapping-Rain-Water/",
        "teaser": null
      },{
        "title": "[OS] Ch7. 교착상태",
        "excerpt":"교착상태     대기 중인 프로세스들이 요청한 자원이 이미 점유되고, 그 프로세스들도 대기 상태일 때 그 상태를 변경할 수 없는 상황   교착 상태의 조건          다음의 4가지 조건이 동시에 성립 될 때 발생한다.       상호 배제 (Mutual Exclusion)            최소 한 개 이상의 자원이 비공유 모드로 점유되어야 한다. 비공유 모드에서는 한 번에 하나의 프로세스만이 그 자원을 사용할 수 있다.           점유 하며 대기 (Hold and Wait)            프로세스는 최소한 하나의 자원을 점유 한 채 자원을 추가로 얻기 위해 대기해야 한다.           비선점 (No Preemtion)            자원들을 선점할 수 없어야 한다.           환형 대기 (Circular Wait)   교착 상태 처리 방법     회피 (Avoidance)            교착 상태가 발생 했을 때 적절히 피해가는 방법       은행원 알고리즘 (Banker's Algorithm)                    프로세스가 자원 요청을 할 때, 자원 할당 뒤에도 시스템이 교착 상태가 일어나지 않는지 확인 후 할당           안정 상태(Safe state)에 있으면 할당, 불안정 상태(Unsafe State)에 있으면 비할당           Max 얼마나 많은 금액을 요구하는가           Available 빌려줄 수 있는 돈           Allocated 현재 빌려준 돈                           예방 (Prevention)            4가지 조건 중 하나를 제거함으로서 해결       가장 자원 낭비가 심하다.       상호 배제 : 한 번에 여러 프로세스가 공유 자원을 사용할 수 있도록 함       점유 대기 : 프로세스가 실행 되기 전 필요한 모든 자원을 할당하거나 자원이 점유되지 않은 상태에서만 자원을 요구하게 함       비선점 : 자원을 점유하고 있는 프로세스가 다른 자원을 요구할 때 점유하고 있는 자원을 반납, 대기하게 함.       환형 대기 : 자원을 선형 순서로 번호를 분배함. 한 쪽 방향으로만 자원을 공유하게 함.           발견 후 처리 (Detect and Recovery)            교착 상태가 발생 했는 지 점검 후 회복시킨다.       교착 상태 발견 알고리즘, 자원 할당 그래프 등을 사용한다.       회복 기법은 교착 상태를 일으킨 프로세스를 종료 시키거나 교착 상태의 자원을 선점하여 해결하는 방법                    자원 선점 시 고려 사항                            희생자 선택 (selection of a victim) : 최소의 피해를 줄 프로세스 선택               후퇴 (rollback) : 일반적으로 일시 중단 시키고 다시 복귀               기아 상태 (starvation) : 한 프로세스가 계속 선점 대상이 되지 않도록 한다. (후퇴 횟수 포함하기)                                                   무시 (Do Nothing)  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch7.-%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C/",
        "teaser": null
      },{
        "title": "[OS] Ch7. 연습문제",
        "excerpt":"2. 동기화 하기 위해 오직 reader-writer 락만을 사용하는 다중스레드 응용을 가정하자. 교착상태가 발생하기 위한 4가지 조건을 적용할 때, 다중 reader-writer 락이 사용되는 경우에도 여전히 교착상태가 발생할 수 있는가?     발생할 수 있다.   상호 배제는 writer가 공유할 수 없기 때문에 지속된다.   점유 대기는 스레드가 reader/writer 락을 대기하면서 소지할 수 있으므로 일어난다.   락을 뺏을 수 없기 때문에 비선점이 일어난다.   스레드들끼리 환형 대기가 일어날 수 있다.   5. 순환 대기 기법과 다양한 교착상태 회피 기법(은행원 알고리즘 같은)을 다음 측면에서 비교하시오.  a. 실행 시간 오버헤드     교착상태 회피 기법은 현재 자원들의 상태를 체크 하기 때문에 오버헤드를 발생 시킨다. b. 시스템 처리율   교착 상태에 들어가는 상태를 피할 수 있기 때문에 시스템 처리율이 증가한다.   6. 은행원 알고리즘으로 교착상태를 관리하고 있다면 아래 중 어떠한 것이, 그리고 어떠한 조건에서 안전하게 변경될 수 있을까?  a. Available 증가     자원의 양은 안전하게 변경될 수 있다.   b. Available 감소     데드락을 유발할 수 있다.   c. 한 프로세스의 Max 증가     데드락을 유발할 수 있다.   d. 한 프로세스의 Max 감소     안전하게 변경 될 수 있다.   e. 프로세스의 수를 증가     불안정상태가 될 수 있다.   f. 프로세스의 수를 감소     안전하게 변경 될 수 있다.   7. 세 개의 프로세스에 의해 공유되는 동일한 유형의 네 개의 자원으로 구성된 시스템을 고려해 보자. 이들 각 프로세스는 최대 두 개의 자원을 필요로 한다. 시스템에 교착상태가 발생하지 않음을 보이시오.     3개의 프로세스가 각각 1개의 자원을 가지고 있다고 가정 해 보자. 각 프로세스는 1개의 자원을 더 필요로 한다. 남은 자원은 1개이므로, 세 개의 프로세스 중 어떤 프로세스에 할당이 되더라도 해당 프로세스는 작업을 끝낼 수 있다. 작업을 끝낸 프로세스가 자원을 반납 하면, 다음 프로세스들도 자원을 가질 수 있기 때문에 교착 상태는 발생하지 않는다.   9. 젓가락이 테이블의 중앙에 있고 철학자에 의해 그 중 2개가 사용될 수 있는 식사하는 철학자 문제를 고려하자. 젓가락에 대한 요청은 한 번에 하나씩 이루어진다고 가정하자. 현재 젓가락이 할당된 상태에서 특정 요청이 교착상태를 유발하지 않고 만족될 수 있는 지를 판단하는 간단한 규칙을 설명하시오.     어느 철학자가 첫 번째 젓가락을 요청 할 때, 두 개의 젓가락을 가진 철학자가 없거나, 1개의 젓가락만 남았다면 요청을 수락하지 않는다.   10. 위의 문제와 똑같은 환경을 고려하자. 이제는 각 철학자가 식사하기 위해서는 3개의 젓가락이 필요하고 자원 요청은 역시 한 번에 하나씩 이루어진다고 가정하자. 현재 젓가락이 할당된 상태에서 특정 요청이 교착상태를 유발하지 않고 만족될 수 있는지 판단하는 간단한 규칙들을 설명하시오.                 적어도 한 개의 젓가락이 남아있고, 2개 이상을 가진 철학자가 있다.                       적어도 두 개의 젓가락이 남아있고, 1개를 가진 철학자가 있다.                       아무도 젓가락을 가지지 않고, 2개의 젓가락이 남아있으며, 2개의 젓가락을 가진 철학자가 있다.           14. 교착상태 탐지는 어떤 낙관적인 가정을 하고 있는가? 이 가정은 어떻게 어긋날 수 있는가?     프로세스가 작업을 마치기까지 더 이상의 추가적인 자원을 필요로 하지 않는다는 가정을 한다.   즉, 프로세스는 종료가 될 시점에 문맥 저장, 파일 입출력 등을 이용하지 않는다는 가정이다.   현재 프로세스의 문맥이 다음 프로세스에 필요하거나, 현재 프로세스의 결과물을 저장한다거나 하면 예외가 발생할 수 있다.  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch7.-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[OS] Ch8. 메모리 관리 전략",
        "excerpt":"스와핑     프로세스는 실행 중 임시로 예비 저장장치로 내보내어졌다가 다시 메모리로 돌아올 수 있다.   스와핑 시간은 오버헤드이다.   한 프로세스를 스왑 아웃 하고 싶다면 해당 프로세스는 휴지 상태에 있어야 한다.            이중 버퍼링 (운영체제의 버퍼와만 입출력을 함) : 오버헤드           연속 메모리 할당 (Contiguous Memory Allocation)     최초 적합            처음으로 사용 가능한 공간을 할당           최적 적합            가능한 공간 중 가장 작은 공간을 할당           최악 적합            가능한 공간 중 가장 큰 공간을 할당           최초 &gt;= 최적 &gt; 최악   단편화     외부 단편화 : 유휴 공간들을 합치면 충분한 공간이 되지만 분산되어 있음            압축(compaction)으로 해결                    메모리 모든 내용들을 한군데로 몰고, 자유 공간을 모아 큰 블럭을 만듬           프로세스들의 재배치가 실행 시간에 동적으로 이루어지는 경우에만 사용 가능.           비용 문제도 고려해야 함                       한 프로세스의 논리 주소 공간을 여러 개의 비연속적인 공간으로 나눔 (페이징, 세그멘테이션)           내부 단편화 : 할당한 메모리 내부에 공간이 남음   세그멘테이션     세그먼트라는 논리적 단위로 나눈다.   외부 단편화가 발생할 수 있음.   메모리 압축을 통해 외부 단편화를 최소화 시킬 수 있음.   분할이 가변적이기 때문에 스와핑은 힘들 수 있다.   페이징보다 공유가 간편함.            페이징: 페이지 테이블의 공유 항목을 표시해야 함, 세그먼테이션: 공유한다고 선언만 하면 됨           페이징     물리 메모리는 프레임이라 불리는 같은 크기 블록으로 나눈다.   논리 메모리는 페이지라 불리는 같은 크기 블록으로 나눈다.   내부 단편화가 발생할 수 있음.   페이지화된 세그멘테이션     페이지와 세그멘테이션의 장점 결합   세그먼트를 페이징한다 -&gt; 세그먼트 안에 별도의 페이지 테이블 존재   외부 단편화 해결   분할공간이 많아져 관리가 힘들 수 있다.  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch8.-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5/",
        "teaser": null
      },{
        "title": "[leetcode] Champagne Tower",
        "excerpt":"[leetcode] Champagne Tower  문제 링크   class Solution { public:     double tower[102][102];     double champagneTower(int poured, int query_row, int query_glass) {                  tower[0][0] = poured;                  for(int i=0; i&lt;=query_row; i++) {             for(int j=0; j&lt;=i; j++) {                 if(tower[i][j] &gt;= 1) {                     tower[i+1][j] += (tower[i][j] - 1) / 2;                     tower[i+1][j+1] += (tower[i][j] - 1) / 2;                     tower[i][j] = 1;                 }             }         }         return tower[query_row][query_glass];     } };     구현 문제.   tower 배열을 만들어 준다. 여기에는 샴페인의 양이 저장 될 곳이다.   맨 처음 잔을 poured로 초기화 시켜준다.   반복문을 돌면서, 만약 해당 잔이 꽉 찼다면 (tower[i][j] &gt;= 1), 그 다음 잔에 넘쳐 흐르게 한다. 다음 잔은 바로 아랫 잔과, 아랫 잔의 옆의 잔을 채우게 된다.   그리고 해당 잔을 1로 초기화 시켜준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Champagne-Tower/",
        "teaser": null
      },{
        "title": "[leetcode] Intersection of Two Linked Lists",
        "excerpt":"[leetcode] Intersection of Two Linked Lists  문제 링크   class Solution { public:     int getLen(ListNode *n) {         int cnt = 0;         while(n) {             cnt++;             n = n-&gt;next;         }         return cnt;     }     ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {          ListNode *curA = headA;         ListNode *curB = headB;                  int cmp = getLen(headA) - getLen(headB);                  while (cmp &lt; 0) {             curB = curB-&gt;next;             cmp++;         }                  while (cmp &gt; 0) {             curA = curA-&gt;next;             cmp--;         }                  while(curA) {             if(curA == curB) return curA;             curA = curA-&gt;next;             curB = curB-&gt;next;         }                  return NULL;              } };     두 링크드 리스트의 만나는 지점을 찾으면 된다.   길이를 구한 다음, 더 긴 애를 길이의 차이만큼 움직여 준다.   그리고 두 리스트를 같이 움직이면서, 같은지를 판별하면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Intersection-of-Two-Linked-Lists/",
        "teaser": null
      },{
        "title": "[OS] Ch8. 연습문제",
        "excerpt":"1. 내부 단편화와 외부 단편화 사이의 차이점을 설명하고, 어떻게 다른지 설명하시오.  내부 단편화 : 프로세스보다 분할 된 공간이 커 잉여 공간이 남는 것 외부 단편화 : 할당된 공간을 모으면 충분히 프로세스가 들어갈 수 있지만 프로세스가 들어갈 공간은 없는 것   5. 다음의 쟁점들을 참고하여 연속적 메모리 할당, 순수 세그멘테이션, 순수 페이징 기법들을 비교하시오.  a. 외부 단편화 연속 메모리 할당 (고정 파티션 크기) : X 연속 메모리 할당 (가변 파티션 크기) : O 순수 세그멘테이션 : O 순수 페이징 : X   b. 내부 단편화 연속 메모리 할당 (고정 파티션 크기) : O 연속 메모리 할당 (가변 파티션 크기) : X 순수 세그멘테이션 : X 순수 페이징 : O   c. 프로세스 사이의 코드 공유 가능성 연속 메모리 할당 (고정 파티션 크기) : X 연속 메모리 할당 (가변 파티션 크기) : X 순수 세그멘테이션 : O 순수 페이징 : O   7. IOS, Android와 같은 모바일 운영체제에서 스와핑을 지원하지 않는 이유를 설명하시오.  모바일 기기들은 플래시 메모리를 사용하기 때문에 공간이 한정되어 있기 때문이다.   14. 물리 메모리의 최대 크기는 얼마인가?  32비트 컴퓨터라면 2^32 = 4GB   18. 세그멘테이션과 페이징 기법을 결합하여 사용하는 이유는 무엇 때문인가?  페이지 테이블이 클 때 유용한 기법이다. 세그먼트가 매우 커서 할당에 시간이 오래 걸리는 것을 방지할 수 있다.   21. 페이지 테이블을 페이징 하는 목적은 무엇인가?  페이지 테이블을 페이징 함으로서 페이지 테이블은 매우 커질 수 있다. 메모리 할당 방식을 단순화 시킬 수 있고, 사용되지 않는 페이지를 쉽게 스와핑 할 수 있다.  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch8.-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[OS] Ch9. 연습문제",
        "excerpt":"2. 스레드의 상태를 준비 완료(ready),실행(running),봉쇄됨(blocked)으로 간단하게 정의 할 수 있다. 여기서 준비 완료는 실행할 준비가 되어 스케줄 되기를 기다리고 있는 상태이고, 실행은 처리기에서 실행 중인 상태 그리고 입출력 완료를 기다리는 것과 같은 대기 상태가 봉쇄됨이다. 이러한 상태를 도시한 그림이 9.30에 나와 있다. 스레드가 실행상태라고 가정하고 다음 질문에 답하시오.  a. 페이지 부재가 발생하면 스레드는 상태를 변화시키는가? 그렇다면 변화된 새로운 상태는 무엇인가? b. 페이지 테이블을 참조하여 해결할 수 있는 TLB 미스를 발생시킬 경우 스레드는 상태를 변화시키는가? 그렇다면 변화된 새로운 상태는 무엇인가? c. 페이지 테이블에 의해 주소 참조가 해결된다면 스레드는 상태를 변화시키는가? 그렇다면 새로운 상태는 무엇인가?   3. 순수 요구 페이징을 사용하는 시스템이 있다고 하자.  a. 프로세스가 처음 실행을 시작할 때, 페이지 부재율은 어떻게 되는가? b. 프로세서의 작업 집합이 메모리 적재된 후에는 페이지 부재율은 어떻게 되는가? c. 프로세서의 지역성이 변하고 새로운 작업 집합의 크기가 너무 커서 자유 메모리에 적재될 수 없다고 가정하자. 이 상황을 해결하기 위하여 시스템 설계자가 선택 할 수 있는 결정들을 제시하시오.   4. 쓰기 시 복사가 어떤 기능인지 설명하고 이 기능을 어떤 상황에서 사용하는 것이 좋은지 설명하시오. 이 기능을 구현하기 위한 하드웨어 지원 사항은 무엇인가?   11. LFU 교체 정책이 LRU 교체 정책보다 더 적은 수의 페이지 부재를 발생시키는 상황에 대해 설명하시오. 또한 반대의 경우는 어떤 경우인지 설명하시오.   14. 다음과 같이 측정된 이용률을 가진 요구 페이징 시스템을 생각해 보시오.  CPU 이용률 20% 페이징 디스크 97.7% 기타 입출력 장치 5%   다음 항목 각각에 대해 CPU 이용률을 개선할 수 있는지(또는 개선 가능성이 있는지) 답하고 그 이유를 설명하시오.   a. 더 빠른 CPU 설치 b. 더 큰 페이징 디스크 설치 c. 다중 프로그래밍의 정도 증가 d. 다중 프로그래밍의 정도 감소 e. 주 메모리 추가 장착 f. 더 빠른 하드디스크나 여러 개의 하드디스크를 가진 다중 제어기의 설치 g. 페이지 인출 알고리즘에 프리페이징 추가 h. 페이지 크기 증가   16. 여러분이 사용하는 페이징 시스템의 교체 정책이 각 페이지를 정기적으로 검사하고 마지막 검사 이후에 참조되지 않은 페이지를 쫓아내는 정책이라고 가정하자. LRU 또는 2차 기회 교체 정책 알고리즘 대신에 이러한 정책을 사용할 경우 이해득실은 어떻게 되는가?   19. 스레싱의 원인은 무엇인가? 시스템이 스레싱을 발견하는 방법은 무엇이며, 일단 스레싱이 발견되면 이 문제를 해결하기 위해 시스템은 무엇을 할 수 있는가?   23. 사용자 수준 스레드와 커널 수준 스레드를 지원하는 시스템이 있다고 하자. 사용자 수준 스레드와 커널 수준 스레드의 사상은 일대일 사상을 사용한다. 즉 사용자 수준 스레드에 대응되는 하나의 커널 스레드가 존재한다. 다중프로세스는 (a) 전체 프로세스의 작업 집합 또는 (b) 각 스레드의 작업 집합으로 구성되는가? 이유를 설명하시오.   25. 프로세스에 서로 다른 크기의 페이지들을 할당하는 시스템을 생각하자. 이러한 페이징 시스템의 장점은 무엇인가? 가상 메모리 시스템을 어떻게 수정하면 이러한 기능을 제공할 수 있는가?  ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch9.-%EC%97%B0%EC%8A%B5%EB%AC%B8%EC%A0%9C/",
        "teaser": null
      },{
        "title": "[OS] Ch9. 가상 메모리",
        "excerpt":"가상 메모리     물리 메모리 개념과 사용자의 논리 메모리 개념을 분리한 것   가상 주소 공간 : 프로세스가 메모리에 저장되는 논리적인 번지   페이지 공유를 통해 파일이나 메모리가 프로세스들에 공유될 수 있는 장점이 있다.   요구 페이징 (Demand Paging)     메모리에 필요한 것들만 적재한다.   필요한 페이지는 swap in, 필요 없으면 swap out   스와핑 기법과 비슷 - 페이저라는 용어 사용   기본 개념     메모리에 존재하는 페이지에 접근하면 실행, 존재하지 않는다면 페이지 부재 트랩 발생   페이지 부재 처리 과정            메모리 참조가 유효한지, 무효한지 판단.       무효하다면 프로세스 중단, 유효하지만 페이지가 없다면 디스크로부터 가져오기       빈 공간 (자유 프레임)을 찾는다.       새로 할당된 프레임에 페이지를 읽어 들이도록 요청한다.       페이지 테이블 갱신, 프로세스의 내부 테이블 수정       트랩에 의해 중단된 명령어 수행.           페이지 교체     페이지 교체 과정            디스크에서 필요한 페이지의 위치를 알아낸다.       빈 페이지 프레임을 찾는다.                    빈 프레임이 있다면 사용한다.           없다면 희생될 프레임을 선정하기 위해 페이지 교체 알고리즘을 실행한다.           희생될 페이지를 디스크에 기록하고, 테이블을 수정한다.                       빼앗은 프레임에 새 페이지를 읽어오고 테이브를 수행한다.       트랩이 발생한 지점에서부터 프로세스를 실행한다.           페이지 교체 알고리즘     FIFO (First In First Out)            가장 오래 된 페이지 교체       이해하기 쉽고, 구현도 쉽다.       성능이 항상 좋지 않다. 교체한 페이지가 자주 사용되는 페이지일 수도 있다.       Belady의 모순 프로세스에게 프레임을 더 주었는데 페이지 부재율은 더 상승한다.           최적 페이지 교체 (Optimal Page Replacement)            가장 오랫동안 사용되지 않는 페이지 교체       가장 낮은 페이지 부재율 보장       구현하기 어렵다.       Belady 모순 X           LRU (Least Recently Used)            가장 오랜 기간동안 사용되지 않은 페이지 교체       카운터 변수나 스택을 사용한다.       Belady 모순 X           LFU (Least Frequently Used)            가장 참조 횟수가 적은 페이지 교체       교체 대상이 여러 개인 경우, LRU 이용       구현 비용이 크다.           스레싱 (Thrashing)     페이지 부재가 연속적으로 발생 돼 프로세스 수행 시간보다 페이지 교체 시간이 더 많을 경우   스레싱의 원인     부적절한 페이지 교체 알고리즘            Belady 모순           시스템 리소스 부족            작은 캐시       낮은 메모리 용량           프로그램 메모리 관리 실패            과도한 스레드 생성, 무분별한 fork           스레싱 해결 방법     Working Set Model            프로세스가 많이 참조하는 페이지 집합을 메모리 공간에 계속 상주시켜 빈번한 페이지 교체현상(스레싱)을 줄이는 방법       다중 프로그래밍 높임, CPU 사용률 최적화       Working set 관리 복잡, Window 사이즈 설정 모호       지역성 활용           Page Fault Frequency            페이지 부재율의 상, 하한으로 페이지 부재율을 예측하고 조절       페이지 부재율이 높으면 프레임 할당, 낮으면 회수       페이지 부재 발생 시에만 실행, 직접 페이지 부재율 조절 가능       프로세스 중지 과정 발생       Working set보다 오버헤드가 작다.          ","categories": ["os"],
        "tags": [],
        "url": "/os/OS-Ch9.%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[leetcode] Number of Longest Increasing Subsequence",
        "excerpt":"[leetcode] Number of Longest Increasing Subsequence  문제 링크   class Solution { public:     int findNumberOfLIS(vector&lt;int&gt;&amp; nums) {         int n = nums.size();         if(!n) return 0;                  int dp[n+1];         int cnt[n+1];                   for(int i=0; i&lt;n+1; i++) {dp[i] = 1; cnt[i] = 1;}                  int cur = 0;         for(int i=0; i&lt;n; i++) {             for(int j=0; j&lt;i; j++) {                 if(nums[i] &gt; nums[j]) {                     if(dp[i] &lt; dp[j] + 1) {                         cnt[i] = cnt[j];                         dp[i] = dp[j] + 1;                     } else if(dp[i] == dp[j] + 1) {                         cnt[i] += cnt[j];                     }                 }             }             cur = max(cur, dp[i]);         }         int ans = 0;         for(int i=0; i&lt;n; i++) if(dp[i] == cur) ans += cnt[i];                  return ans;     } };      LIS의 경우의 수를 구하는 문제이다.   dp 배열 말고 경우의 수를 저장하는 cnt 배열을 추가로 선언 해 주고 1로 초기화 시켜 준다.   IS인 경우에만 다음의 검사를 해준다.            뻗어나갈 수 있는 경우의 수가 존재한다면(dp[i] == dp[j] + 1)                    cnt[i]는 cnt[j]가 더해진다                       경우의 수가 존재하지 않는다면 (dp[i] &gt; dp[j] + 1)                    cnt[i]는 그대로 유지된다.                           마지막으로 가장 긴 LIS가 여러 개 있을 수 있으므로, 해당 LIS에 해당하는 경우의 수들을 모두 더해준다. (2,2,2,2와 같은 경우)  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Number-Of-Longest-Increasing-Subsequence/",
        "teaser": null
      },{
        "title": "[leetcode] Palindrome Partitioning",
        "excerpt":"[leetcode] Palindrome Partitioning  문제 링크   backtracking  class Solution { public:     int isPalindrome(string s, int l, int r) {         int start = l;         int end = r;         while(start &lt; end) {             if(s[start++] != s[end--]) return false;         }         return true;     }          void dfs(vector &lt;vector&lt;string&gt;&gt;&amp; ans, vector &lt;string&gt;&amp; candidates, string s, int idx) {                  if(idx == s.length()) {             ans.push_back(candidates);         } else {                for(int i=idx; i&lt;s.length(); i++) {                 if(isPalindrome(s, idx, i)) {                     candidates.push_back(s.substr(idx, i-idx+1));                     dfs(ans, candidates, s, i+1);                     candidates.pop_back();                 }             }         }     }          vector&lt;vector&lt;string&gt;&gt; partition(string s) {         vector &lt;vector&lt;string&gt;&gt; ans;         vector &lt;string&gt; candidates;                  dfs(ans, candidates, s, 0);                  return ans;     } };   backtracking + dp  class Solution { public:     int dp[204][204];     void dfs(vector &lt;vector&lt;string&gt;&gt;&amp; ans, vector &lt;string&gt;&amp; candidates, string s, int start) {                  if(start == s.length()) {             ans.push_back(candidates);         } else {                for(int end=start; end&lt;s.length(); end++) {                 if(s[end] == s[start] &amp;&amp; (end - start &lt;= 2 || dp[start+1][end-1])) {                     dp[start][end] = 1;                     candidates.push_back(s.substr(start, end-start+1));                     dfs(ans, candidates, s, end+1);                     candidates.pop_back();                 }             }         }     }          vector&lt;vector&lt;string&gt;&gt; partition(string s) {         vector &lt;vector&lt;string&gt;&gt; ans;         vector &lt;string&gt; candidates;                  dfs(ans, candidates, s, 0);                  return ans;     } };  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Palindrome-Partitioning/",
        "teaser": null
      },{
        "title": "정렬 알고리즘 정리",
        "excerpt":"안정 정렬   버블 정렬  for(int i=0; i&lt;n; i++) {     for(int j=i; j&lt;n-i-1; j++) {         if(arr[j] &gt; arr[j+1]) swap(arr[j], arr[j+1]);     } }  Time Complexity O(n^2)   삽입 정렬  for(int i=1; i&lt;n; i++) {     int j = i-1;     while(j &gt;= 0 &amp;&amp; arr[j] &gt; arr[j-1]) {         swap(arr[j], arr[j-1]);         j--;     } }  Time Complexity Worst O(n^2) Best O(n) 비교 연산은 많지만, swap연산은 적다. 정렬된 데이터일 경우 효율적   합병 정렬  void merge(int start, int mid, int end) {     int left = start;     int right = mid + 1;     vector &lt;int&gt; temp;     while(left &lt;= start &amp;&amp; right &lt;= end) {         if(arr[left] &gt; arr[right]) temp.push_back(arr[right++]);         else temp.push_back(arr[left++]);     }      while(left &lt;= start) temp.push_back(arr[left++]);     while(right &lt;= end) temp.push_back(arr[right++]);      int cnt = 0;     for(int idx = start; idx&lt;=end; i++) {         arr[idx] = temp[cnt++];     } }  void mergeSort(int left, int right) {     if(left &lt; right) {         int mid = (left + right) / 2;         mergeSort(left, mid);         mergeSort(mid + 1, right);         merge(left, mid, right);     } }  Time Complexity O(logn)     UNSTABLE   선택 정렬  for(int i=0; i&lt;n; i++) {     int target = i;     for(int j=i+1; j&lt;n; j++) {         if(arr[target] &gt; arr[j]) target = j;     }     swap(arr[target], arr[i]); }  Time Complexity O(n^2)   퀵 정렬  int partition(int left, int right) {     int pivot = left;     int low = left + 1;     int high = right;      while(low &lt;= high) {         while(low &lt;= right &amp;&amp; ans[pivot] &gt;= ans[low]) low++;         while(high &gt; left &amp;&amp; ans[pivot] &lt;= ans[high]) high--;          if(low &gt; high) swap(ans[pivot], ans[high]);         else swap(ans[low], ans[high]);     }      return high;  } int quickSort(int left, int right) {     if(left &lt; right) {         int p = partition(left, right);         quickSort(left, p-1);         quickSort(p+1, right);     } }    Time Complexity Best O(logn) Worst O(n^2) 역순 정렬일 때는 n^2의 시간복잡도를 가진다. 이를 해결하기 위해서는 피봇을 랜덤이나 가운데 값으로 고르면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/%EC%A0%95%EB%A0%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EC%A0%95%EB%A6%AC/",
        "teaser": null
      },{
        "title": "[leetcode] Palindrome Linked List",
        "excerpt":"[leetcode] Palindrome Linked List  문제 링크   class Solution { public:     bool isPalindrome(ListNode* head) {         if(!head || !head-&gt;next) return true;                  ListNode *slow = head;         ListNode *fast = head;                  while(fast &amp;&amp; fast-&gt;next) {             slow = slow-&gt;next;             fast = fast-&gt;next-&gt;next;         }                  fast = slow; // mid         slow = head;         ListNode *prev = NULL;         while(fast) {             ListNode *tmp = fast-&gt;next;             fast-&gt;next = prev;             prev = fast;             fast = tmp;         }                  while(1) {             if(!slow || !prev || slow == prev) break;             if(slow-&gt;val != prev-&gt;val) return false;             slow = slow-&gt;next;             prev = prev-&gt;next;         }                  return true;     } };      지금까지 공부한 LinkedList의 기법?은 다 나온듯   중간을 찾고, 중간부터 뒤집는다.   뒤집은 리스트랑 앞부분 리스트를 비교하면서 palindrome인지 확인 해 주면 된다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Palindrome-Linked-List/",
        "teaser": null
      },{
        "title": "[leetcode] Best Time to Buy and Sell Stock",
        "excerpt":"[leetcode] Best Time to Buy and Sell Stock  문제 링크   class Solution { public:     int maxProfit(vector&lt;int&gt;&amp; prices) {         int n = prices.size();         if(n &lt; 2) return 0;          int ans = 0;         int minimum = prices[0];                  for(int i=1; i&lt;n; i++) {             if(minimum &lt; prices[i]) {                 ans = max(ans, prices[i] - minimum);             }                          minimum = min(minimum, prices[i]);         }                  return ans;     } };  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Best-Time-to-Buy-and-Sell-Stock/",
        "teaser": null
      },{
        "title": "[leetcode] Convert Sorted List to Binary Search Tree",
        "excerpt":"[leetcode] Convert Sorted List to Binary Search Tree  문제 링크   class Solution { public:     TreeNode* sortedListToBST(ListNode* head) {         if(head == NULL) return NULL;         if(head-&gt;next == NULL) return new TreeNode(head-&gt;val);                  // get mid         ListNode *slow = head;         ListNode *fast = head;         ListNode *pre = head;         while(fast &amp;&amp; fast-&gt;next) {             pre = slow;             slow = slow-&gt;next;             fast = fast-&gt;next-&gt;next;         }         pre-&gt;next = NULL;                  TreeNode *root = new TreeNode(slow-&gt;val);         root-&gt;left = sortedListToBST(head);         root-&gt;right = sortedListToBST(slow-&gt;next);         return root;     } };      좋은 트리 + 리스트 문제라서 기록한다.   정렬된 리스트를 이진검색트리로 만드는 문제이다.   재귀로 접근해서 풀 수 있는데, base condition은 head가 null일 경우, null 리턴하고 노드가 하나만 있을 경우는 해당 노드를 리턴한다.   slow, fast포인터로 가운데 값을 찾는다. 이 리스트를 절반으로 나누기 위해 prev노드로 slow의 이전 노드를 저장한다.   prev-&gt;next를 null처리 해 주어 리스트를 두 개로 나눈다.   중간의 노드가 root가 되고, 해당 노드의 left는 왼쪽 리스트의 중간 값, right는 왼쪽 리스트의 중간값이 된다.`  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Convert-Sorted-List-to-Binary-Search-Tree/",
        "teaser": null
      },{
        "title": "[leetcode] Decode String",
        "excerpt":"[leetcode] Decode String  문제 링크   class Solution { public:     string decodeString(string s) {         stack &lt;char&gt; st;                  for(char c: s) {             if(c == ']') {                         string temp;                  while(!st.empty()) {                     if(st.top() == '[') { st.pop(); break; }                     temp += st.top();                     st.pop();                 }                                  reverse(temp.begin(), temp.end());                                  string number;                 while(!st.empty() &amp;&amp; isdigit(st.top())){                     number = st.top() + number;                     st.pop();                 }                                  int num = stoi(number);                 while(num--) {                     for(int i=0; i&lt;temp.size(); i++) st.push(temp[i]);                 }                              } else {                 st.push(c);             }         }                          string ans;          while(!st.empty()) {             ans += st.top();             st.pop();         }                          reverse(ans.begin(), ans.end());         return ans;     } };      코테에서 비슷한 문제를 본 것 같아서 기록한다.   ]가 아니면 스택에 넣어주고,   ]를 만나면 해당 괄호를 처리 해 준다.            괄호가 닫힐 때까지 글자들을 더해준다.       괄호가 닫히면 더한 글자들을 거꾸로 돌려준다.       괄호 앞의 숫자들을 구한다.       숫자만큼 글자들을 스택에 다시 넣어준다.           모든 처리가 끝나면 스택에 들어있는 글자들을 ans에 더해주고, reverse 처리 해 준다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Decode-String/",
        "teaser": null
      },{
        "title": "[leetcode] Search in Rotated Sorted Array",
        "excerpt":"[leetcode] Search in Rotated Sorted Array  문제 링크   class Solution { public:     int search(vector&lt;int&gt;&amp; arr, int target) {         int left = 0;         int right = arr.size()-1;                  while(left &lt;= right){             int mid = left + (right - left) / 2;                          if(arr[mid] == target) return mid;             else if(arr[mid] &lt;= arr[right]) {                 if(arr[mid] &lt; target &amp;&amp; target &lt;= arr[right]) left = mid + 1;                 else right = mid - 1;             } else {                 if(arr[mid] &gt; target &amp;&amp; target &gt;= arr[left]) right = mid - 1;                 else left = mid + 1;             }         }         return -1;     } };      엄청 헷갈리는 문제라서 제대로 정리하기 위해 기록한다.   이분탐색으로 접근하면 되는 문제이다.     첫 번째 배열과 두 번째 배열로 나뉠 것이다.            4,5,6,7,1,2,3이라면, 4,5,6,7은 첫 번째 배열, 1,2,3을 두 번째 배열이라고 하자.           arr[mid] &lt;= arr[right]일 때, (mid-&gt;right으로 오름차순으로 배열된 배열)            arr[mid] &lt; target &lt;= arr[right] 이라면, target과 mid가 같은 배열에 있기 때문에 left를 mid+1로 옮겨서 범위를 좁혀준다.       이외의 경우에는 target과 mid가 다른 배열에 있기 때문에 right을 mid-1로 옮겨준다.           이외의 경우일 때, (섞인 배열)            arr[left] &lt;= target &lt; arr[mid] 이라면, target과 mid가 다른 배열에 있기 때문에 right = mid-1이 된다.       이하 같다.          ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Search-in-Rotated-Sorted-Array/",
        "teaser": null
      },{
        "title": "[leetcode] Flatten Binary Tree to Linked List",
        "excerpt":"[leetcode] Flatten Binary Tree to Linked List  문제 링크   Recursion  class Solution { public:     void flatten(TreeNode* root) {         if(!root) return;           flatten(root-&gt;left);         flatten(root-&gt;right);         if(root-&gt;left) {             TreeNode *right = root-&gt;right; // save right node             root-&gt;right = root-&gt;left;             root-&gt;left = NULL;             while(root-&gt;right) root = root-&gt;right;             root-&gt;right = right;             flatten(root-&gt;right);         }         return;     } };   Iterative           void flatten(TreeNode* root) {                  while(root) {             TreeNode *cur = root;             TreeNode *right = root-&gt;right;             root-&gt;right = root-&gt;left;             root-&gt;left = NULL;             while(cur-&gt;right) cur = cur-&gt;right;             cur-&gt;right = right;                          root = root-&gt;right;         }     }       후위 순회로 가장 아래에 있는 노드중, 작은 값부터 계산해서 올라온다.   만약 Left가 있다면, right을 저장해 놓고, left를 right로 옮긴다.   저장된 right를 맨 아래 right에 부착한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-Flatten-Binary-Tree-to-Linked-List/",
        "teaser": null
      },{
        "title": "[leetcode] House Robber III",
        "excerpt":"[leetcode] House Robber III  문제 링크   Recursive (시간 초과)  class Solution { public:     int dfs(TreeNode *cur, bool isParentRobbed) {         if(cur == NULL) return 0;                  if(isParentRobbed) {             // cannot rob here             return dfs(cur-&gt;left, false) + dfs(cur-&gt;right, false);         } else {             // rob here             int rob = cur-&gt;val + dfs(cur-&gt;left, true) + dfs(cur-&gt;right, true);             int not_rob = dfs(cur-&gt;left, false) + dfs(cur-&gt;right, false);                          return max(rob, not_rob);         }              }          int rob(TreeNode* root) {         return dfs(root, false);     } };     연결된 노드끼리 도둑질을 하면 안 되기 때문에, 부모 노드에 따라 훔칠지 훔치지 않을지가 결정된다.   만약 부모 노드를 훔쳤다면, 자식 노드는 훔치면 안된다.   부모 노드를 훔치지 않았다면, 자식 노드를 훔치거나, 훔치지 않거나의 두 경우로 나뉜다.            이 경우에는 훔친 경우, 훔치지 않은 경우를 비교 해 큰 값을 저장해주면 된다.           이렇게 풀면 시간초과가 난다.   Memoization  class Solution { public:     unordered_map&lt;TreeNode*, vector&lt;int&gt;&gt; m;     int dfs(TreeNode *cur, bool isParentRobbed) {         if(cur == NULL) return 0;                  if(m.find(cur) != m.end() &amp;&amp; m[cur][isParentRobbed] &gt;= 0) return m[cur][isParentRobbed];         else {             if(m.find(cur) == m.end()) m[cur] = {-1, -1};                          int rob = cur-&gt;val + dfs(cur-&gt;left, true) + dfs(cur-&gt;right, true);             int not_rob = dfs(cur-&gt;left, false) + dfs(cur-&gt;right, false);             if(isParentRobbed) return m[cur][isParentRobbed] = not_rob;             else return m[cur][isParentRobbed] = max(not_rob, rob);         }              }          int rob(TreeNode* root) {         return dfs(root, false);     } };     중복된 계산을 제거 해 주기 위해 해쉬 맵을 사용해 결과를 저장해준다.   맵에 계산 결과가 저장 되어 있다면, 해당 결과를 리턴한다.   결과가 저장 되어 있지 않다면 훔친 경우, 훔치지 않은 경우를 맵에 저장하여 리턴한다.  ","categories": ["algorithm"],
        "tags": [],
        "url": "/algorithm/leetcode-House-Robber-III/",
        "teaser": null
      },{
        "title": "[TIL] webpack.config.js 살펴보기",
        "excerpt":"React 개발 환경 설정 시 CRA로만 진행했었다. 멘토님께서 CRA는 불필요한 것들이 많으니 직접 customizing을 해 가는게 좋다고 해주셨다. React 공식 documentation에 나와있는 해당 article을 보며 React 개발 환경을 기초부터 진행 해 봤다. 이 과정에서 webpack.config.js에 있는 환경변수들의 의미를 살필 수 있었다.   webpack.config.js  const path = require(\"path\"); const webpack = require(\"webpack\");  module.exports = {     // Where to start bundling     // 번들링을 시작하는 entry     entry: \"./src/index.js\",      mode: \"development\",     // Define how exported js modules are transformed (defined in rules list)     // exported된 js 모듈들을 어떻게 변환시킬지 정의한다. (rules 리스트에 작성)     module: {         rules: [             {                 // conditions to match file                 test: /\\.(js|jsx)$/,                 // match anything outside of node_modules and bower_components                 // node_modules와 bower_components 이외의 파일들을 matching 한다                 exclude: /(node_modules|bower_components)/,                 loader: \"babel-loader\",                 options: { presets: [\"@babel/env\"] }             },             {                 test: /\\.css$/,                 use: [\"style-loader\", \"css-loader\"]             }         ]     },          // specify which extensions Webpack will resolve     // 웹팩이 어떤 extension들을 resolve 할 것인지 정의     resolve: { extensions: [\"*\", \".js\", \".jsx\"] },       // ** notice **     // output.publicPath and devServer.publicPath are different!     // output.publicPath와 devServer.publicPath는 다르다      // Where to put bundled code     // 번들링된 코드를 어디에 둘 것인지 정의     output: {         // what directory bundle should go in         // webpack-dev-server serve files from here         // bundle된 것이 어디에 저장 될 것인지 정의         // webpack-dev-server가 여기에서 파일들을 serve한다.         path: path.resolve(__dirname, \"dist/\"),         // specifies the public URL of the directory for dev-server         // if thie set is wrong, will retrun 404         // dev-server이 접근할 public URL을 정의한다.         // 잘못 정의할 시 404 코드를 리턴한다.         publicPath: \"/dist/\",         filename: \"bundle.js\"     },          // For dev server     devServer: {         // location where the static files exist         // static 파일들이 어디에 위치해야 하는지         contentBase: path.join(__dirname, \"public/\"),         port: 3000,         // tell server where our bundled code is located         // Dev server에게 번들링된 코드라 어디에 존재하는지 알려줌         publicPath: \"http://localhost:3000/dist/\",         // Hot Module Replacement         // module will updated at runtime without fully refreshing         // HMR을 이용할 시 refresh하지 않고도 module이 업데이트 된다.         hotOnly: true     },     plugins: [new webpack.HotModuleReplacementPlugin()] };    Article을 보면 좀 더 풀어서 설명되어 있으니 참고하길 바란다.  ","categories": ["til"],
        "tags": [],
        "url": "/til/TIL-webpack.config.js-%EC%82%B4%ED%8E%B4%EB%B3%B4%EA%B8%B0/",
        "teaser": null
      }]
